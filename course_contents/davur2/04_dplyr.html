<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Michiel Noback" />
  <title>The dplyr package</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">
body
{
margin: 0 0 0 0;
padding: 0 0 0 0;
width: 100%;
height: 100%;
color: black;
background-color: white;
font-family: "Gill Sans MT", "Gill Sans", GillSans, sans-serif;
font-size: 14pt;
}
div.toolbar {
position: fixed; z-index: 200;
top: auto; bottom: 0; left: 0; right: 0;
height: 1.2em; text-align: right;
padding-left: 1em;
padding-right: 1em; font-size: 60%;
color: DimGray;
background-color: rgb(240,240,240);
border-top: solid 1px rgb(180,180,180);
}
div.toolbar span.copyright {
color: DimGray;
margin-left: 0.5em;
}
div.initial_prompt {
position: absolute;
z-index: 1000;
bottom: 1.2em;
width: 100%;
background-color: rgb(200,200,200);
opacity: 0.35;
background-color: rgb(200,200,200, 0.35);
cursor: pointer;
}
div.initial_prompt p.help {
text-align: center;
}
div.initial_prompt p.close {
text-align: right;
font-style: italic;
}
div.slidy_toc {
position: absolute;
z-index: 300;
width: 60%;
max-width: 30em;
height: 30em;
overflow: auto;
top: auto;
right: auto;
left: 4em;
bottom: 4em;
padding: 1em;
background: rgb(240,240,240);
border-style: solid;
border-width: 2px;
font-size: 60%;
}
div.slidy_toc .toc_heading {
text-align: center;
width: 100%;
margin: 0;
margin-bottom: 1em;
border-bottom-style: solid;
border-bottom-color: rgb(180,180,180);
border-bottom-width: 1px;
}
div.slide {
z-index: 20;
margin: 0 0 0 0;
padding-top: 0;
padding-bottom: 0;
padding-left: 20px;
padding-right: 20px;
border-width: 0;
clear: both;
top: 0;
bottom: 0;
left: 0;
right: 0;
line-height: 120%;
background-color: transparent;
}
div.background {
display: none;
}
div.handout {
margin-left: 20px;
margin-right: 20px;
}
div.slide.titlepage {
text-align: center;
}
div.slide.titlepage h1 {
padding-top: 10%;
margin-right: 0;
}
div.slide h1 {
padding-left: 0;
padding-right: 20pt;
padding-top: 4pt;
padding-bottom: 4pt;
margin-top: 0;
margin-left: 0;
margin-right: 60pt;
margin-bottom: 0.5em;
display: block; font-size: 160%;
line-height: 1.2em;
background: transparent;
}
@media screen and (max-device-width: 1024px)
{
div.slide { font-size: 100%; }
}
@media screen and (max-device-width: 800px)
{
div.slide { font-size: 200%; }
div.slidy_toc {
top: 1em;
left: 1em;
right: auto;
width: 80%;
font-size: 180%;
}
}
div.toc-heading {
width: 100%;
border-bottom: solid 1px rgb(180,180,180);
margin-bottom: 1em;
text-align: center;
}
img {
image-rendering: optimize-quality;
}
pre {
font-size: 80%;
font-weight: bold;
line-height: 120%;
padding-top: 0.2em;
padding-bottom: 0.2em;
padding-left: 1em;
padding-right: 1em;
border-style: solid;
border-left-width: 1em;
border-top-width: thin;
border-right-width: thin;
border-bottom-width: thin;
border-color: #95ABD0;
color: #00428C;
background-color: #E4E5E7;
}
li pre { margin-left: 0; }
blockquote { font-style: italic }
img { background-color: transparent }
p.copyright { font-size: smaller }
.center { text-align: center }
.footnote { font-size: smaller; margin-left: 2em; }
a img { border-width: 0; border-style: none }
a:visited { color: navy }
a:link { color: navy }
a:hover { color: red; text-decoration: underline }
a:active { color: red; text-decoration: underline }
a {text-decoration: none}
.toolbar a:link {color: blue}
.toolbar a:visited {color: blue}
.toolbar a:active {color: red}
.toolbar a:hover {color: red}
ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
li { margin-left: 0.5em; margin-top: 0.5em; }
li li { font-size: 85%; font-style: italic }
li li li { font-size: 85%; font-style: normal }
div dt
{
margin-left: 0;
margin-top: 1em;
margin-bottom: 0.5em;
font-weight: bold;
}
div dd
{
margin-left: 2em;
margin-bottom: 0.5em;
}
p,pre,ul,ol,blockquote,h2,h3,h4,h5,h6,dl,table {
margin-left: 1em;
margin-right: 1em;
}
p.subhead { font-weight: bold; margin-top: 2em; }
.smaller { font-size: smaller }
.bigger { font-size: 130% }
td,th { padding: 0.2em }
ul {
margin: 0.5em 1.5em 0.5em 1.5em;
padding: 0;
}
ol {
margin: 0.5em 1.5em 0.5em 1.5em;
padding: 0;
}
ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
ul li { list-style: square;
margin: 0.1em 0em 0.6em 0;
padding: 0 0 0 0;
line-height: 140%;
}
ol li { margin: 0.1em 0em 0.6em 1.5em;
padding: 0 0 0 0px;
line-height: 140%;
list-style-type: decimal;
}
li ul li { font-size: 85%; font-style: italic;
list-style-type: disc;
background: transparent;
padding: 0 0 0 0;
}
li li ul li { font-size: 85%; font-style: normal;
list-style-type: circle;
background: transparent;
padding: 0 0 0 0;
}
li li li ul li {
list-style-type: disc;
background: transparent;
padding: 0 0 0 0;
}
li ol li {
list-style-type: decimal;
}
li li ol li {
list-style-type: decimal;
}

ol.outline li:hover { cursor: pointer }
ol.outline li.nofold:hover { cursor: default }
ul.outline li:hover { cursor: pointer }
ul.outline li.nofold:hover { cursor: default }
ol.outline { list-style:decimal; }
ol.outline ol { list-style-type:lower-alpha }
ol.outline li.nofold {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAIACAMzMzOvr/ywAAAAACQAJAAACD4SPoRvG614Dctb4MEMcFAA7) no-repeat 0px 0.5em;
}
ol.outline li.unfolded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACEYyPoivG614LAlg7ZZbxoR8UADs=) no-repeat 0px 0.5em;
}
ol.outline li.folded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACFIyPoiu2sJyCyoF7W3hxz850CFIAADs=) no-repeat 0px 0.5em;
}
ol.outline li.unfolded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACEYSPoivG614DIlg7ZZbxoQ8UADs=) no-repeat 0px 0.5em;
}
ol.outline li.folded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACFISPoiu2sZyCyoV7G3hxz850CFIAADs=) no-repeat 0px 0.5em;
}
ul.outline li.nofold {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAIACAMzMzOvr/ywAAAAACQAJAAACD4SPoRvG614Dctb4MEMcFAA7) no-repeat 0px 0.5em;
}
ul.outline li.unfolded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACEYyPoivG614LAlg7ZZbxoR8UADs=) no-repeat 0px 0.5em;
}
ul.outline li.folded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACFIyPoiu2sJyCyoF7W3hxz850CFIAADs=) no-repeat 0px 0.5em;
}
ul.outline li.unfolded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACEYSPoivG614DIlg7ZZbxoQ8UADs=) no-repeat 0px 0.5em;
}
ul.outline li.folded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACFISPoiu2sZyCyoV7G3hxz850CFIAADs=) no-repeat 0px 0.5em;
}

a.titleslide { font-weight: bold; font-style: italic }

img.hidden { display: none; visibility: hidden }
div.initial_prompt { display: none; visibility: hidden }
div.slide {
visibility: visible;
position: inherit;
}
div.handout {
border-top-style: solid;
border-top-width: thin;
border-top-color: black;
}
@media screen {
.hidden { display: none; visibility: visible }
div.slide.hidden { display: block; visibility: visible }
div.handout.hidden { display: block; visibility: visible }
div.background { display: none; visibility: hidden }
body.single_slide div.initial_prompt { display: block; visibility: visible }
body.single_slide div.background { display: block; visibility: visible }
body.single_slide div.background.hidden { display: none; visibility: hidden }
body.single_slide .invisible { visibility: hidden }
body.single_slide .hidden { display: none; visibility: hidden }
body.single_slide div.slide { position: absolute }
body.single_slide div.handout { display: none; visibility: hidden }
}
@media print {
.hidden { display: block; visibility: visible }
div.slide pre { font-size: 60%; padding-left: 0.5em; }
div.toolbar { display: none; visibility: hidden; }
div.slidy_toc { display: none; visibility: hidden; }
div.background { display: none; visibility: hidden; }
div.slide { page-break-before: always }

div.slide.first-slide { page-break-before: avoid }
}


.jslider table {
margin-left: 0em;
margin-right: 0em;
}

table.dataTable, .shiny-datatable-output div {
font-size: 14pt;
}

.dataTables_info, .dataTables_paginate {
font-size: 19px;
}

pre.sourceCode, code.sourceCode {
font-size: 80%;
}

label, button, input, select, textarea {
font-size: 14pt;
}

ul.nav, ul.nav li {
list-style-type: none;
}
</style>
  <script src="data:application/javascript;base64,Lyogc2xpZHkuanMKCiAgIENvcHlyaWdodCAoYykgMjAwNS0yMDEzIFczQyAoTUlULCBFUkNJTSwgS2VpbyksIEFsbCBSaWdodHMgUmVzZXJ2ZWQuCiAgIFczQyBsaWFiaWxpdHksIHRyYWRlbWFyaywgZG9jdW1lbnQgdXNlIGFuZCBzb2Z0d2FyZSBsaWNlbnNpbmcKICAgcnVsZXMgYXBwbHksIHNlZToKCiAgIGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvY29weXJpZ2h0LWRvY3VtZW50cwogICBodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsL2NvcHlyaWdodC1zb2Z0d2FyZQoKICAgRGVmaW5lcyBzaW5nbGUgbmFtZSAidzNjX3NsaWR5IiBpbiBnbG9iYWwgbmFtZXNwYWNlCiAgIEFkZHMgZXZlbnQgaGFuZGxlcnMgd2l0aG91dCB0cmFtcGxpbmcgb24gYW55IG90aGVycwoqLwoKLy8gdGhlIHNsaWR5IG9iamVjdCBpbXBsZW1lbnRhdGlvbgp2YXIgdzNjX3NsaWR5ID0gewogIC8vIGNsYXNzaWZ5IHdoaWNoIGtpbmQgb2YgYnJvd3NlciB3ZSdyZSBydW5uaW5nIHVuZGVyCiAgbnNfcG9zOiAodHlwZW9mIHdpbmRvdy5wYWdlWU9mZnNldCE9J3VuZGVmaW5lZCcpLAogIGtodG1sOiAoKG5hdmlnYXRvci51c2VyQWdlbnQpLmluZGV4T2YoIktIVE1MIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgb3BlcmE6ICgobmF2aWdhdG9yLnVzZXJBZ2VudCkuaW5kZXhPZigiT3BlcmEiKSA+PSAwID8gdHJ1ZSA6IGZhbHNlKSwKICBpcGFkOiAoKG5hdmlnYXRvci51c2VyQWdlbnQpLmluZGV4T2YoImlQYWQiKSA+PSAwID8gdHJ1ZSA6IGZhbHNlKSwKICBpcGhvbmU6ICgobmF2aWdhdG9yLnVzZXJBZ2VudCkuaW5kZXhPZigiaVBob25lIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgYW5kcm9pZDogKChuYXZpZ2F0b3IudXNlckFnZW50KS5pbmRleE9mKCJBbmRyb2lkIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgaWU6ICh0eXBlb2YgZG9jdW1lbnQuYWxsICE9ICJ1bmRlZmluZWQiICYmICF0aGlzLm9wZXJhKSwKICBpZTY6ICghdGhpcy5uc19wb3MgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIDYiKSAhPSAtMSksCiAgaWU3OiAoIXRoaXMubnNfcG9zICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiTVNJRSA3IikgIT0gLTEpLAogIGllODogKCF0aGlzLm5zX3BvcyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUgOCIpICE9IC0xKSwKICBpZTk6ICghdGhpcy5uc19wb3MgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIDkiKSAhPSAtMSksCgogIC8vIGRhdGEgZm9yIHN3aXBlIGFuZCBkb3VibGUgdGFwIGRldGVjdGlvbiBvbiB0b3VjaCBzY3JlZW5zCiAgbGFzdF90YXA6IDAsCiAgcHJldl90YXA6IDAsCiAgc3RhcnRfeDogMCwKICBzdGFydF95OiAwLAogIGRlbHRhX3g6IDAsCiAgZGVsdGFfeTogMCwKCiAgLy8gYXJlIHdlIHJ1bm5pbmcgYXMgWEhUTUw/IChkb2Vzbid0IHdvcmsgb24gT3BlcmEpCiAgaXNfeGh0bWw6IC94bWwvLnRlc3QoZG9jdW1lbnQuY29udGVudFR5cGUpLAoKICBzbGlkZV9udW1iZXI6IDAsIC8vIGludGVnZXIgc2xpZGUgY291bnQ6IDAsIDEsIDIsIC4uLgogIHNsaWRlX251bWJlcl9lbGVtZW50OiBudWxsLCAvLyBlbGVtZW50IGNvbnRhaW5pbmcgc2xpZGUgbnVtYmVyCiAgc2xpZGVzOiBbXSwgLy8gc2V0IHRvIGFycmF5IG9mIHNsaWRlIGRpdidzCiAgbm90ZXM6IFtdLCAvLyBzZXQgdG8gYXJyYXkgb2YgaGFuZG91dCBkaXYncwogIGJhY2tncm91bmRzOiBbXSwgLy8gc2V0IHRvIGFycmF5IG9mIGJhY2tncm91bmQgZGl2J3MKICBvYnNlcnZlcnM6IFtdLCAvLyBsaXN0IG9mIG9ic2VydmVyIGZ1bmN0aW9ucwogIHRvb2xiYXI6IG51bGwsIC8vIGVsZW1lbnQgY29udGFpbmluZyB0b29sYmFyCiAgdGl0bGU6IG51bGwsIC8vIGRvY3VtZW50IHRpdGxlCiAgbGFzdF9zaG93bjogbnVsbCwgLy8gbGFzdCBpbmNyZW1lbnRhbGx5IHNob3duIGl0ZW0KICBlb3M6IG51bGwsICAvLyBzcGFuIGVsZW1lbnQgZm9yIGVuZCBvZiBzbGlkZSBpbmRpY2F0b3IKICB0b2M6IG51bGwsIC8vIHRhYmxlIG9mIGNvbnRlbnRzCiAgb3V0bGluZTogbnVsbCwgLy8gb3V0bGluZSBlbGVtZW50IHdpdGggdGhlIGZvY3VzCiAgc2VsZWN0ZWRfdGV4dF9sZW46IDAsIC8vIGxlbmd0aCBvZiBkcmFnIHNlbGVjdGlvbiBvbiBkb2N1bWVudAogIHZpZXdfYWxsOiAwLCAgLy8gMSB0byB2aWV3IGFsbCBzbGlkZXMgKyBoYW5kb3V0cwogIHdhbnRfdG9vbGJhcjogdHJ1ZSwgIC8vIHVzZXIgcHJlZmVyZW5jZSB0byBzaG93L2hpZGUgdG9vbGJhcgogIG1vdXNlX2NsaWNrX2VuYWJsZWQ6IHRydWUsIC8vIGVuYWJsZXMgbGVmdCBjbGljayBmb3IgbmV4dCBzbGlkZQogIHNjcm9sbF9oYWNrOiAwLCAvLyBJRSB3b3JrIGFyb3VuZCBmb3IgcG9zaXRpb246IGZpeGVkCiAgZGlzYWJsZV9zbGlkZV9jbGljazogZmFsc2UsICAvLyB1c2VkIGJ5IGNsaWNrZWQgYW5jaG9ycwoKICBsYW5nOiAiZW4iLCAvLyB1cGRhdGVkIHRvIGxhbmd1YWdlIHNwZWNpZmllZCBieSBodG1sIGZpbGUKCiAgaGVscF9hbmNob3I6IG51bGwsIC8vIHVzZWQgZm9yIGtleWJvYXJkIGZvY3VzIGhhY2sgaW4gc2hvd1Rvb2xiYXIoKQogIGhlbHBfcGFnZTogImh0dHA6Ly93d3cudzMub3JnL1RhbGtzL1Rvb2xzL1NsaWR5Mi9oZWxwL2hlbHAuaHRtbCIsCiAgaGVscF90ZXh0OiAiTmF2aWdhdGUgd2l0aCBtb3VzZSBjbGljaywgc3BhY2UgYmFyLCBDdXJzb3IgTGVmdC9SaWdodCwgIiArCiAgICAgICAgICAgICAib3IgUGcgVXAgYW5kIFBnIERuLiBVc2UgUyBhbmQgQiB0byBjaGFuZ2UgZm9udCBzaXplLiIsCgogIHNpemVfaW5kZXg6IDAsCiAgc2l6ZV9hZGp1c3RtZW50OiAwLAogIHNpemVzOiAgbmV3IEFycmF5KCIxMHB0IiwgIjEycHQiLCAiMTRwdCIsICIxNnB0IiwgIjE4cHQiLCAiMjBwdCIsCiAgICAgICAgICAgICAgICAgICAgIjIycHQiLCAiMjRwdCIsICIyNnB0IiwgIjI4cHQiLCAiMzBwdCIsICIzMnB0IiksCgogIC8vIG5lZWRlZCBmb3IgZWZmaWNpZW50IHJlc2l6aW5nCiAgbGFzdF93aWR0aDogMCwKICBsYXN0X2hlaWdodDogMCwKCgogIC8vIE5lZWRlZCBmb3IgY3Jvc3MgYnJvd3NlciBzdXBwb3J0IGZvciByZWxhdGl2ZSB3aWR0aC9oZWlnaHQgb24KICAvLyBvYmplY3QgZWxlbWVudHMuIFRoZSB3b3JrIGFyb3VuZCBpcyB0byBzYXZlIHdpZHRoL2hlaWdodCBhdHRyaWJ1dGVzCiAgLy8gYW5kIHRoZW4gdG8gcmVjb21wdXRlIGFic29sdXRlIHdpZHRoL2hlaWdodCBkaW1lbnNpb25zIG9uIHJlc2l6aW5nCiAgIG9iamVjdHM6IFtdLAoKICAvLyBhdHRhY2ggaW5pdGlhbGlhdGlvbiBldmVudCBoYW5kbGVycwogIHNldF91cDogZnVuY3Rpb24gKCkgewogICAgdmFyIGluaXQgPSBmdW5jdGlvbigpIHsgdzNjX3NsaWR5LmluaXQoKTsgfTsKICAgIGlmICh0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT0gInVuZGVmaW5lZCIpCiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCJsb2FkIiwgaW5pdCwgZmFsc2UpOwogICAgZWxzZQogICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoIm9ubG9hZCIsIGluaXQpOwogIH0sCgogIGhpZGVfc2xpZGVzOiBmdW5jdGlvbiAoKSB7CiAgICBpZiAoZG9jdW1lbnQuYm9keSAmJiAhdzNjX3NsaWR5LmluaXRpYWxpemVkKQogICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnZpc2liaWxpdHkgPSAiaGlkZGVuIjsKICAgIGVsc2UKICAgICAgc2V0VGltZW91dCh3M2Nfc2xpZHkuaGlkZV9zbGlkZXMsIDUwKTsKICB9LAoKICAvLyBoYWNrIHRvIHBlcnN1YWRlIElFIHRvIGNvbXB1dGUgY29ycmVjdCBkb2N1bWVudCBoZWlnaHQKICAvLyBhcyBuZWVkZWQgZm9yIHNpbXVsYXRpbmcgZml4ZWQgcG9zaXRpb25pbmcgb2YgdG9vbGJhcgogIGllX2hhY2s6IGZ1bmN0aW9uICgpIHsKICAgIHdpbmRvdy5yZXNpemVCeSgwLC0xKTsKICAgIHdpbmRvdy5yZXNpemVCeSgwLCAxKTsKICB9LAoKICBpbml0OiBmdW5jdGlvbiAoKSB7CiAgICAvL2FsZXJ0KCJzbGlkeSBzdGFydGluZyB0ZXN0IDEwIik7CiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnZpc2liaWxpdHkgPSAidmlzaWJsZSI7CiAgICB0aGlzLmluaXRfbG9jYWxpemF0aW9uKCk7CiAgICB0aGlzLmFkZF90b29sYmFyKCk7CiAgICB0aGlzLndyYXBfaW1wbGljaXRfc2xpZGVzKCk7CiAgICB0aGlzLmNvbGxlY3Rfc2xpZGVzKCk7CiAgICB0aGlzLmNvbGxlY3Rfbm90ZXMoKTsKICAgIHRoaXMuY29sbGVjdF9iYWNrZ3JvdW5kcygpOwogICAgdGhpcy5vYmplY3RzID0gZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgib2JqZWN0Iik7CiAgICB0aGlzLnBhdGNoX2FuY2hvcnMoKTsKICAgIHRoaXMuc2xpZGVfbnVtYmVyID0gdGhpcy5maW5kX3NsaWRlX251bWJlcihsb2NhdGlvbi5ocmVmKTsKICAgIHdpbmRvdy5vZmZzY3JlZW5idWZmZXJpbmcgPSB0cnVlOwogICAgdGhpcy5zaXplX2FkanVzdG1lbnQgPSB0aGlzLmZpbmRfc2l6ZV9hZGp1c3QoKTsKICAgIHRoaXMudGltZV9sZWZ0ID0gdGhpcy5maW5kX2R1cmF0aW9uKCk7CiAgICB0aGlzLmhpZGVfaW1hZ2VfdG9vbGJhcigpOyAgLy8gc3VwcHJlc3MgSUUgaW1hZ2UgdG9vbGJhciBwb3B1cAogICAgdGhpcy5pbml0X291dGxpbmVyKCk7ICAvLyBhY3RpdmF0ZSBmb2xkL3VuZm9sZCBzdXBwb3J0CiAgICB0aGlzLnRpdGxlID0gZG9jdW1lbnQudGl0bGU7CiAgICB0aGlzLmtleWJvYXJkbGVzcyA9ICh0aGlzLmlwYWR8fHRoaXMuaXBob25lfHx0aGlzLmFuZHJvaWQpOwoKICAgIGlmICh0aGlzLmtleWJvYXJkbGVzcykKICAgIHsKICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpCiAgICAgIHRoaXMud2FudF90b29sYmFyID0gMDsKICAgIH0KCiAgICAvLyB3b3JrIGFyb3VuZCBmb3Igb3BlcmEgYnVnCiAgICB0aGlzLmlzX3hodG1sID0gKGRvY3VtZW50LmJvZHkudGFnTmFtZSA9PSAiQk9EWSIgPyBmYWxzZSA6IHRydWUpOwoKICAgIGlmICh0aGlzLnNsaWRlcy5sZW5ndGggPiAwKQogICAgewogICAgICB2YXIgc2xpZGUgPSB0aGlzLnNsaWRlc1t0aGlzLnNsaWRlX251bWJlcl07CiAgIAogICAgICBpZiAodGhpcy5zbGlkZV9udW1iZXIgPiAwKQogICAgICB7CiAgICAgICAgdGhpcy5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICAgICAgICB0aGlzLmxhc3Rfc2hvd24gPSB0aGlzLnByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW0obnVsbCk7CiAgICAgICAgdGhpcy5zZXRfZW9zX3N0YXR1cyh0cnVlKTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICB0aGlzLmxhc3Rfc2hvd24gPSBudWxsOwogICAgICAgIHRoaXMuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJoaWRkZW4iKTsKICAgICAgICB0aGlzLnNldF9lb3Nfc3RhdHVzKCF0aGlzLm5leHRfaW5jcmVtZW50YWxfaXRlbSh0aGlzLmxhc3Rfc2hvd24pKTsKICAgICAgfQoKICAgICAgdGhpcy5zZXRfbG9jYXRpb24oKTsKICAgICAgdGhpcy5hZGRfY2xhc3ModGhpcy5zbGlkZXNbMF0sICJmaXJzdC1zbGlkZSIpOwogICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZShzbGlkZSk7CiAgICB9CgogICAgdGhpcy50b2MgPSB0aGlzLnRhYmxlX29mX2NvbnRlbnRzKCk7CgogICAgdGhpcy5hZGRfaW5pdGlhbF9wcm9tcHQoKTsKCiAgICAvLyBiaW5kIGV2ZW50IGhhbmRsZXJzIHdpdGhvdXQgaW50ZXJmZXJpbmcgd2l0aCBjdXN0b20gcGFnZSBzY3JpcHRzCiAgICAvLyBUYXAgZXZlbnRzIGJlaGF2ZSB0b28gd2VpcmRseSB0byBzdXBwb3J0IGNsaWNrcyByZWxpYWJseSBvbgogICAgLy8gaVBob25lIGFuZCBpUGFkLCBzbyBleGNsdWRlIHRoZXNlIGZyb20gY2xpY2sgaGFuZGxlcgoKICAgIGlmICghdGhpcy5rZXlib2FyZGxlc3MpCiAgICB7CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LmJvZHksICJjbGljayIsIHRoaXMubW91c2VfYnV0dG9uX2NsaWNrKTsKICAgICAgdGhpcy5hZGRfbGlzdGVuZXIoZG9jdW1lbnQuYm9keSwgIm1vdXNlZG93biIsIHRoaXMubW91c2VfYnV0dG9uX2Rvd24pOwogICAgfQoKICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LCAia2V5ZG93biIsIHRoaXMua2V5X2Rvd24pOwogICAgdGhpcy5hZGRfbGlzdGVuZXIoZG9jdW1lbnQsICJrZXlwcmVzcyIsIHRoaXMua2V5X3ByZXNzKTsKICAgIHRoaXMuYWRkX2xpc3RlbmVyKHdpbmRvdywgInJlc2l6ZSIsIHRoaXMucmVzaXplZCk7CiAgICB0aGlzLmFkZF9saXN0ZW5lcih3aW5kb3csICJzY3JvbGwiLCB0aGlzLnNjcm9sbGVkKTsKICAgIHRoaXMuYWRkX2xpc3RlbmVyKHdpbmRvdywgInVubG9hZCIsIHRoaXMudW5sb2FkZWQpOwoKICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LCAiZ2VzdHVyZWNoYW5nZSIsIGZ1bmN0aW9uICgpCiAgICB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0pOwoKICAgIHRoaXMuYXR0YWNoX3RvdWNoX2hhbmRlcnModGhpcy5zbGlkZXMpOwoKICAgIC8vIHRoaXMgc2VlbXMgdG8gYmUgYSBkZWJ1Z2dpbmcgaGFjawogICAgLy9pZiAoIWRvY3VtZW50LmJvZHkub25jbGljaykKICAgIC8vICBkb2N1bWVudC5ib2R5Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7IH07CgogICAgdGhpcy5zaW5nbGVfc2xpZGVfdmlldygpOwoKICAgIC8vdGhpcy5zZXRfbG9jYXRpb24oKTsKCiAgICB0aGlzLnJlc2l6ZWQoKTsKCiAgICBpZiAodGhpcy5pZTcpCiAgICAgIHNldFRpbWVvdXQodzNjX3NsaWR5LmllX2hhY2ssIDEwMCk7CgogICAgdGhpcy5zaG93X3Rvb2xiYXIoKTsKCiAgICAvLyBmb3IgYmFjayBidXR0b24gZGV0ZWN0aW9uCiAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHczY19zbGlkeS5jaGVja19sb2NhdGlvbigpOyB9LCAyMDApOwogICAgdzNjX3NsaWR5LmluaXRpYWxpemVkID0gdHJ1ZTsKICB9LAoKICAvLyBjcmVhdGUgZGl2IGVsZW1lbnQgd2l0aCBsaW5rcyB0byBlYWNoIHNsaWRlCiAgdGFibGVfb2ZfY29udGVudHM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciB0b2MgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKTsKICAgIHRoaXMuYWRkX2NsYXNzKHRvYywgInNsaWR5X3RvYyBoaWRkZW4iKTsKICAgIC8vdG9jLnNldEF0dHJpYnV0ZSgidGFiaW5kZXgiLCAiMCIpOwoKICAgIHZhciBoZWFkaW5nID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICB0aGlzLmFkZF9jbGFzcyhoZWFkaW5nLCAidG9jLWhlYWRpbmciKTsKICAgIGhlYWRpbmcuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgiVGFibGUgb2YgQ29udGVudHMiKTsKCiAgICB0b2MuYXBwZW5kQ2hpbGQoaGVhZGluZyk7CiAgICB2YXIgcHJldmlvdXMgPSBudWxsOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zbGlkZXMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIHZhciB0aXRsZSA9IHRoaXMuaGFzX2NsYXNzKHRoaXMuc2xpZGVzW2ldLCAidGl0bGUiKTsKICAgICAgdmFyIG51bSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKChpICsgMSkgKyAiLiAiKTsKCiAgICAgIHRvYy5hcHBlbmRDaGlsZChudW0pOwoKICAgICAgdmFyIGEgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJhIik7CiAgICAgIGEuc2V0QXR0cmlidXRlKCJocmVmIiwgIiMoIiArIChpKzEpICsgIikiKTsKCiAgICAgIGlmICh0aXRsZSkKICAgICAgICB0aGlzLmFkZF9jbGFzcyhhLCAidGl0bGVzbGlkZSIpOwoKICAgICAgdmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnNsaWRlX25hbWUoaSkpOwogICAgICBhLmFwcGVuZENoaWxkKG5hbWUpOwogICAgICBhLm9uY2xpY2sgPSB3M2Nfc2xpZHkudG9jX2NsaWNrOwogICAgICBhLm9ua2V5ZG93biA9IHczY19zbGlkeS50b2Nfa2V5X2Rvd247CiAgICAgIGEucHJldmlvdXMgPSBwcmV2aW91czsKCiAgICAgIGlmIChwcmV2aW91cykKICAgICAgICBwcmV2aW91cy5uZXh0ID0gYTsKCiAgICAgIHRvYy5hcHBlbmRDaGlsZChhKTsKCiAgICAgIGlmIChpID09IDApCiAgICAgICAgdG9jLmZpcnN0ID0gYTsKCiAgICAgIGlmIChpIDwgdGhpcy5zbGlkZXMubGVuZ3RoIC0gMSkKICAgICAgewogICAgICAgIHZhciBiciA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImJyIik7CiAgICAgICAgdG9jLmFwcGVuZENoaWxkKGJyKTsKICAgICAgfQoKICAgICAgcHJldmlvdXMgPSBhOwogICAgfQoKICAgIHRvYy5mb2N1cyA9IGZ1bmN0aW9uICgpIHsKICAgICAgaWYgKHRoaXMuZmlyc3QpCiAgICAgICAgdGhpcy5maXJzdC5mb2N1cygpOwogICAgfQoKICAgIHRvYy5vbm1vdXNldXAgPSB3M2Nfc2xpZHkubW91c2VfYnV0dG9uX3VwOwoKICAgIHRvYy5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHsKICAgICAgZXx8KGU9d2luZG93LmV2ZW50KTsKCiAgICAgIGlmICh3M2Nfc2xpZHkuc2VsZWN0ZWRfdGV4dF9sZW4gPD0gMCkKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHModHJ1ZSk7CgogICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKICAgIAogICAgICBpZiAoZS5jYW5jZWwgIT0gdW5kZWZpbmVkKQogICAgICAgIGUuY2FuY2VsID0gdHJ1ZTsKICAgICAgCiAgICAgIGlmIChlLnJldHVyblZhbHVlICE9IHVuZGVmaW5lZCkKICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7CiAgICAgIAogICAgICByZXR1cm4gZmFsc2U7CiAgICB9OwoKICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHRvYywgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTsKICAgIHJldHVybiB0b2M7CiAgfSwKCiAgaXNfc2hvd25fdG9jOiBmdW5jdGlvbiAoKSB7CiAgICByZXR1cm4gIXczY19zbGlkeS5oYXNfY2xhc3ModzNjX3NsaWR5LnRvYywgImhpZGRlbiIpOwogIH0sCgogIHNob3dfdGFibGVfb2ZfY29udGVudHM6IGZ1bmN0aW9uICgpIHsKICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3ModzNjX3NsaWR5LnRvYywgImhpZGRlbiIpOwogICAgdmFyIHRvYyA9IHczY19zbGlkeS50b2M7CiAgICB0b2MuZm9jdXMoKTsKCiAgICBpZiAodzNjX3NsaWR5LmllNyAmJiB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID09IDApCiAgICAgIHNldFRpbWVvdXQodzNjX3NsaWR5LmllX2hhY2ssIDEwMCk7CiAgfSwKCiAgaGlkZV90YWJsZV9vZl9jb250ZW50czogZnVuY3Rpb24gKGZvY3VzKSB7CiAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKHczY19zbGlkeS50b2MsICJoaWRkZW4iKTsKCiAgICBpZiAoZm9jdXMgJiYgIXczY19zbGlkeS5vcGVyYSAmJgogICAgICAgICF3M2Nfc2xpZHkuaGFzX2NsYXNzKHczY19zbGlkeS50b2MsICJoaWRkZW4iKSkKICAgICAgdzNjX3NsaWR5LnNldF9mb2N1cygpOwogIH0sCgogIHRvZ2dsZV90YWJsZV9vZl9jb250ZW50czogZnVuY3Rpb24gKCkgewogICAgaWYgKHczY19zbGlkeS5pc19zaG93bl90b2MoKSkKICAgICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHModHJ1ZSk7CiAgICBlbHNlCiAgICAgIHczY19zbGlkeS5zaG93X3RhYmxlX29mX2NvbnRlbnRzKCk7CiAgfSwKCiAgLy8gY2FsbGVkIG9uIGNsaWNraW5nIHRvYyBlbnRyeQogIHRvY19jbGljazogZnVuY3Rpb24gKGUpIHsKICAgIGlmICghZSkKICAgICAgZSA9IHdpbmRvdy5ldmVudDsKCiAgICB2YXIgdGFyZ2V0ID0gdzNjX3NsaWR5LmdldF90YXJnZXQoZSk7CgogICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMSkKICAgIHsKICAgICAgdmFyIHVyaSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoImhyZWYiKTsKCiAgICAgIGlmICh1cmkpCiAgICAgIHsKICAgICAgICAvL2FsZXJ0KCJnb2luZyB0byAiICsgdXJpKTsKICAgICAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5oaWRlX3NsaWRlKHNsaWRlKTsKICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID0gdzNjX3NsaWR5LmZpbmRfc2xpZGVfbnVtYmVyKHVyaSk7CiAgICAgICAgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CiAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgdzNjX3NsaWR5LnNldF9lb3Nfc3RhdHVzKCF3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKSk7CiAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICAgIC8vdGFyZ2V0LmZvY3VzKCk7CgogICAgICAgIHRyeQogICAgICAgIHsKICAgICAgICAgIGlmICghdzNjX3NsaWR5Lm9wZXJhKQogICAgICAgICAgICB3M2Nfc2xpZHkuc2V0X2ZvY3VzKCk7CiAgICAgICAgfQogICAgICAgIGNhdGNoIChlKQogICAgICAgIHsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICB3M2Nfc2xpZHkuaGlkZV90YWJsZV9vZl9jb250ZW50cyh0cnVlKTsKICAgIGlmICh3M2Nfc2xpZHkuaWU3KSB3M2Nfc2xpZHkuaWVfaGFjaygpOwogICAgdzNjX3NsaWR5LnN0b3BfcHJvcGFnYXRpb24oZSk7CiAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChlKTsKICB9LAoKICAvLyBjYWxsZWQgb25rZXlkb3duIGZvciB0b2MgZW50cnkKICB0b2Nfa2V5X2Rvd246IGZ1bmN0aW9uIChldmVudCkgewogICAgdmFyIGtleTsKCiAgICBpZiAoIWV2ZW50KQogICAgICB2YXIgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7CgogICAgLy8ga2x1ZGdlIGFyb3VuZCBOUy9JRSBkaWZmZXJlbmNlcyAKICAgIGlmICh3aW5kb3cuZXZlbnQpCiAgICAgIGtleSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlOwogICAgZWxzZSBpZiAoZXZlbnQud2hpY2gpCiAgICAgIGtleSA9IGV2ZW50LndoaWNoOwogICAgZWxzZQogICAgICByZXR1cm4gdHJ1ZTsgLy8gWWlrZXMhIHVua25vd24gYnJvd3NlcgoKICAgIC8vIGlnbm9yZSBldmVudCBpZiBrZXkgdmFsdWUgaXMgemVybwogICAgLy8gYXMgZm9yIGFsdCBvbiBPcGVyYSBhbmQgS29ucXVlcm9yCiAgICBpZiAoIWtleSkKICAgICAgcmV0dXJuIHRydWU7CgogICAgLy8gY2hlY2sgZm9yIGNvbmN1cnJlbnQgY29udHJvbC9jb21tYW5kL2FsdCBrZXkKICAgIC8vIGJ1dCBhcmUgdGhlc2Ugb25seSBwcmVzZW50IG9uIG1vdXNlIGV2ZW50cz8KCiAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkpCiAgICAgIHJldHVybiB0cnVlOwoKICAgIGlmIChrZXkgPT0gMTMpCiAgICB7CiAgICAgIHZhciB1cmkgPSB0aGlzLmdldEF0dHJpYnV0ZSgiaHJlZiIpOwoKICAgICAgaWYgKHVyaSkKICAgICAgewogICAgICAgIC8vYWxlcnQoImdvaW5nIHRvICIgKyB1cmkpOwogICAgICAgdmFyIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkuaGlkZV9zbGlkZShzbGlkZSk7CiAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5maW5kX3NsaWRlX251bWJlcih1cmkpOwogICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IG51bGw7CiAgICAgICAgdzNjX3NsaWR5LnNldF9sb2NhdGlvbigpOwogICAgICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoImhpZGRlbiIpOwogICAgICAgIHczY19zbGlkeS5zZXRfZW9zX3N0YXR1cyghdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbSh3M2Nfc2xpZHkubGFzdF9zaG93bikpOwogICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgICAvL3RhcmdldC5mb2N1cygpOwoKICAgICAgICB0cnkKICAgICAgICB7CiAgICAgICAgICBpZiAoIXczY19zbGlkeS5vcGVyYSkKICAgICAgICAgICAgdzNjX3NsaWR5LnNldF9mb2N1cygpOwogICAgICAgIH0KICAgICAgICBjYXRjaCAoZSkKICAgICAgICB7CiAgICAgICAgfQogICAgICB9CgogICAgICB3M2Nfc2xpZHkuaGlkZV90YWJsZV9vZl9jb250ZW50cyh0cnVlKTsKCiAgICAgIGlmIChzZWxmLmllNykKICAgICAgIHczY19zbGlkeS5pZV9oYWNrKCk7CgogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CgogICAgaWYgKGtleSA9PSA0MCAmJiB0aGlzLm5leHQpCiAgICB7CiAgICAgIHRoaXMubmV4dC5mb2N1cygpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CgogICAgaWYgKGtleSA9PSAzOCAmJiB0aGlzLnByZXZpb3VzKQogICAgewogICAgICB0aGlzLnByZXZpb3VzLmZvY3VzKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KCiAgICByZXR1cm4gdHJ1ZTsKICB9LAoKICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZSkKICB7CiAgICAvLyBhIGRvdWJsZSB0b3VjaCBvZnRlbiBzdGFydHMgd2l0aCBhCiAgICAvLyBzaW5nbGUgdG91Y2ggZHVlIHRvIGZpbmdlcnMgdG91Y2hpbmcKICAgIC8vIGRvd24gYXQgc2xpZ2h0bHkgZGlmZmVyZW50IHRpbWVzCiAgICAvLyB0aHVzIGF2b2lkIGNhbGxpbmcgcHJldmVudERlZmF1bHQgaGVyZQogICAgdGhpcy5wcmV2X3RhcCA9IHRoaXMubGFzdF90YXA7CiAgICB0aGlzLmxhc3RfdGFwID0gKG5ldyBEYXRlKS5nZXRUaW1lKCk7CgogICAgdmFyIHRhcF9kZWxheSA9IHRoaXMubGFzdF90YXAgLSB0aGlzLnByZXZfdGFwOwoKICAgIGlmICh0YXBfZGVsYXkgPD0gMjAwKQogICAgewogICAgICAvLyBkb3VibGUgdGFwCiAgICB9CgogICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdOwoKICAgIHRoaXMucGFnZVggPSB0b3VjaC5wYWdlWDsKICAgIHRoaXMucGFnZVkgPSB0b3VjaC5wYWdlWTsKICAgIHRoaXMuc2NyZWVuWCA9IHRvdWNoLnNjcmVlblg7CiAgICB0aGlzLnNjcmVlblkgPSB0b3VjaC5zY3JlZW5ZOwogICAgdGhpcy5jbGllbnRYID0gdG91Y2guY2xpZW50WDsKICAgIHRoaXMuY2xpZW50WSA9IHRvdWNoLmNsaWVudFk7CgogICAgdGhpcy5kZWx0YV94ID0gdGhpcy5kZWx0YV95ID0gMDsKICB9LAoKICB0b3VjaG1vdmU6IGZ1bmN0aW9uIChlKQogIHsKICAgIC8vIG92ZXJyaWRlIG5hdGl2ZSBnZXN0dXJlcyBmb3Igc2luZ2xlIHRvdWNoCiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpCiAgICAgIHJldHVybjsKCiAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07CiAgICB0aGlzLmRlbHRhX3ggPSB0b3VjaC5wYWdlWCAtIHRoaXMucGFnZVg7CiAgICB0aGlzLmRlbHRhX3kgPSB0b3VjaC5wYWdlWSAtIHRoaXMucGFnZVk7CiAgfSwKCiAgdG91Y2hlbmQ6IGZ1bmN0aW9uIChlKQogIHsKICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgZm9yIG11bHRpLXRvdWNoCiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpCiAgICAgIHJldHVybjsKCiAgICB2YXIgZGVsYXkgPSAobmV3IERhdGUpLmdldFRpbWUoKSAtIHRoaXMubGFzdF90YXA7CiAgICB2YXIgZHggPSB0aGlzLmRlbHRhX3g7CiAgICB2YXIgZHkgPSB0aGlzLmRlbHRhX3k7CiAgICB2YXIgYWJzX2R4ID0gTWF0aC5hYnMoZHgpOwogICAgdmFyIGFic19keSA9IE1hdGguYWJzKGR5KTsKCiAgICBpZiAoZGVsYXkgPCA1MDAgJiYgKGFic19keCA+IDEwMCB8fCBhYnNfZHkgPiAxMDApKQogICAgewogICAgICBpZiAoYWJzX2R4ID4gMC41ICogYWJzX2R5KQogICAgICB7CiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOwoKICAgICAgICBpZiAoZHggPCAwKQogICAgICAgICAgdzNjX3NsaWR5Lm5leHRfc2xpZGUodHJ1ZSk7CiAgICAgICAgZWxzZQogICAgICAgICAgdzNjX3NsaWR5LnByZXZpb3VzX3NsaWRlKHRydWUpOwogICAgICB9CiAgICAgIGVsc2UgaWYgKGFic19keSA+IDIgKiBhYnNfZHgpCiAgICAgIHsKICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICAgICAgdzNjX3NsaWR5LnRvZ2dsZV90YWJsZV9vZl9jb250ZW50cygpOwogICAgICB9CiAgICB9CiAgfSwKCiAgLy8gIyMjIE9CU09MRVRFICMjIwogIGJlZm9yZV9wcmludDogZnVuY3Rpb24gKCkgewogICAgdGhpcy5zaG93X2FsbF9zbGlkZXMoKTsKICAgIHRoaXMuaGlkZV90b29sYmFyKCk7CiAgICBhbGVydCgiYmVmb3JlIHByaW50Iik7CiAgfSwKCiAgLy8gIyMjIE9CU09MRVRFICMjIwogIGFmdGVyX3ByaW50OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAoIXRoaXMudmlld19hbGwpCiAgICB7CiAgICAgIHRoaXMuc2luZ2xlX3NsaWRlX3ZpZXcoKTsKICAgICAgdGhpcy5zaG93X3Rvb2xiYXIoKTsKICAgIH0KICAgIGFsZXJ0KCJhZnRlciBwcmludCIpOwogIH0sCgogIC8vICMjIyBPQlNPTEVURSAjIyMKICBwcmludF9zbGlkZXM6IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuYmVmb3JlX3ByaW50KCk7CiAgICB3aW5kb3cucHJpbnQoKTsKICAgIHRoaXMuYWZ0ZXJfcHJpbnQoKTsKICB9LAoKICAvLyAjIyMgT0JTT0xFVEUgPz8gIyMjCiAgdG9nZ2xlX3ZpZXc6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh0aGlzLnZpZXdfYWxsKQogICAgewogICAgICB0aGlzLnNpbmdsZV9zbGlkZV92aWV3KCk7CiAgICAgIHRoaXMuc2hvd190b29sYmFyKCk7CiAgICAgIHRoaXMudmlld19hbGwgPSAwOwogICAgfQogICAgZWxzZQogICAgewogICAgICB0aGlzLnNob3dfYWxsX3NsaWRlcygpOwogICAgICB0aGlzLmhpZGVfdG9vbGJhcigpOwogICAgICB0aGlzLnZpZXdfYWxsID0gMTsKICAgIH0KICB9LAoKICAvLyBwcmVwYXJlIGZvciBwcmludGluZyAgIyMjIE9CU09MRVRFICMjIwogIHNob3dfYWxsX3NsaWRlczogZnVuY3Rpb24gKCkgewogICAgdGhpcy5yZW1vdmVfY2xhc3MoZG9jdW1lbnQuYm9keSwgInNpbmdsZV9zbGlkZSIpOwogICAgdGhpcy5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICB9LAoKICAvLyByZXN0b3JlIGFmdGVyIHByaW50aW5nICAjIyMgT0JTT0xFVEUgIyMjCiAgc2luZ2xlX3NsaWRlX3ZpZXc6IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuYWRkX2NsYXNzKGRvY3VtZW50LmJvZHksICJzaW5nbGVfc2xpZGUiKTsKICAgIHRoaXMuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJ2aXNpYmxlIik7CiAgICB0aGlzLmxhc3Rfc2hvd24gPSB0aGlzLnByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW0obnVsbCk7CiAgfSwKCiAgLy8gc3VwcHJlc3MgSUUncyBpbWFnZSB0b29sYmFyIHBvcCB1cAogIGhpZGVfaW1hZ2VfdG9vbGJhcjogZnVuY3Rpb24gKCkgewogICAgaWYgKCF0aGlzLm5zX3BvcykKICAgIHsKICAgICAgdmFyIGltYWdlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJJTUciKTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKQogICAgICAgIGltYWdlc1tpXS5zZXRBdHRyaWJ1dGUoImdhbGxlcnlpbWciLCAibm8iKTsKICAgIH0KICB9LAoKICB1bmxvYWRlZDogZnVuY3Rpb24gKGUpIHsKICAgIC8vYWxlcnQoInVubG9hZGVkIik7CiAgfSwKCiAgLy8gU2FmYXJpIGFuZCBLb25xdWVyb3IgZG9uJ3QgeWV0IHN1cHBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSgpCiAgLy8gYW5kIHRoZXkgYWx3YXlzIHJlbG9hZCBwYWdlIHdoZW4gbG9jYXRpb24uaHJlZiBpcyB1cGRhdGVkCiAgaXNfS0hUTUw6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7CiAgICByZXR1cm4gKGFnZW50LmluZGV4T2YoIktIVE1MIikgPj0gMCA/IHRydWUgOiBmYWxzZSk7CiAgfSwKCiAgLy8gZmluZCBzbGlkZSBuYW1lIGZyb20gZmlyc3QgaDEgZWxlbWVudAogIC8vIGRlZmF1bHQgdG8gZG9jdW1lbnQgdGl0bGUgKyBzbGlkZSBudW1iZXIKICBzbGlkZV9uYW1lOiBmdW5jdGlvbiAoaW5kZXgpIHsKICAgIHZhciBuYW1lID0gbnVsbDsKICAgIHZhciBzbGlkZSA9IHRoaXMuc2xpZGVzW2luZGV4XTsKCiAgICB2YXIgaGVhZGluZyA9IHRoaXMuZmluZF9oZWFkaW5nKHNsaWRlKTsKCiAgICBpZiAoaGVhZGluZykKICAgICAgbmFtZSA9IHRoaXMuZXh0cmFjdF90ZXh0KGhlYWRpbmcpOwoKICAgIGlmICghbmFtZSkKICAgICAgbmFtZSA9IHRoaXMudGl0bGUgKyAiKCIgKyAoaW5kZXggKyAxKSArICIpIjsKCiAgICBuYW1lLnJlcGxhY2UoL1wmL2csICImYW1wOyIpOwogICAgbmFtZS5yZXBsYWNlKC9cPC9nLCAiJmx0OyIpOwogICAgbmFtZS5yZXBsYWNlKC9cPi9nLCAiJmd0OyIpOwoKICAgIHJldHVybiBuYW1lOwogIH0sCgogIC8vIGZpbmQgZmlyc3QgaDEgZWxlbWVudCBpbiBET00gdHJlZQogIGZpbmRfaGVhZGluZzogZnVuY3Rpb24gKG5vZGUpIHsKICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9IDEpCiAgICAgIHJldHVybiBudWxsOwoKICAgIGlmIChub2RlLm5vZGVOYW1lID09ICJIMSIgfHwgbm9kZS5ub2RlTmFtZSA9PSAiaDEiKQogICAgICByZXR1cm4gbm9kZTsKCiAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7CgogICAgd2hpbGUgKGNoaWxkKQogICAgewogICAgICBub2RlID0gdGhpcy5maW5kX2hlYWRpbmcoY2hpbGQpOwoKICAgICAgaWYgKG5vZGUpCiAgICAgICAgcmV0dXJuIG5vZGU7CgogICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nOwogICAgfQoKICAgIHJldHVybiBudWxsOwogIH0sCgogIC8vIHJlY3Vyc2l2ZWx5IGV4dHJhY3QgdGV4dCBmcm9tIERPTSB0cmVlCiAgZXh0cmFjdF90ZXh0OiBmdW5jdGlvbiAobm9kZSkgewogICAgaWYgKCFub2RlKQogICAgICByZXR1cm4gIiI7CgogICAgLy8gdGV4dCBub2RlcwogICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykKICAgICAgcmV0dXJuIG5vZGUubm9kZVZhbHVlOwoKICAgIC8vIGVsZW1lbnRzCiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKQogICAgewogICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkOwogICAgICB2YXIgdGV4dCA9ICIiOwoKICAgICAgd2hpbGUgKG5vZGUpCiAgICAgIHsKICAgICAgICB0ZXh0ID0gdGV4dCArIHRoaXMuZXh0cmFjdF90ZXh0KG5vZGUpOwogICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nOwogICAgICB9CgogICAgICByZXR1cm4gdGV4dDsKICAgIH0KCiAgICByZXR1cm4gIiI7CiAgfSwKCiAgLy8gZmluZCBjb3B5cmlnaHQgdGV4dCBmcm9tIG1ldGEgZWxlbWVudAogIGZpbmRfY29weXJpZ2h0OiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgbmFtZSwgY29udGVudDsKICAgIHZhciBtZXRhID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIm1ldGEiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIG5hbWUgPSBtZXRhW2ldLmdldEF0dHJpYnV0ZSgibmFtZSIpOwogICAgICBjb250ZW50ID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoImNvbnRlbnQiKTsKCiAgICAgIGlmIChuYW1lID09ICJjb3B5cmlnaHQiKQogICAgICAgIHJldHVybiBjb250ZW50OwogICAgfQoKICAgIHJldHVybiBudWxsOwogIH0sCgogIGZpbmRfc2l6ZV9hZGp1c3Q6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBuYW1lLCBjb250ZW50LCBvZmZzZXQ7CiAgICB2YXIgbWV0YSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJtZXRhIik7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgKytpKQogICAgewogICAgICBuYW1lID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTsKICAgICAgY29udGVudCA9IG1ldGFbaV0uZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7CgogICAgICBpZiAobmFtZSA9PSAiZm9udC1zaXplLWFkanVzdG1lbnQiKQogICAgICAgIHJldHVybiAxICogY29udGVudDsKICAgIH0KCiAgICByZXR1cm4gMTsKICB9LAoKICAvLyA8bWV0YSBuYW1lPSJkdXJhdGlvbiIgY29udGVudD0iMjAiIC8+ICBmb3IgMjAgbWludXRlcwogIGZpbmRfZHVyYXRpb246IGZ1bmN0aW9uICgpIHsKICAgIHZhciBuYW1lLCBjb250ZW50LCBvZmZzZXQ7CiAgICB2YXIgbWV0YSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJtZXRhIik7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgKytpKQogICAgewogICAgICBuYW1lID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTsKICAgICAgY29udGVudCA9IG1ldGFbaV0uZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7CgogICAgICBpZiAobmFtZSA9PSAiZHVyYXRpb24iKQogICAgICAgIHJldHVybiA2MDAwMCAqIGNvbnRlbnQ7CiAgICB9CgogICAgcmV0dXJuIG51bGw7CiAgfSwKCiAgcmVwbGFjZV9ieV9ub25fYnJlYWtpbmdfc3BhY2U6IGZ1bmN0aW9uIChzdHIpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKQogICAgICBzdHJbaV0gPSAxNjA7CiAgfSwKCiAgLy8gIyMjIENIRUNLIE1FICMjIyBpcyB1c2Ugb2YgImxpIiBva2F5IGZvciB0ZXh0L2h0bWw/CiAgLy8gZm9yIFhIVE1MIGRvIHdlIGFsc28gbmVlZCB0byBzcGVjaWZ5IG5hbWVzcGFjZT8KICBpbml0X291dGxpbmVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgaXRlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgibGkiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKQogICAgewogICAgICB2YXIgdGFyZ2V0ID0gaXRlbXNbaV07CgogICAgICBpZiAoIXRoaXMuaGFzX2NsYXNzKHRhcmdldC5wYXJlbnROb2RlLCAib3V0bGluZSIpKQogICAgICAgIGNvbnRpbnVlOwoKICAgICAgdGFyZ2V0Lm9uY2xpY2sgPSB0aGlzLm91dGxpbmVfY2xpY2s7Ci8qICMjIyBtb3JlIHdvcmsgbmVlZGVkIGZvciBJRTYKICAgICAgaWYgKCF0aGlzLm5zX3BvcykKICAgICAgewogICAgICAgIHRhcmdldC5vbm1vdXNlb3ZlciA9IHRoaXMuaG92ZXJfb3V0bGluZTsKICAgICAgICB0YXJnZXQub25tb3VzZW91dCA9IHRoaXMudW5ob3Zlcl9vdXRsaW5lOwogICAgICB9CiovCiAgICAgIGlmICh0aGlzLmZvbGRhYmxlKHRhcmdldCkpCiAgICAgIHsKICAgICAgICB0YXJnZXQuZm9sZGFibGUgPSB0cnVlOwogICAgICAgIHRhcmdldC5vbmZvY3VzID0gZnVuY3Rpb24gKCkge3czY19zbGlkeS5vdXRsaW5lID0gdGhpczt9OwogICAgICAgIHRhcmdldC5vbmJsdXIgPSBmdW5jdGlvbiAoKSB7dzNjX3NsaWR5Lm91dGxpbmUgPSBudWxsO307CgogICAgICAgIGlmICghdGFyZ2V0LmdldEF0dHJpYnV0ZSgidGFiaW5kZXgiKSkKICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoInRhYmluZGV4IiwgIjAiKTsKCiAgICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKHRhcmdldCwgImV4cGFuZCIpKQogICAgICAgICAgdGhpcy51bmZvbGQodGFyZ2V0KTsKICAgICAgICBlbHNlCiAgICAgICAgICB0aGlzLmZvbGQodGFyZ2V0KTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICB0aGlzLmFkZF9jbGFzcyh0YXJnZXQsICJub2ZvbGQiKTsKICAgICAgICB0YXJnZXQudmlzaWJsZSA9IHRydWU7CiAgICAgICAgdGFyZ2V0LmZvbGRhYmxlID0gZmFsc2U7CiAgICAgIH0KICAgIH0KICB9LAoKICBmb2xkYWJsZTogZnVuY3Rpb24gKGl0ZW0pIHsKICAgIGlmICghaXRlbSB8fCBpdGVtLm5vZGVUeXBlICE9IDEpCiAgICAgIHJldHVybiBmYWxzZTsKCiAgICB2YXIgbm9kZSA9IGl0ZW0uZmlyc3RDaGlsZDsKCiAgICB3aGlsZSAobm9kZSkKICAgIHsKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiB0aGlzLmlzX2Jsb2NrKG5vZGUpKQogICAgICAgIHJldHVybiB0cnVlOwoKICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIC8vICMjIyBDSEVDSyBNRSAjIyMgc3dpdGNoIHRvIGFkZC9yZW1vdmUgImhpZGRlbiIgY2xhc3MKICBmb2xkOiBmdW5jdGlvbiAoaXRlbSkgewogICAgaWYgKGl0ZW0pCiAgICB7CiAgICAgIHRoaXMucmVtb3ZlX2NsYXNzKGl0ZW0sICJ1bmZvbGRlZCIpOwogICAgICB0aGlzLmFkZF9jbGFzcyhpdGVtLCAiZm9sZGVkIik7CiAgICB9CgogICAgdmFyIG5vZGUgPSBpdGVtID8gaXRlbS5maXJzdENoaWxkIDogbnVsbDsKCiAgICB3aGlsZSAobm9kZSkKICAgIHsKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiB0aGlzLmlzX2Jsb2NrKG5vZGUpKSAvLyBlbGVtZW50CiAgICAgIHsKICAgICAgICAgdzNjX3NsaWR5LmFkZF9jbGFzcyhub2RlLCAiaGlkZGVuIik7CiAgICAgIH0KCiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nOwogICAgfQoKICAgIGl0ZW0udmlzaWJsZSA9IGZhbHNlOwogIH0sCgogIC8vICMjIyBDSEVDSyBNRSAjIyMgc3dpdGNoIHRvIGFkZC9yZW1vdmUgImhpZGRlbiIgY2xhc3MKICB1bmZvbGQ6IGZ1bmN0aW9uIChpdGVtKSB7CiAgICBpZiAoaXRlbSkKICAgIHsKICAgICAgdGhpcy5hZGRfY2xhc3MoaXRlbSwgInVuZm9sZGVkIik7CiAgICAgIHRoaXMucmVtb3ZlX2NsYXNzKGl0ZW0sICJmb2xkZWQiKTsKICAgIH0KCiAgICB2YXIgbm9kZSA9IGl0ZW0gPyBpdGVtLmZpcnN0Q2hpbGQgOiBudWxsOwoKICAgIHdoaWxlIChub2RlKQogICAgewogICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIHRoaXMuaXNfYmxvY2sobm9kZSkpIC8vIGVsZW1lbnQKICAgICAgewogICAgICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3Mobm9kZSwgImhpZGRlbiIpOwogICAgICB9CgogICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZzsKICAgIH0KCiAgICBpdGVtLnZpc2libGUgPSB0cnVlOwogIH0sCgogIG91dGxpbmVfY2xpY2s6IGZ1bmN0aW9uIChlKSB7CiAgICBpZiAoIWUpCiAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgdmFyIHJpZ2h0Y2xpY2sgPSBmYWxzZTsKICAgIHZhciB0YXJnZXQgPSB3M2Nfc2xpZHkuZ2V0X3RhcmdldChlKTsKCiAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC52aXNpYmxlID09IHVuZGVmaW5lZCkKICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7CgogICAgaWYgKCF0YXJnZXQpCiAgICAgIHJldHVybiB0cnVlOwoKICAgIGlmIChlLndoaWNoKQogICAgICByaWdodGNsaWNrID0gKGUud2hpY2ggPT0gMyk7CiAgICBlbHNlIGlmIChlLmJ1dHRvbikKICAgICAgcmlnaHRjbGljayA9IChlLmJ1dHRvbiA9PSAyKTsKCiAgICBpZiAoIXJpZ2h0Y2xpY2sgJiYgdGFyZ2V0LnZpc2libGUgIT0gdW5kZWZpbmVkKQogICAgewogICAgICBpZiAodGFyZ2V0LmZvbGRhYmxlKQogICAgICB7CiAgICAgICAgaWYgKHRhcmdldC52aXNpYmxlKQogICAgICAgICAgdzNjX3NsaWR5LmZvbGQodGFyZ2V0KTsKICAgICAgICBlbHNlCiAgICAgICAgICB3M2Nfc2xpZHkudW5mb2xkKHRhcmdldCk7CiAgICAgIH0KCiAgICAgIHczY19zbGlkeS5zdG9wX3Byb3BhZ2F0aW9uKGUpOwogICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTsKICAgIH0KCiAgICByZXR1cm4gZmFsc2U7CiAgfSwKCiAgYWRkX2luaXRpYWxfcHJvbXB0OiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgcHJvbXB0ID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICBwcm9tcHQuc2V0QXR0cmlidXRlKCJjbGFzcyIsICJpbml0aWFsX3Byb21wdCIpOwoKICAgIHZhciBwMSA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoInAiKTsKICAgIHByb21wdC5hcHBlbmRDaGlsZChwMSk7CiAgICBwMS5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgImhlbHAiKTsKCiAgICBpZiAodGhpcy5rZXlib2FyZGxlc3MpCiAgICAgIHAxLmlubmVySFRNTCA9ICJzd2lwZSBsZWZ0IHRvIG1vdmUgdG8gbmV4dCBzbGlkZSI7CiAgICBlbHNlCiAgICAgIHAxLmlubmVySFRNTCA9ICJTcGFjZSwgUmlnaHQgQXJyb3cgb3Igc3dpcGUgbGVmdCB0byBtb3ZlIHRvICIgKwogICAgICAgICAgICAgICAgICAgICAibmV4dCBzbGlkZSwgY2xpY2sgaGVscCBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzIjsKCiAgICB0aGlzLmFkZF9saXN0ZW5lcihwcm9tcHQsICJjbGljayIsIGZ1bmN0aW9uIChlKSB7CiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocHJvbXB0KTsKICAgICAgdzNjX3NsaWR5LnN0b3BfcHJvcGFnYXRpb24oZSk7CiAgICAKICAgICAgaWYgKGUuY2FuY2VsICE9IHVuZGVmaW5lZCkKICAgICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIAogICAgICBpZiAoZS5yZXR1cm5WYWx1ZSAhPSB1bmRlZmluZWQpCiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOwogICAgICAKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSk7CgogICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcm9tcHQpOwogICAgdGhpcy5pbml0aWFsX3Byb21wdCA9IHByb21wdDsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChwcm9tcHQpO30sIDUwMDApOwogIH0sCgogIGFkZF90b29sYmFyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgY291bnRlciwgcGFnZTsKCiAgICAgdGhpcy50b29sYmFyID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICAgdGhpcy50b29sYmFyLnNldEF0dHJpYnV0ZSgiY2xhc3MiLCAidG9vbGJhciIpOwoKICAgICAvLyBhIHJlYXNvbmFibHkgYmVoYXZlZCBicm93c2VyCiAgICAgaWYgKHRoaXMubnNfcG9zIHx8ICF0aGlzLmllNikKICAgICB7CiAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKTsKICAgICAgIHJpZ2h0LnNldEF0dHJpYnV0ZSgic3R5bGUiLCAiZmxvYXQ6IHJpZ2h0OyB0ZXh0LWFsaWduOiByaWdodCIpOwoKICAgICAgIGNvdW50ZXIgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIikKICAgICAgIGNvdW50ZXIuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgic2xpZGUiKSArICIgbi9tIjsKICAgICAgIHJpZ2h0LmFwcGVuZENoaWxkKGNvdW50ZXIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKHJpZ2h0KTsKCiAgICAgICB2YXIgbGVmdCA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImRpdiIpOwogICAgICAgbGVmdC5zZXRBdHRyaWJ1dGUoInN0eWxlIiwgInRleHQtYWxpZ246IGxlZnQiKTsKCiAgICAgICAvLyBnbG9iYWwgZW5kIG9mIHNsaWRlIGluZGljYXRvcgogICAgICAgdGhpcy5lb3MgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICB0aGlzLmVvcy5pbm5lckhUTUwgPSAiKiAiOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZCh0aGlzLmVvcyk7CgogICAgICAgdmFyIGhlbHAgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJhIik7CiAgICAgICBoZWxwLnNldEF0dHJpYnV0ZSgiaHJlZiIsIHRoaXMuaGVscF9wYWdlKTsKICAgICAgIGhlbHAuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIHRoaXMubG9jYWxpemUodGhpcy5oZWxwX3RleHQpKTsKICAgICAgIGhlbHAuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgiaGVscD8iKTsKICAgICAgIGxlZnQuYXBwZW5kQ2hpbGQoaGVscCk7CiAgICAgICBoZWxwLnN0eWxlLmRpc3BsYXk9Im5vbmUiOyAKICAgICAgIHRoaXMuaGVscF9hbmNob3IgPSBoZWxwOyAgLy8gc2F2ZSBmb3IgZm9jdXMgaGFjawoKICAgICAgIHZhciBnYXAxID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIiAiKTsKICAgICAgIGxlZnQuYXBwZW5kQ2hpbGQoZ2FwMSk7CgogICAgICAgdmFyIGNvbnRlbnRzID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiYSIpOwogICAgICAgY29udGVudHMuc2V0QXR0cmlidXRlKCJocmVmIiwgImphdmFzY3JpcHQ6dzNjX3NsaWR5LnRvZ2dsZV90YWJsZV9vZl9jb250ZW50cygpIik7CiAgICAgICBjb250ZW50cy5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSgidGFibGUgb2YgY29udGVudHMiKSk7CiAgICAgICBjb250ZW50cy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJDb250ZW50cyIpOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZChjb250ZW50cyk7CgogICAgICAgdmFyIGdhcDIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZChnYXAyKTsKCiAgICAgICB2YXIgY29weXJpZ2h0ID0gdGhpcy5maW5kX2NvcHlyaWdodCgpOwoKICAgICAgIGlmIChjb3B5cmlnaHQpCiAgICAgICB7CiAgICAgICAgIHZhciBzcGFuID0gdGhpcy5jcmVhdGVfZWxlbWVudCgic3BhbiIpOwogICAgICAgICBzcGFuLmNsYXNzTmFtZSA9ICJjb3B5cmlnaHQiOwogICAgICAgICBzcGFuLmlubmVySFRNTCA9IGNvcHlyaWdodDsKICAgICAgICAgbGVmdC5hcHBlbmRDaGlsZChzcGFuKTsKICAgICAgIH0KCiAgICAgICB0aGlzLnRvb2xiYXIuc2V0QXR0cmlidXRlKCJ0YWJpbmRleCIsICIwIik7CiAgICAgICB0aGlzLnRvb2xiYXIuYXBwZW5kQ2hpbGQobGVmdCk7CiAgICAgfQogICAgIGVsc2UgLy8gSUU2IHNvIG5lZWQgdG8gd29yayBhcm91bmQgaXRzIHBvb3IgQ1NTIHN1cHBvcnQKICAgICB7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUucG9zaXRpb24gPSAodGhpcy5pZTcgPyAiZml4ZWQiIDogImFic29sdXRlIik7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUuekluZGV4ID0gIjIwMCI7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUud2lkdGggPSAiOTkuOSUiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmhlaWdodCA9ICIxLjJlbSI7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUudG9wID0gImF1dG8iOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmJvdHRvbSA9ICIwIjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5sZWZ0ID0gIjAiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLnJpZ2h0ID0gIjAiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLnRleHRBbGlnbiA9ICJsZWZ0IjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5mb250U2l6ZSA9ICI2MCUiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmNvbG9yID0gInJlZCI7CiAgICAgICB0aGlzLnRvb2xiYXIuYm9yZGVyV2lkdGggPSAwOwogICAgICAgdGhpcy50b29sYmFyLmNsYXNzTmFtZSA9ICJ0b29sYmFyIjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5iYWNrZ3JvdW5kID0gInJnYigyNDAsMjQwLDI0MCkiOwoKICAgICAgIC8vIHdvdWxkIGxpa2UgdG8gaGF2ZSBoZWxwIHRleHQgbGVmdCBhbGlnbmVkCiAgICAgICAvLyBhbmQgcGFnZSBjb3VudGVyIHJpZ2h0IGFsaWduZWQsIGZsb2F0aW5nCiAgICAgICAvLyBkaXYncyBkb24ndCB3b3JrLCBzbyBpbnN0ZWFkIHVzZSBuZXN0ZWQKICAgICAgIC8vIGFic29sdXRlbHkgcG9zaXRpb25lZCBkaXYncy4KCiAgICAgICB2YXIgc3AgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICBzcC5pbm5lckhUTUwgPSAiJm5ic3A7Jm5ic3A7KiZuYnNwOyI7CiAgICAgICB0aGlzLnRvb2xiYXIuYXBwZW5kQ2hpbGQoc3ApOwogICAgICAgdGhpcy5lb3MgPSBzcDsgIC8vIGVuZCBvZiBzbGlkZSBpbmRpY2F0b3IKCiAgICAgICB2YXIgaGVscCA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImEiKTsKICAgICAgIGhlbHAuc2V0QXR0cmlidXRlKCJocmVmIiwgdGhpcy5oZWxwX3BhZ2UpOwogICAgICAgaGVscC5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSh0aGlzLmhlbHBfdGV4dCkpOwogICAgICAgaGVscC5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJoZWxwPyIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGhlbHApOwogICAgICAgdGhpcy5oZWxwX2FuY2hvciA9IGhlbHA7ICAvLyBzYXZlIGZvciBmb2N1cyBoYWNrCgogICAgICAgdmFyIGdhcDEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGdhcDEpOwoKICAgICAgIHZhciBjb250ZW50cyA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImEiKTsKICAgICAgIGNvbnRlbnRzLnNldEF0dHJpYnV0ZSgiaHJlZiIsICJqYXZhc2NyaXB0OnRvZ2dsZVRhYmxlT2ZDb250ZW50cygpIik7CiAgICAgICBjb250ZW50cy5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSgidGFibGUgb2YgY29udGVudHMiLmxvY2FsaXplKSk7CiAgICAgICBjb250ZW50cy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJjb250ZW50cz8iKTsKICAgICAgIHRoaXMudG9vbGJhci5hcHBlbmRDaGlsZChjb250ZW50cyk7CgogICAgICAgdmFyIGdhcDIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGdhcDIpOwoKICAgICAgIHZhciBjb3B5cmlnaHQgPSB0aGlzLmZpbmRfY29weXJpZ2h0KCk7CgogICAgICAgaWYgKGNvcHlyaWdodCkKICAgICAgIHsKICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gY29weXJpZ2h0OwogICAgICAgICBzcGFuLnN0eWxlLmNvbG9yID0gImJsYWNrIjsKICAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5MZWZ0ID0gIjAuNWVtIjsKICAgICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKHNwYW4pOwogICAgICAgfQoKICAgICAgIGNvdW50ZXIgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKQogICAgICAgY291bnRlci5zdHlsZS5wb3NpdGlvbiA9ICJhYnNvbHV0ZSI7CiAgICAgICBjb3VudGVyLnN0eWxlLndpZHRoID0gImF1dG8iOyAvLyIyMCUiOwogICAgICAgY291bnRlci5zdHlsZS5oZWlnaHQgPSAiMS4yZW0iOwogICAgICAgY291bnRlci5zdHlsZS50b3AgPSAiYXV0byI7CiAgICAgICBjb3VudGVyLnN0eWxlLmJvdHRvbSA9IDA7CiAgICAgICBjb3VudGVyLnN0eWxlLnJpZ2h0ID0gIjAiOwogICAgICAgY291bnRlci5zdHlsZS50ZXh0QWxpZ24gPSAicmlnaHQiOwogICAgICAgY291bnRlci5zdHlsZS5jb2xvciA9ICJyZWQiOwogICAgICAgY291bnRlci5zdHlsZS5iYWNrZ3JvdW5kID0gInJnYigyNDAsMjQwLDI0MCkiOwoKICAgICAgIGNvdW50ZXIuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgic2xpZGUiKSArICIgbi9tIjsKICAgICAgIHRoaXMudG9vbGJhci5hcHBlbmRDaGlsZChjb3VudGVyKTsKICAgICB9CgogICAgIC8vIGVuc3VyZSB0aGF0IGNsaWNrIGlzbid0IHBhc3NlZCB0aHJvdWdoIHRvIHRoZSBwYWdlCiAgICAgdGhpcy50b29sYmFyLm9uY2xpY2sgPQogICAgICAgICBmdW5jdGlvbiAoZSkgewogICAgICAgICAgIGlmICghZSkKICAgICAgICAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDsKCiAgICAgICAgICAgaWYgKCF0YXJnZXQgJiYgZS5zcmNFbGVtZW50KQogICAgICAgICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBTYWZhcmkgYnVnCiAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMykKICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlOwoKICAgICAgICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKCiAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSAiYSIpCiAgICAgICAgICAgICB3M2Nfc2xpZHkubW91c2VfYnV0dG9uX2NsaWNrKGUpOwogICAgICAgICB9OwoKICAgICB0aGlzLnNsaWRlX251bWJlcl9lbGVtZW50ID0gY291bnRlcjsKICAgICB0aGlzLnNldF9lb3Nfc3RhdHVzKGZhbHNlKTsKICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudG9vbGJhcik7CiAgfSwKCiAgLy8gd3lzaXd5ZyBlZGl0b3JzIG1ha2UgaXQgaGFyZCB0byB1c2UgZGl2IGVsZW1lbnRzCiAgLy8gZS5nLiBhbWF5YSBsb3NlcyB0aGUgZGl2IHdoZW4geW91IGNvcHkgYW5kIHBhc3RlCiAgLy8gdGhpcyBmdW5jdGlvbiB3cmFwcyBkaXYgZWxlbWVudHMgYXJvdW5kIGltcGxpY2l0CiAgLy8gc2xpZGVzIHdoaWNoIHN0YXJ0IHdpdGggYW4gaDEgZWxlbWVudCBhbmQgY29udGludWUKICAvLyB1cCB0byB0aGUgbmV4dCBoZWFkaW5nIG9yIGRpdiBlbGVtZW50CiAgd3JhcF9pbXBsaWNpdF9zbGlkZXM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBpLCBoZWFkaW5nLCBub2RlLCBuZXh0LCBkaXY7CiAgICB2YXIgaGVhZGluZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaDEiKTsKCiAgICBpZiAoIWhlYWRpbmdzKQogICAgICByZXR1cm47CgogICAgZm9yIChpID0gMDsgaSA8IGhlYWRpbmdzLmxlbmd0aDsgKytpKQogICAgewogICAgICBoZWFkaW5nID0gaGVhZGluZ3NbaV07CgogICAgICBpZiAoaGVhZGluZy5wYXJlbnROb2RlICE9IGRvY3VtZW50LmJvZHkpCiAgICAgICAgY29udGludWU7CgogICAgICBub2RlID0gaGVhZGluZy5uZXh0U2libGluZzsKCiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwogICAgICB0aGlzLmFkZF9jbGFzcyhkaXYsICJzbGlkZSIpOwogICAgICBkb2N1bWVudC5ib2R5LnJlcGxhY2VDaGlsZChkaXYsIGhlYWRpbmcpOwogICAgICBkaXYuYXBwZW5kQ2hpbGQoaGVhZGluZyk7CgogICAgICB3aGlsZSAobm9kZSkKICAgICAgewogICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIC8vIGFuIGVsZW1lbnQKICAgICAgICB7CiAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gIkgxIiB8fCBub2RlLm5vZGVOYW1lID09ICJoMSIpCiAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gIkRJViIgfHwgbm9kZS5ub2RlTmFtZSA9PSAiZGl2IikKICAgICAgICAgICB7CiAgICAgICAgICAgICBpZiAodGhpcy5oYXNfY2xhc3Mobm9kZSwgInNsaWRlIikpCiAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgIGlmICh0aGlzLmhhc19jbGFzcyhub2RlLCAiaGFuZG91dCIpKQogICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZzsKICAgICAgICBub2RlID0gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub2RlKTsKICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZSk7CiAgICAgICAgbm9kZSA9IG5leHQ7CiAgICAgIH0gCiAgICB9CiAgfSwKCiAgYXR0YWNoX3RvdWNoX2hhbmRlcnM6IGZ1bmN0aW9uKHNsaWRlcykKICB7CiAgICB2YXIgaSwgc2xpZGU7CgogICAgZm9yIChpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgc2xpZGUgPSBzbGlkZXNbaV07CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKHNsaWRlLCAidG91Y2hzdGFydCIsIHRoaXMudG91Y2hzdGFydCk7CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKHNsaWRlLCAidG91Y2htb3ZlIiwgdGhpcy50b3VjaG1vdmUpOwogICAgICB0aGlzLmFkZF9saXN0ZW5lcihzbGlkZSwgInRvdWNoZW5kIiwgdGhpcy50b3VjaGVuZCk7CiAgICB9CiAgfSwKCi8vIHJldHVybiBuZXcgYXJyYXkgb2YgYWxsIHNsaWRlcwogIGNvbGxlY3Rfc2xpZGVzOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgc2xpZGVzID0gbmV3IEFycmF5KCk7CiAgICB2YXIgZGl2cyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgZGl2ID0gZGl2cy5pdGVtKGkpOwoKICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKGRpdiwgInNsaWRlIikpCiAgICAgIHsKICAgICAgICAvLyBhZGQgc2xpZGUgdG8gY29sbGVjdGlvbgogICAgICAgIHNsaWRlc1tzbGlkZXMubGVuZ3RoXSA9IGRpdjsKCiAgICAgICAgLy8gaGlkZSBlYWNoIHNsaWRlIGFzIGl0IGlzIGZvdW5kCiAgICAgICAgdGhpcy5hZGRfY2xhc3MoZGl2LCAiaGlkZGVuIik7CgogICAgICAgIC8vIGFkZCBkdW1teSA8YnIvPiBhdCBlbmQgZm9yIHNjcm9sbGluZyBoYWNrCiAgICAgICAgdmFyIG5vZGUxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnIiKTsKICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZTEpOwogICAgICAgIHZhciBub2RlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImJyIik7CiAgICAgICAgZGl2LmFwcGVuZENoaWxkKG5vZGUyKTsKICAgICAgfQogICAgICBlbHNlIGlmICh0aGlzLmhhc19jbGFzcyhkaXYsICJiYWNrZ3JvdW5kIikpCiAgICAgIHsgIC8vIHdvcmsgYXJvdW5kIGZvciBGaXJlZm94IFNWRyByZWxvYWQgYnVnCiAgICAgICAgLy8gd2hpY2ggb3RoZXJ3aXNlIHJlcGxhY2VzIDFzdCBTVkcgZ3JhcGhpYyB3aXRoIDJuZAogICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsKICAgICAgfQogICAgfQoKICAgIHRoaXMuc2xpZGVzID0gc2xpZGVzOwogIH0sCgogIC8vIHJldHVybiBuZXcgYXJyYXkgb2YgYWxsIDxkaXYgY2xhc3M9ImhhbmRvdXQiPgogIGNvbGxlY3Rfbm90ZXM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBub3RlcyA9IG5ldyBBcnJheSgpOwogICAgdmFyIGRpdnMgPSBkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpdnMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGRpdiA9IGRpdnMuaXRlbShpKTsKCiAgICAgIGlmICh0aGlzLmhhc19jbGFzcyhkaXYsICJoYW5kb3V0IikpCiAgICAgIHsKICAgICAgICAvLyBhZGQgbm90ZSB0byBjb2xsZWN0aW9uCiAgICAgICAgbm90ZXNbbm90ZXMubGVuZ3RoXSA9IGRpdjsKCiAgICAgICAgLy8gYW5kIGhpZGUgaXQKICAgICAgICB0aGlzLmFkZF9jbGFzcyhkaXYsICJoaWRkZW4iKTsKICAgICAgfQogICAgfQoKICAgIHRoaXMubm90ZXMgPSBub3RlczsKICB9LAoKICAvLyByZXR1cm4gbmV3IGFycmF5IG9mIGFsbCA8ZGl2IGNsYXNzPSJiYWNrZ3JvdW5kIj4KICAvLyBpbmNsdWRpbmcgbmFtZWQgYmFja2dyb3VuZHMgZS5nLiBjbGFzcz0iYmFja2dyb3VuZCB0aXRsZXBhZ2UiCiAgY29sbGVjdF9iYWNrZ3JvdW5kczogZnVuY3Rpb24gKCkgewogICAgdmFyIGJhY2tncm91bmRzID0gbmV3IEFycmF5KCk7CiAgICB2YXIgZGl2cyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgZGl2ID0gZGl2cy5pdGVtKGkpOwoKICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKGRpdiwgImJhY2tncm91bmQiKSkKICAgICAgewogICAgICAgIC8vIGFkZCBiYWNrZ3JvdW5kIHRvIGNvbGxlY3Rpb24KICAgICAgICBiYWNrZ3JvdW5kc1tiYWNrZ3JvdW5kcy5sZW5ndGhdID0gZGl2OwoKICAgICAgICAvLyBhbmQgaGlkZSBpdAogICAgICAgIHRoaXMuYWRkX2NsYXNzKGRpdiwgImhpZGRlbiIpOwogICAgICB9CiAgICB9CgogICAgdGhpcy5iYWNrZ3JvdW5kcyA9IGJhY2tncm91bmRzOwogIH0sCgogIC8vIHNldCBjbGljayBoYW5kbGVycyBvbiBhbGwgYW5jaG9ycwogIHBhdGNoX2FuY2hvcnM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBzZWxmID0gdzNjX3NsaWR5OwogICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsKICAgICAgLy8gY29tcGFyZSB0aGlzLmhyZWYgd2l0aCBsb2NhdGlvbi5ocmVmCiAgICAgIC8vIGZvciBsaW5rIHRvIGFub3RoZXIgc2xpZGUgaW4gdGhpcyBkb2MKCiAgICAgIGlmIChzZWxmLnBhZ2VfYWRkcmVzcyh0aGlzLmhyZWYpID09IHNlbGYucGFnZV9hZGRyZXNzKGxvY2F0aW9uLmhyZWYpKQogICAgICB7CiAgICAgICAgLy8geWVzLCBzbyBmaW5kIG5ldyBzbGlkZSBudW1iZXIKICAgICAgICB2YXIgbmV3c2xpZGVudW0gPSBzZWxmLmZpbmRfc2xpZGVfbnVtYmVyKHRoaXMuaHJlZik7CgogICAgICAgIGlmIChuZXdzbGlkZW51bSAhPSBzZWxmLnNsaWRlX251bWJlcikKICAgICAgICB7CiAgICAgICAgICB2YXIgc2xpZGUgPSBzZWxmLnNsaWRlc1tzZWxmLnNsaWRlX251bWJlcl07CiAgICAgICAgICBzZWxmLmhpZGVfc2xpZGUoc2xpZGUpOwogICAgICAgICAgc2VsZi5zbGlkZV9udW1iZXIgPSBuZXdzbGlkZW51bTsKICAgICAgICAgIHNsaWRlID0gc2VsZi5zbGlkZXNbc2VsZi5zbGlkZV9udW1iZXJdOwogICAgICAgICAgc2VsZi5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgICAgIHNlbGYuc2V0X2xvY2F0aW9uKCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGVsc2UKICAgICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihldmVudCk7CgovLyAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0ID09IG51bGwpCi8vICAgICAgICBsb2NhdGlvbi5ocmVmID0gdGhpcy5ocmVmOwoKICAgICAgdGhpcy5ibHVyKCk7CiAgICAgIHNlbGYuZGlzYWJsZV9zbGlkZV9jbGljayA9IHRydWU7CiAgICB9OwoKICAgIHZhciBhbmNob3JzID0gZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jaG9ycy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKQogICAgICAgIGFuY2hvcnNbaV0uYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCBoYW5kbGVyLCBmYWxzZSk7CiAgICAgIGVsc2UKICAgICAgICBhbmNob3JzW2ldLmF0dGFjaEV2ZW50KCJvbmNsaWNrIiwgaGFuZGxlcik7CiAgICB9CiAgfSwKCiAgLy8gIyMjIENIRUNLIE1FICMjIyBzZWUgd2hpY2ggZnVuY3Rpb25zIGFyZSBpbnZva2VkIHZpYSBzZXRUaW1lb3V0CiAgLy8gZWl0aGVyIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgZm9yIHVzZSBvZiB3M2Nfc2xpZHkgdnMgdGhpcwogIHNob3dfc2xpZGVfbnVtYmVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgdGltZXIgPSB3M2Nfc2xpZHkuZ2V0X3RpbWVyKCk7CiAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyX2VsZW1lbnQuaW5uZXJIVE1MID0gdGltZXIgKyB3M2Nfc2xpZHkubG9jYWxpemUoInNsaWRlIikgKyAiICIgKwogICAgICAgICAgICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyICsgMSkgKyAiLyIgKyB3M2Nfc2xpZHkuc2xpZGVzLmxlbmd0aDsKICB9LAoKICAvLyBldmVyeSAyMDBtUyBjaGVjayBpZiB0aGUgbG9jYXRpb24gaGFzIGJlZW4gY2hhbmdlZCBhcyBhCiAgLy8gcmVzdWx0IG9mIHRoZSB1c2VyIGFjdGl2YXRpbmcgdGhlIEJhY2sgYnV0dG9uL21lbnUgaXRlbQogIC8vIGRvZXNuJ3Qgd29yayBmb3IgT3BlcmEgPCA5LjUKICBjaGVja19sb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoOwoKICAgIGlmICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID4gMCAmJiAoaGFzaCA9PSAiIiB8fCBoYXNoID09ICIjIikpCiAgICAgIHczY19zbGlkeS5nb3RvX3NsaWRlKDApOwogICAgZWxzZSBpZiAoaGFzaC5sZW5ndGggPiAyICYmIGhhc2ggIT0gIiMoIisodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSsiKSIpCiAgICB7CiAgICAgIHZhciBudW0gPSBwYXJzZUludChsb2NhdGlvbi5oYXNoLnN1YnN0cigyKSk7CgogICAgICBpZiAoIWlzTmFOKG51bSkpCiAgICAgICAgdzNjX3NsaWR5LmdvdG9fc2xpZGUobnVtLTEpOwogICAgfQoKICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0ICYmIHczY19zbGlkeS5zbGlkZV9udW1iZXIgPiAwKQogICAgewogICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKCiAgICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0ID4gMCkKICAgICAgICB3M2Nfc2xpZHkudGltZV9sZWZ0IC09IDIwMDsKICAgIH0gCiAgfSwKCiAgZ2V0X3RpbWVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgdGltZXIgPSAiIjsKICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0KQogICAgewogICAgICB2YXIgbWlucywgc2VjczsKICAgICAgc2VjcyA9IE1hdGguZmxvb3IodzNjX3NsaWR5LnRpbWVfbGVmdC8xMDAwKTsKICAgICAgbWlucyA9IE1hdGguZmxvb3Ioc2VjcyAvIDYwKTsKICAgICAgc2VjcyA9IHNlY3MgJSA2MDsKICAgICAgdGltZXIgPSAobWlucyA/IG1pbnMrIm0iIDogIiIpICsgc2VjcyArICJzICI7CiAgICB9CgogICAgcmV0dXJuIHRpbWVyOwogIH0sCgogIC8vIHRoaXMgZG9lc24ndCBwdXNoIGxvY2F0aW9uIG9udG8gaGlzdG9yeSBzdGFjayBmb3IgSUUKICAvLyBmb3Igd2hpY2ggYSBoaWRkZW4gaWZyYW1lIGhhY2sgaXMgbmVlZGVkOiBsb2FkIHBhZ2UgaW50bwogIC8vIHRoZSBpZnJhbWUgd2l0aCBzY3JpcHQgdGhhdCBzZXQncyBwYXJlbnQncyBsb2NhdGlvbi5oYXNoCiAgLy8gYnV0IHRoYXQgd29uJ3Qgd29yayBmb3Igc3RhbmRhbG9uZSB1c2UgdW5sZXNzIHdlIGNhbgogIC8vIGNyZWF0ZSB0aGUgcGFnZSBkeW5hbWljYWxseSB2aWEgYSBqYXZhc2NyaXB0OiBVUkwKICAvLyAjIyMgdXNlIGhpc3RvcnkucHVzaFN0YXRlIGlmIGF2YWlsYWJsZQogIHNldF9sb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgIHZhciB1cmkgPSB3M2Nfc2xpZHkucGFnZV9hZGRyZXNzKGxvY2F0aW9uLmhyZWYpOwogICAgIHZhciBoYXNoID0gIiMoIiArICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyKzEpICsgIikiOwoKICAgICBpZiAodzNjX3NsaWR5LnNsaWRlX251bWJlciA+PSAwKQogICAgICAgdXJpID0gdXJpICsgaGFzaDsKCiAgICAgaWYgKHR5cGVvZihoaXN0b3J5LnB1c2hTdGF0ZSkgIT0gInVuZGVmaW5lZCIgJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICJmaWxlOiIpCiAgICAgewogICAgICAgZG9jdW1lbnQudGl0bGUgPSB3M2Nfc2xpZHkudGl0bGUgKyAiICgiICsgKHczY19zbGlkeS5zbGlkZV9udW1iZXIrMSkgKyAiKSI7CiAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSgwLCBkb2N1bWVudC50aXRsZSwgaGFzaCk7CiAgICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKICAgICAgIHczY19zbGlkeS5ub3RpZnlfb2JzZXJ2ZXJzKCk7CiAgICAgICByZXR1cm47CiAgICAgfQoKICAgICBpZiAodzNjX3NsaWR5LmllICYmICh3M2Nfc2xpZHkuaWU2IHx8IHczY19zbGlkeS5pZTcpKQogICAgICAgdzNjX3NsaWR5LnB1c2hfaGFzaChoYXNoKTsKCiAgICAgaWYgKHVyaSAhPSBsb2NhdGlvbi5ocmVmKSAvLyAmJiAha2h0bWwKICAgICAgICBsb2NhdGlvbi5ocmVmID0gdXJpOwoKICAgICBpZiAodGhpcy5raHRtbCkKICAgICAgICBoYXNoID0gIigiICsgKHczY19zbGlkeS5zbGlkZV9udW1iZXIrMSkgKyAiKSI7CgogICAgIGlmICghdGhpcy5pZSAmJiBsb2NhdGlvbi5oYXNoICE9IGhhc2ggJiYgbG9jYXRpb24uaGFzaCAhPSAiIikKICAgICAgIGxvY2F0aW9uLmhhc2ggPSBoYXNoOwoKICAgICBkb2N1bWVudC50aXRsZSA9IHczY19zbGlkeS50aXRsZSArICIgKCIgKyAodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSArICIpIjsKICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKICAgICB3M2Nfc2xpZHkubm90aWZ5X29ic2VydmVycygpOwogIH0sCgogIG5vdGlmeV9vYnNlcnZlcnM6IGZ1bmN0aW9uICgpCiAgewogICAgdmFyIHNsaWRlID0gdGhpcy5zbGlkZXNbdGhpcy5zbGlkZV9udW1iZXJdOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyArK2kpCiAgICAgIHRoaXMub2JzZXJ2ZXJzW2ldKHRoaXMuc2xpZGVfbnVtYmVyKzEsIHRoaXMuZmluZF9oZWFkaW5nKHNsaWRlKS5pbm5lclRleHQsIGxvY2F0aW9uLmhyZWYpOwogIH0sCgogIGFkZF9vYnNlcnZlcjogZnVuY3Rpb24gKG9ic2VydmVyKQogIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGlmIChvYnNlcnZlciA9PSB0aGlzLm9ic2VydmVyc1tpXSkKICAgICAgICByZXR1cm47CiAgICB9CgogICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7CiAgfSwKCiAgcmVtb3ZlX29ic2VydmVyOiBmdW5jdGlvbiAobykKICB7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgKytpKQogICAgewogICAgICBpZiAob2JzZXJ2ZXIgPT0gdGhpcy5vYnNlcnZlcnNbaV0pCiAgICAgIHsKICAgICAgICB0aGlzLm9ic2VydmVycy5zcGxpY2UoaSwxKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogIH0sCgogIHBhZ2VfYWRkcmVzczogZnVuY3Rpb24gKHVyaSkgewogICAgdmFyIGkgPSB1cmkuaW5kZXhPZigiIyIpOwoKICAgIGlmIChpIDwgMCkKICAgICAgaSA9IHVyaS5pbmRleE9mKCIlMjMiKTsKCiAgICAvLyBjaGVjayBpZiBhbmNob3IgaXMgZW50aXJlIHBhZ2UKCiAgICBpZiAoaSA8IDApCiAgICAgIHJldHVybiB1cmk7ICAvLyB5ZXMKCiAgICByZXR1cm4gdXJpLnN1YnN0cigwLCBpKTsKICB9LAoKICAvLyBvbmx5IHVzZWQgZm9yIElFNiBhbmQgSUU3CiAgb25fZnJhbWVfbG9hZGVkOiBmdW5jdGlvbiAoaGFzaCkgewogICAgbG9jYXRpb24uaGFzaCA9IGhhc2g7CiAgICB2YXIgdXJpID0gdzNjX3NsaWR5LnBhZ2VfYWRkcmVzcyhsb2NhdGlvbi5ocmVmKTsKICAgIGxvY2F0aW9uLmhyZWYgPSB1cmkgKyBoYXNoOwogIH0sCgogIC8vIGhpc3RvcnkgaGFjayB3aXRoIHRoYW5rcyB0byBCZXJ0cmFuZCBMZSBSb3kKICBwdXNoX2hhc2g6IGZ1bmN0aW9uIChoYXNoKSB7CiAgICBpZiAoaGFzaCA9PSAiIikgaGFzaCA9ICIjKDEpIjsKICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoOwoKICAgIHZhciBkb2MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiaGlzdG9yeUZyYW1lIikuY29udGVudFdpbmRvdy5kb2N1bWVudDsKICAgIGRvYy5vcGVuKCJqYXZhc2NyaXB0Oic8aHRtbD48L2h0bWw+JyIpOwogICAgZG9jLndyaXRlKCI8aHRtbD48aGVhZD48c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj53aW5kb3cucGFyZW50LnczY19zbGlkeS5vbl9mcmFtZV9sb2FkZWQoJyIrCiAgICAgIChoYXNoKSArICInKTs8L3NjcmlwdD48L2hlYWQ+PGJvZHk+aGVsbG8gbXVtPC9ib2R5PjwvaHRtbD4iKTsKICAgICAgZG9jLmNsb3NlKCk7CiAgfSwKCiAgLy8gZmluZCBjdXJyZW50IHNsaWRlIGJhc2VkIHVwb24gbG9jYXRpb24KICAvLyBmaXJzdCBmaW5kIHRhcmdldCBhbmNob3IgYW5kIHRoZW4gbG9vawogIC8vIGZvciBhc3NvY2lhdGVkIGRpdiBlbGVtZW50IGVuY2xvc2luZyBpdAogIC8vIGZpbmFsbHkgbWFwIHRoYXQgdG8gc2xpZGUgbnVtYmVyCiAgZmluZF9zbGlkZV9udW1iZXI6IGZ1bmN0aW9uICh1cmkpIHsKICAgIC8vIGZpcnN0IGdldCBhbmNob3IgZnJvbSBwYWdlIGxvY2F0aW9uCgogICAgdmFyIGkgPSB1cmkuaW5kZXhPZigiIyIpOwoKICAgIC8vIGNoZWNrIGlmIGFuY2hvciBpcyBlbnRpcmUgcGFnZQogICAgaWYgKGkgPCAwKQogICAgICByZXR1cm4gMDsgIC8vIHllcwoKICAgIHZhciBhbmNob3IgPSB1bmVzY2FwZSh1cmkuc3Vic3RyKGkrMSkpOwoKICAgIC8vIG5vdyB1c2UgYW5jaG9yIGFzIFhNTCBJRCB0byBmaW5kIHRhcmdldAogICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFuY2hvcik7CgogICAgaWYgKCF0YXJnZXQpCiAgICB7CiAgICAgIC8vIGRvZXMgYW5jaG9yIGxvb2sgbGlrZSAiKDIpIiBmb3Igc2xpZGUgMiA/PwogICAgICAvLyB3aGVyZSBmaXJzdCBzbGlkZSBpcyAoMSkKICAgICAgdmFyIHJlID0gL1woKFxkKStcKS87CgogICAgICBpZiAoYW5jaG9yLm1hdGNoKHJlKSkKICAgICAgewogICAgICAgIHZhciBudW0gPSBwYXJzZUludChhbmNob3Iuc3Vic3RyaW5nKDEsIGFuY2hvci5sZW5ndGgtMSkpOwoKICAgICAgICBpZiAobnVtID4gdGhpcy5zbGlkZXMubGVuZ3RoKQogICAgICAgICAgbnVtID0gMTsKCiAgICAgICAgaWYgKC0tbnVtIDwgMCkKICAgICAgICAgIG51bSA9IDA7CgogICAgICAgIHJldHVybiBudW07CiAgICAgIH0KCiAgICAgIC8vIGFjY2VwdCBbMl0gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5CiAgICAgIHJlID0gL1xbKFxkKStcXS87CgogICAgICBpZiAoYW5jaG9yLm1hdGNoKHJlKSkKICAgICAgewogICAgICAgICB2YXIgbnVtID0gcGFyc2VJbnQoYW5jaG9yLnN1YnN0cmluZygxLCBhbmNob3IubGVuZ3RoLTEpKTsKCiAgICAgICAgIGlmIChudW0gPiB0aGlzLnNsaWRlcy5sZW5ndGgpCiAgICAgICAgICAgIG51bSA9IDE7CgogICAgICAgICBpZiAoLS1udW0gPCAwKQogICAgICAgICAgICBudW0gPSAwOwoKICAgICAgICAgcmV0dXJuIG51bTsKICAgICAgfQoKICAgICAgLy8gb2ggZGVhciB1bmtub3duIGFuY2hvcgogICAgICByZXR1cm4gMDsKICAgIH0KCiAgICAvLyBzZWFyY2ggZm9yIGVuY2xvc2luZyBzbGlkZQoKICAgIHdoaWxlICh0cnVlKQogICAgewogICAgICAvLyBicm93c2VyIGNvZXJjZXMgaHRtbCBlbGVtZW50cyB0byB1cHBlcmNhc2UhCiAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAiZGl2IiAmJgogICAgICAgICAgICB0aGlzLmhhc19jbGFzcyh0YXJnZXQsICJzbGlkZSIpKQogICAgICB7CiAgICAgICAgLy8gZm91bmQgdGhlIHNsaWRlIGVsZW1lbnQKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgLy8gb3RoZXJ3aXNlIHRyeSBwYXJlbnQgZWxlbWVudCBpZiBhbnkKCiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlOwoKICAgICAgaWYgKCF0YXJnZXQpCiAgICAgIHsKICAgICAgICByZXR1cm4gMDsgICAvLyBubyBsdWNrIQogICAgICB9CiAgICB9OwoKICAgIGZvciAoaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGlmIChzbGlkZXNbaV0gPT0gdGFyZ2V0KQogICAgICAgIHJldHVybiBpOyAgLy8gc3VjY2VzcwogICAgfQoKICAgIC8vIG9oIGRlYXIgc3RpbGwgbm8gbHVjawogICAgcmV0dXJuIDA7CiAgfSwKCiAgcHJldmlvdXNfc2xpZGU6IGZ1bmN0aW9uIChpbmNyZW1lbnRhbCkgewogICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICB7CiAgICAgIHZhciBzbGlkZTsKCiAgICAgIGlmICgoaW5jcmVtZW50YWwgfHwgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9PSAwKSAmJiB3M2Nfc2xpZHkubGFzdF9zaG93biAhPSBudWxsKQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkuaGlkZV9wcmV2aW91c19pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXMoZmFsc2UpOwogICAgICB9CiAgICAgIGVsc2UgaWYgKHczY19zbGlkeS5zbGlkZV9udW1iZXIgPiAwKQogICAgICB7CiAgICAgICAgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5oaWRlX3NsaWRlKHNsaWRlKTsKCiAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5zbGlkZV9udW1iZXIgLSAxOwogICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJ2aXNpYmxlIik7CiAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkucHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbShudWxsKTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXModHJ1ZSk7CiAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CgogICAgICBpZiAoIXczY19zbGlkeS5uc19wb3MpCiAgICAgICAgdzNjX3NsaWR5LnJlZnJlc2hfdG9vbGJhcigyMDApOwogICAgfQogIH0sCgogIG5leHRfc2xpZGU6IGZ1bmN0aW9uIChpbmNyZW1lbnRhbCkgewogICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICB7CiAgICAgIHZhciBzbGlkZSwgbGFzdCA9IHczY19zbGlkeS5sYXN0X3Nob3duOwoKICAgICAgaWYgKGluY3JlbWVudGFsIHx8IHczY19zbGlkeS5zbGlkZV9udW1iZXIgPT0gdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IHczY19zbGlkeS5yZXZlYWxfbmV4dF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKTsKCiAgICAgIGlmICgoIWluY3JlbWVudGFsIHx8IHczY19zbGlkeS5sYXN0X3Nob3duID09IG51bGwpICYmCiAgICAgICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyIDwgdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwoKICAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5zbGlkZV9udW1iZXIgKyAxOwogICAgICAgICBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICAgICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgfQogICAgICBlbHNlIGlmICghdzNjX3NsaWR5Lmxhc3Rfc2hvd24pCiAgICAgIHsKICAgICAgICAgaWYgKGxhc3QgJiYgaW5jcmVtZW50YWwpCiAgICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSBsYXN0OwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CgogICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXMoIXczY19zbGlkeS5uZXh0X2luY3JlbWVudGFsX2l0ZW0odzNjX3NsaWR5Lmxhc3Rfc2hvd24pKTsKCiAgICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcykKICAgICAgICAgdzNjX3NsaWR5LnJlZnJlc2hfdG9vbGJhcigyMDApOwogICAgIH0KICB9LAoKICAvLyB0byBmaXJzdCBzbGlkZSB3aXRoIG5vdGhpbmcgcmV2ZWFsZWQKICAvLyBpLmUuIHN0YXRlIGF0IHN0YXJ0IG9mIHByZXNlbnRhdGlvbgogIGZpcnN0X3NsaWRlOiBmdW5jdGlvbiAoKSB7CiAgICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICAgewogICAgICAgdmFyIHNsaWRlOwoKICAgICAgIGlmICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyICE9IDApCiAgICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwoKICAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IDA7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSBudWxsOwogICAgICAgICB3M2Nfc2xpZHkuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJoaWRkZW4iKTsKICAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICAgfQoKICAgICAgIHczY19zbGlkeS5zZXRfZW9zX3N0YXR1cygKICAgICAgICAgIXczY19zbGlkeS5uZXh0X2luY3JlbWVudGFsX2l0ZW0odzNjX3NsaWR5Lmxhc3Rfc2hvd24pKTsKICAgICAgIHczY19zbGlkeS5zZXRfbG9jYXRpb24oKTsKICAgICB9CiAgfSwKCiAgLy8gZ290byBsYXN0IHNsaWRlIHdpdGggZXZlcnl0aGluZyByZXZlYWxlZAogIC8vIGkuZS4gc3RhdGUgYXQgZW5kIG9mIHByZXNlbnRhdGlvbgogIGxhc3Rfc2xpZGU6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghdzNjX3NsaWR5LnZpZXdfYWxsKQogICAgewogICAgICB2YXIgc2xpZGU7CgogICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IG51bGw7IC8vcmV2ZWFsTmV4dEl0ZW0obGFzdFNob3duKTsKCiAgICAgIGlmICh3M2Nfc2xpZHkubGFzdF9zaG93biA9PSBudWxsICYmCiAgICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyIDwgdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID0gdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxOwogICAgICAgICBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICAgICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkucHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbShudWxsKTsKCiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgidmlzaWJsZSIpOwogICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IHczY19zbGlkeS5wcmV2aW91c19pbmNyZW1lbnRhbF9pdGVtKG51bGwpOwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXModHJ1ZSk7CiAgICAgIHczY19zbGlkeS5zZXRfbG9jYXRpb24oKTsKICAgIH0KICB9LAoKCiAgLy8gIyMjIGNoZWNrIHRoaXMgYW5kIGNvbnNpZGVyIGFkZC9yZW1vdmUgY2xhc3MKICBzZXRfZW9zX3N0YXR1czogZnVuY3Rpb24gKHN0YXRlKSB7CiAgICBpZiAodGhpcy5lb3MpCiAgICAgIHRoaXMuZW9zLnN0eWxlLmNvbG9yID0gKHN0YXRlID8gInJnYigyNDAsMjQwLDI0MCkiIDogInJlZCIpOwogIH0sCgogIC8vIGZpcnN0IHNsaWRlIGlzIDAKICBnb3RvX3NsaWRlOiBmdW5jdGlvbiAobnVtKSB7CiAgICAvL2FsZXJ0KCJnb2luZyB0byBzbGlkZSAiICsgKG51bSsxKSk7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IG51bTsKICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoImhpZGRlbiIpOwogICAgdzNjX3NsaWR5LnNldF9lb3Nfc3RhdHVzKCF3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKSk7CiAgICBkb2N1bWVudC50aXRsZSA9IHczY19zbGlkeS50aXRsZSArICIgKCIgKyAodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSArICIpIjsKICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgIHczY19zbGlkeS5zaG93X3NsaWRlX251bWJlcigpOwogIH0sCgoKICBzaG93X3NsaWRlOiBmdW5jdGlvbiAoc2xpZGUpIHsKICAgIHRoaXMuc3luY19iYWNrZ3JvdW5kKHNsaWRlKTsKICAgIHRoaXMucmVtb3ZlX2NsYXNzKHNsaWRlLCAiaGlkZGVuIik7CgogICAgLy8gd29yayBhcm91bmQgSUU5IG9iamVjdCByZW5kZXJpbmcgYnVnCiAgICBzZXRUaW1lb3V0KCJ3aW5kb3cuc2Nyb2xsVG8oMCwwKTsiLCAxKTsKICB9LAoKICBoaWRlX3NsaWRlOiBmdW5jdGlvbiAoc2xpZGUpIHsKICAgIHRoaXMuYWRkX2NsYXNzKHNsaWRlLCAiaGlkZGVuIik7CiAgfSwKCiAgc2V0X2ZvY3VzOiBmdW5jdGlvbiAoZWxlbWVudCkKICB7CiAgICBpZiAoZWxlbWVudCkKICAgICAgZWxlbWVudC5mb2N1cygpOwogICAgZWxzZQogICAgewogICAgICB3M2Nfc2xpZHkuaGVscF9hbmNob3IuZm9jdXMoKTsKCiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAgICAgdzNjX3NsaWR5LmhlbHBfYW5jaG9yLmJsdXIoKTsKICAgICAgfSwgMSk7CiAgICB9CiAgfSwKCiAgLy8gc2hvdyBqdXN0IHRoZSBiYWNrZ3JvdW5kcyBwZXJ0aW5lbnQgdG8gdGhpcyBzbGlkZQogIC8vIHdoZW4gc2xpZGUgYmFja2dyb3VuZC1jb2xvciBpcyB0cmFuc3BhcmVudAogIC8vIHRoaXMgc2hvdWxkIG5vdyB3b3JrIHdpdGggcmdiYSBjb2xvciB2YWx1ZXMKICBzeW5jX2JhY2tncm91bmQ6IGZ1bmN0aW9uIChzbGlkZSkgewogICAgdmFyIGJhY2tncm91bmQ7CiAgICB2YXIgYmdDb2xvcjsKCiAgICBpZiAoc2xpZGUuY3VycmVudFN0eWxlKQogICAgICBiZ0NvbG9yID0gc2xpZGUuY3VycmVudFN0eWxlWyJiYWNrZ3JvdW5kQ29sb3IiXTsKICAgIGVsc2UgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3KQogICAgewogICAgICB2YXIgc3R5bGVzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSxudWxsKTsKCiAgICAgIGlmIChzdHlsZXMpCiAgICAgICAgYmdDb2xvciA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCJiYWNrZ3JvdW5kLWNvbG9yIik7CiAgICAgIGVsc2UgLy8gYnJva2VuIGltcGxlbWVudGF0aW9uIHByb2JhYmx5IGR1ZSBTYWZhcmkgb3IgS29ucXVlcm9yCiAgICAgIHsKICAgICAgICAvL2FsZXJ0KCJkZWZlY3RpdmUgaW1wbGVtZW50YXRpb24gb2YgZ2V0Q29tcHV0ZWRTdHlsZSgpIik7CiAgICAgICAgYmdDb2xvciA9ICJ0cmFuc3BhcmVudCI7CiAgICAgIH0KICAgIH0KICAgIGVsc2UKICAgICAgYmdDb2xvciA9PSAidHJhbnNwYXJlbnQiOwoKICAgIGlmIChiZ0NvbG9yID09ICJ0cmFuc3BhcmVudCIgfHwKICAgICAgICBiZ0NvbG9yLmluZGV4T2YoInJnYmEiKSA+PSAwIHx8CiAgICAgICAgYmdDb2xvci5pbmRleE9mKCJvcGFjaXR5IikgPj0gMCkKICAgIHsKICAgICAgdmFyIHNsaWRlQ2xhc3MgPSB0aGlzLmdldF9jbGFzc19saXN0KHNsaWRlKTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iYWNrZ3JvdW5kcy5sZW5ndGg7IGkrKykKICAgICAgewogICAgICAgIGJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmRzW2ldOwoKICAgICAgICB2YXIgYmdDbGFzcyA9IHRoaXMuZ2V0X2NsYXNzX2xpc3QoYmFja2dyb3VuZCk7CgogICAgICAgIGlmICh0aGlzLm1hdGNoaW5nX2JhY2tncm91bmQoc2xpZGVDbGFzcywgYmdDbGFzcykpCiAgICAgICAgICB0aGlzLnJlbW92ZV9jbGFzcyhiYWNrZ3JvdW5kLCAiaGlkZGVuIik7CiAgICAgICAgZWxzZQogICAgICAgICAgdGhpcy5hZGRfY2xhc3MoYmFja2dyb3VuZCwgImhpZGRlbiIpOwogICAgICB9CiAgICB9CiAgICBlbHNlIC8vIGZvcmNpYmx5IGhpZGUgYWxsIGJhY2tncm91bmRzCiAgICAgIHRoaXMuaGlkZV9iYWNrZ3JvdW5kcygpOwogIH0sCgogIGhpZGVfYmFja2dyb3VuZHM6IGZ1bmN0aW9uICgpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iYWNrZ3JvdW5kcy5sZW5ndGg7IGkrKykKICAgIHsKICAgICAgYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZHNbaV07CiAgICAgIHRoaXMuYWRkX2NsYXNzKGJhY2tncm91bmQsICJoaWRkZW4iKTsKICAgIH0KICB9LAoKICAvLyBjb21wYXJlIGNsYXNzZXMgZm9yIHNsaWRlIGFuZCBiYWNrZ3JvdW5kCiAgbWF0Y2hpbmdfYmFja2dyb3VuZDogZnVuY3Rpb24gKHNsaWRlQ2xhc3MsIGJnQ2xhc3MpIHsKICAgIHZhciBpLCBjb3VudCwgcGF0dGVybiwgcmVzdWx0OwoKICAgIC8vIGRlZmluZSBwYXR0ZXJuIGFzIHJlZ3VsYXIgZXhwcmVzc2lvbgogICAgcGF0dGVybiA9IC9cdysvZzsKCiAgICAvLyBjaGVjayBiYWNrZ3JvdW5kIGNsYXNzIG5hbWVzCiAgICByZXN1bHQgPSBiZ0NsYXNzLm1hdGNoKHBhdHRlcm4pOwoKICAgIGZvciAoaSA9IGNvdW50ID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykKICAgIHsKICAgICAgaWYgKHJlc3VsdFtpXSA9PSAiaGlkZGVuIikKICAgICAgICBjb250aW51ZTsKCiAgICAgIGlmIChyZXN1bHRbaV0gPT0gImJhY2tncm91bmQiKQoJY29udGludWU7CgogICAgICArK2NvdW50OwogICAgfQoKICAgIGlmIChjb3VudCA9PSAwKSAgLy8gZGVmYXVsdCBtYXRjaAogICAgICByZXR1cm4gdHJ1ZTsKCiAgICAvLyBjaGVjayBmb3IgbWF0Y2hlcyBhbmQgcGxhY2UgcmVzdWx0IGluIGFycmF5CiAgICByZXN1bHQgPSBzbGlkZUNsYXNzLm1hdGNoKHBhdHRlcm4pOwoKICAgIC8vIG5vdyBjaGVjayBpZiBkZXNpcmVkIG5hbWUgaXMgcHJlc2VudCBmb3IgYmFja2dyb3VuZAogICAgZm9yIChpID0gY291bnQgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKQogICAgewogICAgICBpZiAocmVzdWx0W2ldID09ICJoaWRkZW4iKQogICAgICAgIGNvbnRpbnVlOwoKICAgICAgaWYgKHRoaXMuaGFzX3Rva2VuKGJnQ2xhc3MsIHJlc3VsdFtpXSkpCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIHJlc2l6ZWQ6IGZ1bmN0aW9uICgpIHsKICAgICB2YXIgd2lkdGggPSAwOwoKICAgICBpZiAoIHR5cGVvZiggd2luZG93LmlubmVyV2lkdGggKSA9PSAnbnVtYmVyJyApCiAgICAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoOyAgLy8gTm9uIElFIGJyb3dzZXIKICAgICBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKQogICAgICAgd2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7ICAvLyBJRTYKICAgICBlbHNlIGlmIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpCiAgICAgICB3aWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7IC8vIElFNAoKICAgICB2YXIgaGVpZ2h0ID0gMDsKCiAgICAgaWYgKCB0eXBlb2YoIHdpbmRvdy5pbm5lckhlaWdodCApID09ICdudW1iZXInICkKICAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDsgIC8vIE5vbiBJRSBicm93c2VyCiAgICAgZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpCiAgICAgICBoZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OyAgLy8gSUU2CiAgICAgZWxzZSBpZiAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCkKICAgICAgIGhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBJRTQKCiAgICAgaWYgKGhlaWdodCAmJiAod2lkdGgvaGVpZ2h0ID4gMS4wNSoxMDI0Lzc2OCkpCiAgICAgewogICAgICAgd2lkdGggPSBoZWlnaHQgKiAxMDI0LjAvNzY4OwogICAgIH0KCiAgICAgLy8gSUUgZmlyZXMgb25yZXNpemUgZXZlbiB3aGVuIG9ubHkgZm9udCBzaXplIGlzIGNoYW5nZWQhCiAgICAgLy8gc28gd2UgZG8gYSBjaGVjayB0byBhdm9pZCBibG9ja2luZyA8IGFuZCA+IGFjdGlvbnMKICAgICBpZiAod2lkdGggIT0gdzNjX3NsaWR5Lmxhc3Rfd2lkdGggfHwgaGVpZ2h0ICE9IHczY19zbGlkeS5sYXN0X2hlaWdodCkKICAgICB7CiAgICAgICBpZiAod2lkdGggPj0gMTEwMCkKICAgICAgICAgdzNjX3NsaWR5LnNpemVfaW5kZXggPSA1OyAgICAvLyA0CiAgICAgICBlbHNlIGlmICh3aWR0aCA+PSAxMDAwKQogICAgICAgICB3M2Nfc2xpZHkuc2l6ZV9pbmRleCA9IDQ7ICAgIC8vIDMKICAgICAgIGVsc2UgaWYgKHdpZHRoID49IDgwMCkKICAgICAgICAgdzNjX3NsaWR5LnNpemVfaW5kZXggPSAzOyAgICAvLyAyCiAgICAgICBlbHNlIGlmICh3aWR0aCA+PSA2MDApCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gMjsgICAgLy8gMQogICAgICAgZWxzZSBpZiAod2lkdGgpCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gMDsKCiAgICAgICAvLyBhZGQgaW4gZm9udCBzaXplIGFkanVzdG1lbnQgZnJvbSBtZXRhIGVsZW1lbnQgZS5nLgogICAgICAgLy8gPG1ldGEgbmFtZT0iZm9udC1zaXplLWFkanVzdG1lbnQiIGNvbnRlbnQ9Ii0yIiAvPgogICAgICAgLy8gdXNlZnVsIHdoZW4gc2xpZGVzIGhhdmUgdG9vIG11Y2ggY29udGVudCA7LSkKCiAgICAgICBpZiAoMCA8PSB3M2Nfc2xpZHkuc2l6ZV9pbmRleCArIHczY19zbGlkeS5zaXplX2FkanVzdG1lbnQgJiYKICAgICAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ICsgdzNjX3NsaWR5LnNpemVfYWRqdXN0bWVudCA8IHczY19zbGlkeS5zaXplcy5sZW5ndGgpCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gdzNjX3NsaWR5LnNpemVfaW5kZXggKyB3M2Nfc2xpZHkuc2l6ZV9hZGp1c3RtZW50OwoKICAgICAgIC8vIGVuYWJsZXMgY3Jvc3MgYnJvd3NlciB1c2Ugb2YgcmVsYXRpdmUgd2lkdGgvaGVpZ2h0CiAgICAgICAvLyBvbiBvYmplY3QgZWxlbWVudHMgZm9yIHVzZSB3aXRoIFNWRyBhbmQgRmxhc2ggbWVkaWEKICAgICAgIHczY19zbGlkeS5hZGp1c3Rfb2JqZWN0X2RpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7CgogICAgICAgaWYgKGRvY3VtZW50LmJvZHkuc3R5bGUuZm9udFNpemUgIT0gdzNjX3NsaWR5LnNpemVzW3czY19zbGlkeS5zaXplX2luZGV4XSkKICAgICAgIHsKICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICAgICB9CgogICAgICAgdzNjX3NsaWR5Lmxhc3Rfd2lkdGggPSB3aWR0aDsKICAgICAgIHczY19zbGlkeS5sYXN0X2hlaWdodCA9IGhlaWdodDsKCiAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gd29yayBhcm91bmQgTW96aWxsYSBidWcKICAgICAgIGlmICh3M2Nfc2xpZHkubnNfcG9zKQogICAgICAgewogICAgICAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgICB3M2Nfc2xpZHkuaGlkZV9zbGlkZShzbGlkZSk7CiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgIH0KCiAgICAgICAvLyBmb3JjZSBjb3JyZWN0IHBvc2l0aW9uaW5nIG9mIHRvb2xiYXIKICAgICAgIHczY19zbGlkeS5yZWZyZXNoX3Rvb2xiYXIoMjAwKTsKICAgICB9CiAgfSwKCiAgc2Nyb2xsZWQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3M2Nfc2xpZHkudG9vbGJhciAmJiAhdzNjX3NsaWR5Lm5zX3BvcyAmJiAhdzNjX3NsaWR5LmllNykKICAgIHsKICAgICAgdzNjX3NsaWR5LmhhY2tfb2Zmc2V0ID0gdzNjX3NsaWR5LnNjcm9sbF94X29mZnNldCgpOwogICAgICAvLyBoaWRlIHRvb2xiYXIKICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUuZGlzcGxheSA9ICJub25lIjsKCiAgICAgIC8vIG1ha2UgaXQgcmVhcHBlYXIgbGF0ZXIKICAgICAgaWYgKHczY19zbGlkeS5zY3JvbGxoYWNrID09IDAgJiYgIXczY19zbGlkeS52aWV3X2FsbCkKICAgICAgewogICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge3czY19zbGlkeS5zaG93X3Rvb2xiYXIoKTsgfSwgMTAwMCk7CiAgICAgICAgdzNjX3NsaWR5LnNjcm9sbGhhY2sgPSAxOwogICAgICB9CiAgICB9CiAgfSwKCiAgaGlkZV90b29sYmFyOiBmdW5jdGlvbiAoKSB7CiAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKHczY19zbGlkeS50b29sYmFyLCAiaGlkZGVuIik7CiAgICB3aW5kb3cuZm9jdXMoKTsKICB9LAoKICAvLyB1c2VkIHRvIGVuc3VyZSBJRSByZWZyZXNoZXMgdG9vbGJhciBpbiBjb3JyZWN0IHBvc2l0aW9uCiAgcmVmcmVzaF90b29sYmFyOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHsKICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcyAmJiAhdzNjX3NsaWR5LmllNykKICAgIHsKICAgICAgdzNjX3NsaWR5LmhpZGVfdG9vbGJhcigpOwogICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHt3M2Nfc2xpZHkuc2hvd190b29sYmFyKCk7fSwgaW50ZXJ2YWwpOwogICAgfQogIH0sCgogIC8vIHJlc3RvcmVzIHRvb2xiYXIgYWZ0ZXIgc2hvcnQgZGVsYXkKICBzaG93X3Rvb2xiYXI6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3M2Nfc2xpZHkud2FudF90b29sYmFyKQogICAgewogICAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsKCiAgICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcykKICAgICAgewogICAgICAgIC8vIGFkanVzdCBwb3NpdGlvbiB0byBhbGxvdyBmb3Igc2Nyb2xsaW5nCiAgICAgICAgdmFyIHhvZmZzZXQgPSB3M2Nfc2xpZHkuc2Nyb2xsX3hfb2Zmc2V0KCk7CiAgICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUubGVmdCA9IHhvZmZzZXQ7CiAgICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUucmlnaHQgPSB4b2Zmc2V0OwoKICAgICAgICAvLyBkZXRlcm1pbmUgdmVydGljYWwgc2Nyb2xsIG9mZnNldAogICAgICAgIC8vdmFyIHlvZmZzZXQgPSBzY3JvbGxZT2Zmc2V0KCk7CgogICAgICAgIC8vIGJvdHRvbSBpcyBkb2MgaGVpZ2h0IC0gd2luZG93IGhlaWdodCAtIHNjcm9sbCBvZmZzZXQKICAgICAgICAvL3ZhciBib3R0b20gPSBkb2N1bWVudEhlaWdodCgpIC0gbGFzdEhlaWdodCAtIHlvZmZzZXQKCiAgICAgICAgLy9pZiAoeW9mZnNldCA+IDAgfHwgZG9jdW1lbnRIZWlnaHQoKSA+IGxhc3RIZWlnaHQpCiAgICAgICAgLy8gICBib3R0b20gKz0gMTY7ICAvLyBhbGxvdyBmb3IgaGVpZ2h0IG9mIHNjcm9sbGJhcgoKICAgICAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5ib3R0b20gPSAwOyAvL2JvdHRvbTsKICAgICAgfQoKICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpOwogICAgfQoKICAgIHczY19zbGlkeS5zY3JvbGxoYWNrID0gMDsKCgogICAgLy8gc2V0IHRoZSBrZXlib2FyZCBmb2N1cyB0byB0aGUgaGVscCBsaW5rIG9uIHRoZQogICAgLy8gdG9vbGJhciB0byBlbnN1cmUgdGhhdCBkb2N1bWVudCBoYXMgdGhlIGZvY3VzCiAgICAvLyBJRSBkb2Vzbid0IGFsd2F5cyB3b3JrIHdpdGggd2luZG93LmZvY3VzKCkKICAgIC8vIGFuZCB0aGlzIGhhY2sgaGFzIGJlbmVmaXQgb2YgRW50ZXIgZm9yIGhlbHAKCiAgICB0cnkKICAgIHsKICAgICAgaWYgKCF3M2Nfc2xpZHkub3BlcmEpCiAgICAgICAgdzNjX3NsaWR5LnNldF9mb2N1cygpOwogICAgfQogICAgY2F0Y2ggKGUpCiAgICB7CiAgICB9CiAgfSwKCi8vIGludm9rZWQgdmlhIEYga2V5CiAgdG9nZ2xlX3Rvb2xiYXI6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghdzNjX3NsaWR5LnZpZXdfYWxsKQogICAgewogICAgICBpZiAodzNjX3NsaWR5Lmhhc19jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpKQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpCiAgICAgICAgdzNjX3NsaWR5LndhbnRfdG9vbGJhciA9IDE7CiAgICAgIH0KICAgICAgZWxzZQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5LmFkZF9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpCiAgICAgICAgdzNjX3NsaWR5LndhbnRfdG9vbGJhciA9IDA7CiAgICAgIH0KICAgIH0KICB9LAoKICBzY3JvbGxfeF9vZmZzZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3aW5kb3cucGFnZVhPZmZzZXQpCiAgICAgIHJldHVybiBzZWxmLnBhZ2VYT2Zmc2V0OwoKICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgCiAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0OwoKICAgIGlmIChkb2N1bWVudC5ib2R5KQogICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0OwoKICAgIHJldHVybiAwOwogIH0sCgogIHNjcm9sbF95X29mZnNldDogZnVuY3Rpb24gKCkgewogICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCkKICAgICAgcmV0dXJuIHNlbGYucGFnZVlPZmZzZXQ7CgogICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAKICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApCiAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wOwoKICAgIGlmIChkb2N1bWVudC5ib2R5KQogICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7CgogICAgcmV0dXJuIDA7CiAgfSwKCiAgLy8gbG9va2luZyBmb3IgYSB3YXkgdG8gZGV0ZXJtaW5lIGhlaWdodCBvZiBzbGlkZSBjb250ZW50CiAgLy8gdGhlIHNsaWRlIGl0c2VsZiBpcyBzZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgd2luZG93CiAgb3B0aW1pemVfZm9udF9zaXplOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwoKICAgIC8vdmFyIGRoID0gZG9jdW1lbnRIZWlnaHQoKTsgLy9nZXREb2NIZWlnaHQoZG9jdW1lbnQpOwogICAgdmFyIGRoID0gc2xpZGUuc2Nyb2xsSGVpZ2h0OwogICAgdmFyIHdoID0gZ2V0V2luZG93SGVpZ2h0KCk7CiAgICB2YXIgdSA9IDEwMCAqIGRoIC8gd2g7CgogICAgYWxlcnQoIndpbmRvdyB1dGlsaXphdGlvbiA9ICIgKyB1ICsgIiUgKGRvYyAiCiAgICAgICsgZGggKyAiIHdpbiAiICsgd2ggKyAiKSIpOwogIH0sCgogIC8vIGZyb20gZG9jdW1lbnQgb2JqZWN0CiAgZ2V0X2RvY19oZWlnaHQ6IGZ1bmN0aW9uIChkb2MpIHsKICAgIGlmICghZG9jKQogICAgICBkb2MgPSBkb2N1bWVudDsKCiAgICBpZiAoZG9jICYmIGRvYy5ib2R5ICYmIGRvYy5ib2R5Lm9mZnNldEhlaWdodCkKICAgICAgcmV0dXJuIGRvYy5ib2R5Lm9mZnNldEhlaWdodDsgIC8vIG5zL2dlY2tvIHN5bnRheAoKICAgIGlmIChkb2MgJiYgZG9jLmJvZHkgJiYgZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0KQogICAgICByZXR1cm4gZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0OwoKICAgIGFsZXJ0KCJjb3VsZG4ndCBkZXRlcm1pbmUgZG9jdW1lbnQgaGVpZ2h0Iik7CiAgfSwKCiAgZ2V0X3dpbmRvd19oZWlnaHQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICggdHlwZW9mKCB3aW5kb3cuaW5uZXJIZWlnaHQgKSA9PSAnbnVtYmVyJyApCiAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQ7ICAvLyBOb24gSUUgYnJvd3NlcgoKICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7ICAvLyBJRTYKCiAgICBpZiAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBJRTQKICB9LAoKICBkb2N1bWVudF9oZWlnaHQ6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBzaCwgb2g7CgogICAgc2ggPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodDsKICAgIG9oID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7CgogICAgaWYgKHNoICYmIG9oKQogICAgewogICAgICByZXR1cm4gKHNoID4gb2ggPyBzaCA6IG9oKTsKICAgIH0KCiAgICAvLyBubyBpZGVhIQogICAgcmV0dXJuIDA7CiAgfSwKCiAgc21hbGxlcjogZnVuY3Rpb24gKCkgewogICAgaWYgKHczY19zbGlkeS5zaXplX2luZGV4ID4gMCkKICAgIHsKICAgICAgLS13M2Nfc2xpZHkuc2l6ZV9pbmRleDsKICAgIH0KCiAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiOwogICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7dzNjX3NsaWR5LnNob3dfdG9vbGJhcigpOyB9LCA1MCk7CiAgfSwKCiAgYmlnZ2VyOiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodzNjX3NsaWR5LnNpemVfaW5kZXggPCB3M2Nfc2xpZHkuc2l6ZXMubGVuZ3RoIC0gMSkKICAgIHsKICAgICAgKyt3M2Nfc2xpZHkuc2l6ZV9pbmRleDsKICAgIH0KCiAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiOwogICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7dzNjX3NsaWR5LnNob3dfdG9vbGJhcigpOyB9LCA1MCk7CiAgfSwKCiAgLy8gZW5hYmxlcyBjcm9zcyBicm93c2VyIHVzZSBvZiByZWxhdGl2ZSB3aWR0aC9oZWlnaHQKICAvLyBvbiBvYmplY3QgZWxlbWVudHMgZm9yIHVzZSB3aXRoIFNWRyBhbmQgRmxhc2ggbWVkaWEKICAvLyB3aXRoIHRoYW5rcyB0byBJdmFuIEhlcm1hbiBmb3IgdGhlIHN1Z2dlc3Rpb24KICBhZGp1c3Rfb2JqZWN0X2RpbWVuc2lvbnM6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7CiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHczY19zbGlkeS5vYmplY3RzLmxlbmd0aDsgaSsrICkKICAgIHsKICAgICAgdmFyIG9iaiA9IHRoaXMub2JqZWN0c1tpXTsKICAgICAgdmFyIG1pbWVUeXBlID0gb2JqLmdldEF0dHJpYnV0ZSgidHlwZSIpOwoKICAgICAgaWYgKG1pbWVUeXBlID09ICJpbWFnZS9zdmcreG1sIiB8fCBtaW1lVHlwZSA9PSAiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2giKQogICAgICB7CiAgICAgICAgaWYgKCAhb2JqLmluaXRpYWxXaWR0aCApIAogICAgICAgICAgb2JqLmluaXRpYWxXaWR0aCA9IG9iai5nZXRBdHRyaWJ1dGUoIndpZHRoIik7CgogICAgICAgIGlmICggIW9iai5pbml0aWFsSGVpZ2h0ICkgCiAgICAgICAgICBvYmouaW5pdGlhbEhlaWdodCA9IG9iai5nZXRBdHRyaWJ1dGUoImhlaWdodCIpOwoKICAgICAgICBpZiAoIG9iai5pbml0aWFsV2lkdGggJiYgb2JqLmluaXRpYWxXaWR0aC5jaGFyQXQob2JqLmluaXRpYWxXaWR0aC5sZW5ndGgtMSkgPT0gIiUiICkKICAgICAgICB7CiAgICAgICAgICB2YXIgdyA9IHBhcnNlSW50KG9iai5pbml0aWFsV2lkdGguc2xpY2UoMCwgb2JqLmluaXRpYWxXaWR0aC5sZW5ndGgtMSkpOwogICAgICAgICAgdmFyIG5ld1cgPSB3aWR0aCAqICh3LzEwMC4wKTsKICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoIndpZHRoIixuZXdXKTsKICAgICAgICB9CgogICAgICAgIGlmICggb2JqLmluaXRpYWxIZWlnaHQgJiYKICAgICAgICAgICAgIG9iai5pbml0aWFsSGVpZ2h0LmNoYXJBdChvYmouaW5pdGlhbEhlaWdodC5sZW5ndGgtMSkgPT0gIiUiICkKICAgICAgICB7CiAgICAgICAgICB2YXIgaCA9IHBhcnNlSW50KG9iai5pbml0aWFsSGVpZ2h0LnNsaWNlKDAsIG9iai5pbml0aWFsSGVpZ2h0Lmxlbmd0aC0xKSk7CiAgICAgICAgICB2YXIgbmV3SCA9IGhlaWdodCAqIChoLzEwMC4wKTsKICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIG5ld0gpOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0sCgogIC8vIG5lZWRlZCBmb3IgT3BlcmEgdG8gaW5oaWJpdCBkZWZhdWx0IGJlaGF2aW9yCiAgLy8gc2luY2UgT3BlcmEgZGVsaXZlcnMga2V5UHJlc3MgZXZlbiBpZiBrZXlEb3duCiAgLy8gd2FzIGNhbmNlbGxlZAogIGtleV9wcmVzczogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICBpZiAoIWV2ZW50KQogICAgICBldmVudCA9IHdpbmRvdy5ldmVudDsKCiAgICBpZiAoIXczY19zbGlkeS5rZXlfd2FudGVkKQogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgLy8gIFNlZSBlLmcuIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzL2tleXMuaHRtbCBmb3Iga2V5Y29kZXMKICBrZXlfZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICB2YXIga2V5LCB0YXJnZXQsIHRhZzsKCiAgICB3M2Nfc2xpZHkua2V5X3dhbnRlZCA9IHRydWU7CgogICAgaWYgKCFldmVudCkKICAgICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7CgogICAgLy8ga2x1ZGdlIGFyb3VuZCBOUy9JRSBkaWZmZXJlbmNlcyAKICAgIGlmICh3aW5kb3cuZXZlbnQpCiAgICB7CiAgICAgIGtleSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlOwogICAgICB0YXJnZXQgPSB3aW5kb3cuZXZlbnQuc3JjRWxlbWVudDsKICAgIH0KICAgIGVsc2UgaWYgKGV2ZW50LndoaWNoKQogICAgewogICAgICBrZXkgPSBldmVudC53aGljaDsKICAgICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OwogICAgfQogICAgZWxzZQogICAgICByZXR1cm4gdHJ1ZTsgLy8gWWlrZXMhIHVua25vd24gYnJvd3NlcgoKICAgIC8vIGlnbm9yZSBldmVudCBpZiBrZXkgdmFsdWUgaXMgemVybwogICAgLy8gYXMgZm9yIGFsdCBvbiBPcGVyYSBhbmQgS29ucXVlcm9yCiAgICBpZiAoIWtleSkKICAgICAgIHJldHVybiB0cnVlOwoKICAgIC8vIGF2b2lkIGludGVyZmVyaW5nIHdpdGgga2V5c3Ryb2tlCiAgICAvLyBiZWhhdmlvciBmb3Igbm9uLXNsaWR5IGNocm9tZSBlbGVtZW50cwogICAgaWYgKCF3M2Nfc2xpZHkuc2xpZHlfY2hyb21lKHRhcmdldCkgJiYKICAgICAgICB3M2Nfc2xpZHkuc3BlY2lhbF9lbGVtZW50KHRhcmdldCkpCiAgICAgIHJldHVybiB0cnVlOwoKICAgIC8vIGNoZWNrIGZvciBjb25jdXJyZW50IGNvbnRyb2wvY29tbWFuZC9hbHQga2V5CiAgICAvLyBidXQgYXJlIHRoZXNlIG9ubHkgcHJlc2VudCBvbiBtb3VzZSBldmVudHM/CgogICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkpCiAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAvLyBkaXNtaXNzIHRhYmxlIG9mIGNvbnRlbnRzIGlmIHZpc2libGUKICAgIGlmICh3M2Nfc2xpZHkuaXNfc2hvd25fdG9jKCkgJiYga2V5ICE9IDkgJiYga2V5ICE9IDE2ICYmIGtleSAhPSAzOCAmJiBrZXkgIT0gNDApCiAgICB7CiAgICAgIHczY19zbGlkeS5oaWRlX3RhYmxlX29mX2NvbnRlbnRzKHRydWUpOwoKICAgICAgaWYgKGtleSA9PSAyNyB8fCBrZXkgPT0gODQgfHwga2V5ID09IDY3KQogICAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KCiAgICBpZiAoa2V5ID09IDM0KSAvLyBQYWdlIERvd24KICAgIHsKICAgICAgaWYgKHczY19zbGlkeS52aWV3X2FsbCkKICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgIHczY19zbGlkeS5uZXh0X3NsaWRlKGZhbHNlKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDMzKSAvLyBQYWdlIFVwCiAgICB7CiAgICAgIGlmICh3M2Nfc2xpZHkudmlld19hbGwpCiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgICB3M2Nfc2xpZHkucHJldmlvdXNfc2xpZGUoZmFsc2UpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMzIpIC8vIHNwYWNlIGJhcgogICAgewogICAgICB3M2Nfc2xpZHkubmV4dF9zbGlkZSh0cnVlKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDM3KSAvLyBMZWZ0IGFycm93CiAgICB7CiAgICAgIHczY19zbGlkeS5wcmV2aW91c19zbGlkZSghZXZlbnQuc2hpZnRLZXkpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMzYpIC8vIEhvbWUKICAgIHsKICAgICAgdzNjX3NsaWR5LmZpcnN0X3NsaWRlKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAzNSkgLy8gRW5kCiAgICB7CiAgICAgIHczY19zbGlkeS5sYXN0X3NsaWRlKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAzOSkgLy8gUmlnaHQgYXJyb3cKICAgIHsKICAgICAgdzNjX3NsaWR5Lm5leHRfc2xpZGUoIWV2ZW50LnNoaWZ0S2V5KTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDEzKSAvLyBFbnRlcgogICAgewogICAgICBpZiAodzNjX3NsaWR5Lm91dGxpbmUpCiAgICAgIHsKICAgICAgICBpZiAodzNjX3NsaWR5Lm91dGxpbmUudmlzaWJsZSkKICAgICAgICAgIHczY19zbGlkeS5mb2xkKHczY19zbGlkeS5vdXRsaW5lKTsKICAgICAgICBlbHNlCiAgICAgICAgICB3M2Nfc2xpZHkudW5mb2xkKHczY19zbGlkeS5vdXRsaW5lKTsKICAgICAgICAgIAogICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgICB9CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTg4KSAgLy8gPCBmb3Igc21hbGxlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuc21hbGxlcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTkwKSAgLy8gPiBmb3IgbGFyZ2VyIGZvbnRzCiAgICB7CiAgICAgIHczY19zbGlkeS5iaWdnZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDE4OSB8fCBrZXkgPT0gMTA5KSAgLy8gLSBmb3Igc21hbGxlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuc21hbGxlcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTg3IHx8IGtleSA9PSAxOTEgfHwga2V5ID09IDEwNykgIC8vID0gKyAgZm9yIGxhcmdlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuYmlnZ2VyKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA4MykgIC8vIFMgZm9yIHNtYWxsZXIgZm9udHMKICAgIHsKICAgICAgdzNjX3NsaWR5LnNtYWxsZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDY2KSAgLy8gQiBmb3IgbGFyZ2VyIGZvbnRzCiAgICB7CiAgICAgIHczY19zbGlkeS5iaWdnZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDkwKSAgLy8gWiBmb3IgbGFzdCBzbGlkZQogICAgewogICAgICB3M2Nfc2xpZHkubGFzdF9zbGlkZSgpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gNzApICAvLyBGIGZvciB0b2dnbGUgdG9vbGJhcgogICAgewogICAgICB3M2Nfc2xpZHkudG9nZ2xlX3Rvb2xiYXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDY1KSAgLy8gQSBmb3IgdG9nZ2xlIHZpZXcgc2luZ2xlL2FsbCBzbGlkZXMKICAgIHsKICAgICAgdzNjX3NsaWR5LnRvZ2dsZV92aWV3KCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA3NSkgIC8vIHRvZ2dsZSBhY3Rpb24gb2YgbGVmdCBjbGljayBmb3IgbmV4dCBwYWdlCiAgICB7CiAgICAgIHczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkID0gIXczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkOwogICAgICB2YXIgYWxlcnRfbXNnID0gKHczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkID8KICAgICAgICAgICAgICAgICJlbmFibGVkIiA6ICJkaXNhYmxlZCIpICsgICIgbW91c2UgY2xpY2sgYWR2YW5jZSI7CgogICAgICBhbGVydCh3M2Nfc2xpZHkubG9jYWxpemUoYWxlcnRfbXNnKSk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA4NCB8fCBrZXkgPT0gNjcpICAvLyBUIG9yIEMgZm9yIHRhYmxlIG9mIGNvbnRlbnRzCiAgICB7CiAgICAgIGlmICh3M2Nfc2xpZHkudG9jKQogICAgICAgIHczY19zbGlkeS50b2dnbGVfdGFibGVfb2ZfY29udGVudHMoKTsKCiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA3MikgLy8gSCBmb3IgaGVscAogICAgewogICAgICB3aW5kb3cubG9jYXRpb24gPSB3M2Nfc2xpZHkuaGVscF9wYWdlOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICAvL2Vsc2UgYWxlcnQoImtleSBjb2RlIGlzICIrIGtleSk7CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgLy8gc2FmZSBmb3IgYm90aCB0ZXh0L2h0bWwgYW5kIGFwcGxpY2F0aW9uL3hodG1sK3htbAogIGNyZWF0ZV9lbGVtZW50OiBmdW5jdGlvbiAobmFtZSkgewogICAgaWYgKHRoaXMueGh0bWwgJiYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgIT0gJ3VuZGVmaW5lZCcpKQogICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiwgbmFtZSkKCiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTsKICB9LAoKICBnZXRfZWxlbWVudF9zdHlsZTogZnVuY3Rpb24gKGVsZW0sIElFU3R5bGVQcm9wLCBDU1NTdHlsZVByb3ApIHsKICAgIGlmIChlbGVtLmN1cnJlbnRTdHlsZSkKICAgIHsKICAgICAgcmV0dXJuIGVsZW0uY3VycmVudFN0eWxlW0lFU3R5bGVQcm9wXTsKICAgIH0KICAgIGVsc2UgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKQogICAgewogICAgICB2YXIgY29tcFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgIiIpOwogICAgICByZXR1cm4gY29tcFN0eWxlLmdldFByb3BlcnR5VmFsdWUoQ1NTU3R5bGVQcm9wKTsKICAgIH0KICAgIHJldHVybiAiIjsKICB9LAoKICAvLyB0aGUgc3RyaW5nIHN0ciBpcyBhIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgdG9rZW5zCiAgLy8gdGVzdCBpZiBzdHIgY29udGFpbnMgYSBwYXJ0aWN1bGFyIHRva2VuLCBlLmcuICJzbGlkZSIKICBoYXNfdG9rZW46IGZ1bmN0aW9uIChzdHIsIHRva2VuKSB7CiAgICBpZiAoc3RyKQogICAgewogICAgICAvLyBkZWZpbmUgcGF0dGVybiBhcyByZWd1bGFyIGV4cHJlc3Npb24KICAgICAgdmFyIHBhdHRlcm4gPSAvXHcrL2c7CgogICAgICAvLyBjaGVjayBmb3IgbWF0Y2hlcwogICAgICAvLyBwbGFjZSByZXN1bHQgaW4gYXJyYXkKICAgICAgdmFyIHJlc3VsdCA9IHN0ci5tYXRjaChwYXR0ZXJuKTsKCiAgICAgIC8vIG5vdyBjaGVjayBpZiBkZXNpcmVkIHRva2VuIGlzIHByZXNlbnQKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspCiAgICAgIHsKICAgICAgICBpZiAocmVzdWx0W2ldID09IHRva2VuKQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gZmFsc2U7CiAgfSwKCiAgZ2V0X2NsYXNzX2xpc3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7CiAgICBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lICE9ICd1bmRlZmluZWQnKQogICAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWU7CgogICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJjbGFzcyIpOwogIH0sCgogIGhhc19jbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsKICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9IDEpCiAgICAgIHJldHVybiBmYWxzZTsKCiAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgiKF58ICkiICsgbmFtZSArICJcVyoiKTsKCiAgICBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lICE9ICd1bmRlZmluZWQnKQogICAgICByZXR1cm4gcmVnZXhwLnRlc3QoZWxlbWVudC5jbGFzc05hbWUpOwoKICAgIHJldHVybiByZWdleHAudGVzdChlbGVtZW50LmdldEF0dHJpYnV0ZSgiY2xhc3MiKSk7CiAgfSwKCiAgcmVtb3ZlX2NsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkgewogICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoIihefCApIiArIG5hbWUgKyAiXFcqIik7CiAgICB2YXIgY2xzdmFsID0gIiI7CgogICAgaWYgKHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSAhPSAndW5kZWZpbmVkJykKICAgIHsKICAgICAgY2xzdmFsID0gZWxlbWVudC5jbGFzc05hbWU7CgogICAgICBpZiAoY2xzdmFsKQogICAgICB7CiAgICAgICAgY2xzdmFsID0gY2xzdmFsLnJlcGxhY2UocmVnZXhwLCAiIik7CiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbHN2YWw7CiAgICAgIH0KICAgIH0KICAgIGVsc2UKICAgIHsKICAgICAgY2xzdmFsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoImNsYXNzIik7CgogICAgICBpZiAoY2xzdmFsKQogICAgICB7CiAgICAgICAgY2xzdmFsID0gY2xzdmFsLnJlcGxhY2UocmVnZXhwLCAiIik7CiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgY2xzdmFsKTsKICAgICAgfQogICAgfQogIH0sCgogIGFkZF9jbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsKICAgIGlmICghdGhpcy5oYXNfY2xhc3MoZWxlbWVudCwgbmFtZSkpCiAgICB7CiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgIT0gJ3VuZGVmaW5lZCcpCiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gIiAiICsgbmFtZTsKICAgICAgZWxzZQogICAgICB7CiAgICAgICAgdmFyIGNsc3ZhbCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJjbGFzcyIpOwogICAgICAgIGNsc3ZhbCA9IGNsc3ZhbCA/IGNsc3ZhbCArICIgIiArIG5hbWUgOiBuYW1lOwogICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCJjbGFzcyIsIGNsc3ZhbCk7CiAgICAgIH0KICAgIH0KICB9LAoKICAvLyBIVE1MIGVsZW1lbnRzIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBjbGFzcz0iaW5jcmVtZW50YWwiCiAgLy8gbm90ZSB0aGF0IHlvdSBjYW4gYWxzbyBwdXQgdGhlIGNsYXNzIG9uIGNvbnRhaW5lcnMgbGlrZQogIC8vIHVwLCBvbCwgZGwsIGFuZCBkaXYgdG8gbWFrZSB0aGVpciBjb250ZW50cyBhcHBlYXIKICAvLyBpbmNyZW1lbnRhbGx5LiBVcHBlciBjYXNlIGlzIHVzZWQgc2luY2UgdGhpcyBpcyB3aGF0CiAgLy8gYnJvd3NlcnMgcmVwb3J0IGZvciBIVE1MIG5vZGUgbmFtZXMgKHRleHQvaHRtbCkuCiAgaW5jcmVtZW50YWxfZWxlbWVudHM6IG51bGwsCiAgb2theV9mb3JfaW5jcmVtZW50YWw6IGZ1bmN0aW9uIChuYW1lKSB7CiAgICBpZiAoIXRoaXMuaW5jcmVtZW50YWxfZWxlbWVudHMpCiAgICB7CiAgICAgIHZhciBpbmNsaXN0ID0gbmV3IEFycmF5KCk7CiAgICAgIGluY2xpc3RbInAiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbInByZSJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsibGkiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImJsb2NrcXVvdGUiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImR0Il0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJkZCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaDIiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImgzIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJoNCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaDUiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImg2Il0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJzcGFuIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJhZGRyZXNzIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJ0YWJsZSJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsidHIiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbInRoIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJ0ZCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaW1nIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJvYmplY3QiXSA9IHRydWU7CiAgICAgIHRoaXMuaW5jcmVtZW50YWxfZWxlbWVudHMgPSBpbmNsaXN0OwogICAgfQogICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50YWxfZWxlbWVudHNbbmFtZS50b0xvd2VyQ2FzZSgpXTsKICB9LAoKICBuZXh0X2luY3JlbWVudGFsX2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICB2YXIgYnIgPSB0aGlzLmlzX3hodG1sID8gImJyIiA6ICJCUiI7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwoKICAgIGZvciAoOzspCiAgICB7CiAgICAgIG5vZGUgPSB3M2Nfc2xpZHkubmV4dF9ub2RlKHNsaWRlLCBub2RlKTsKCiAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS5wYXJlbnROb2RlID09IG51bGwpCiAgICAgICAgYnJlYWs7CgogICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSAgLy8gRUxFTUVOVAogICAgICB7CiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gYnIpCiAgICAgICAgICBjb250aW51ZTsKCiAgICAgICAgaWYgKHczY19zbGlkeS5oYXNfY2xhc3Mobm9kZSwgImluY3JlbWVudGFsIikKICAgICAgICAgICAgICYmIHczY19zbGlkeS5va2F5X2Zvcl9pbmNyZW1lbnRhbChub2RlLm5vZGVOYW1lKSkKICAgICAgICAgIHJldHVybiBub2RlOwoKICAgICAgICBpZiAodzNjX3NsaWR5Lmhhc19jbGFzcyhub2RlLnBhcmVudE5vZGUsICJpbmNyZW1lbnRhbCIpCiAgICAgICAgICAgICAmJiAhdzNjX3NsaWR5Lmhhc19jbGFzcyhub2RlLCAibm9uLWluY3JlbWVudGFsIikpCiAgICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBub2RlOwogIH0sCgogIHByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICB2YXIgYnIgPSB0aGlzLmlzX3hodG1sID8gImJyIiA6ICJCUiI7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwoKICAgIGZvciAoOzspCiAgICB7CiAgICAgIG5vZGUgPSB3M2Nfc2xpZHkucHJldmlvdXNfbm9kZShzbGlkZSwgbm9kZSk7CgogICAgICBpZiAobm9kZSA9PSBudWxsIHx8IG5vZGUucGFyZW50Tm9kZSA9PSBudWxsKQogICAgICAgIGJyZWFrOwoKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkKICAgICAgewogICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IGJyKQogICAgICAgICAgY29udGludWU7CgogICAgICAgIGlmICh3M2Nfc2xpZHkuaGFzX2NsYXNzKG5vZGUsICJpbmNyZW1lbnRhbCIpCiAgICAgICAgICAgICAmJiB3M2Nfc2xpZHkub2theV9mb3JfaW5jcmVtZW50YWwobm9kZS5ub2RlTmFtZSkpCiAgICAgICAgICByZXR1cm4gbm9kZTsKCiAgICAgICAgaWYgKHczY19zbGlkeS5oYXNfY2xhc3Mobm9kZS5wYXJlbnROb2RlLCAiaW5jcmVtZW50YWwiKQogICAgICAgICAgICAgJiYgIXczY19zbGlkeS5oYXNfY2xhc3Mobm9kZSwgIm5vbi1pbmNyZW1lbnRhbCIpKQogICAgICAgICAgcmV0dXJuIG5vZGU7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gbm9kZTsKICB9LAoKICAvLyBzZXQgdmlzaWJpbGl0eSBmb3IgYWxsIGVsZW1lbnRzIG9uIGN1cnJlbnQgc2xpZGUgd2l0aAogIC8vIGEgcGFyZW50IGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgY2xhc3M9ImluY3JlbWVudGFsIgogIHNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbDogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICB2YXIgbm9kZSA9IHRoaXMubmV4dF9pbmNyZW1lbnRhbF9pdGVtKG51bGwpOwoKICAgIGlmICh2YWx1ZSA9PSAiaGlkZGVuIikKICAgIHsKICAgICAgd2hpbGUgKG5vZGUpCiAgICAgIHsKICAgICAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKG5vZGUsICJpbnZpc2libGUiKTsKICAgICAgICBub2RlID0gdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKICAgICAgfQogICAgfQogICAgZWxzZSAvLyB2YWx1ZSA9PSAidmlzaWJsZSIKICAgIHsKICAgICAgd2hpbGUgKG5vZGUpCiAgICAgIHsKICAgICAgICB3M2Nfc2xpZHkucmVtb3ZlX2NsYXNzKG5vZGUsICJpbnZpc2libGUiKTsKICAgICAgICBub2RlID0gdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKICAgICAgfQogICAgfQogIH0sCgogIC8vIHJldmVhbCB0aGUgbmV4dCBoaWRkZW4gaXRlbSBvbiB0aGUgc2xpZGUKICAvLyBub2RlIGlzIG51bGwgb3IgdGhlIG5vZGUgdGhhdCB3YXMgbGFzdCByZXZlYWxlZAogIHJldmVhbF9uZXh0X2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICBub2RlID0gdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKCiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEpICAvLyBhbiBlbGVtZW50CiAgICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3Mobm9kZSwgImludmlzaWJsZSIpOwoKICAgIHJldHVybiBub2RlOwogIH0sCgogIC8vIGV4YWN0IGludmVyc2Ugb2YgcmV2ZWFsTmV4dEl0ZW0obm9kZSkKICBoaWRlX3ByZXZpb3VzX2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEpICAvLyBhbiBlbGVtZW50CiAgICAgIHczY19zbGlkeS5hZGRfY2xhc3Mobm9kZSwgImludmlzaWJsZSIpOwoKICAgIHJldHVybiB0aGlzLnByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW0obm9kZSk7CiAgfSwKCiAgLy8gbGVmdCB0byByaWdodCB0cmF2ZXJzYWwgb2Ygcm9vdCdzIGNvbnRlbnQKICBuZXh0X25vZGU6IGZ1bmN0aW9uIChyb290LCBub2RlKSB7CiAgICBpZiAobm9kZSA9PSBudWxsKQogICAgICByZXR1cm4gcm9vdC5maXJzdENoaWxkOwoKICAgIGlmIChub2RlLmZpcnN0Q2hpbGQpCiAgICAgIHJldHVybiBub2RlLmZpcnN0Q2hpbGQ7CgogICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpCiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nOwoKICAgIGZvciAoOzspCiAgICB7CiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7CgogICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PSByb290KQogICAgICAgIGJyZWFrOwoKICAgICAgaWYgKG5vZGUgJiYgbm9kZS5uZXh0U2libGluZykKICAgICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZzsKICAgIH0KCiAgICByZXR1cm4gbnVsbDsKICB9LAoKICAvLyByaWdodCB0byBsZWZ0IHRyYXZlcnNhbCBvZiByb290J3MgY29udGVudAogIHByZXZpb3VzX25vZGU6IGZ1bmN0aW9uIChyb290LCBub2RlKSB7CiAgICBpZiAobm9kZSA9PSBudWxsKQogICAgewogICAgICBub2RlID0gcm9vdC5sYXN0Q2hpbGQ7CgogICAgICBpZiAobm9kZSkKICAgICAgewogICAgICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkKICAgICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDsKICAgICAgfQoKICAgICAgcmV0dXJuIG5vZGU7CiAgICB9CgogICAgaWYgKG5vZGUucHJldmlvdXNTaWJsaW5nKQogICAgewogICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7CgogICAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpCiAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkOwoKICAgICAgcmV0dXJuIG5vZGU7CiAgICB9CgogICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPSByb290KQogICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlOwoKICAgIHJldHVybiBudWxsOwogIH0sCgogIHByZXZpb3VzX3NpYmxpbmdfZWxlbWVudDogZnVuY3Rpb24gKGVsKSB7CiAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZzsKCiAgICB3aGlsZSAoZWwgJiYgZWwubm9kZVR5cGUgIT0gMSkKICAgICAgZWwgPSBlbC5wcmV2aW91c1NpYmxpbmc7CgogICAgcmV0dXJuIGVsOwogIH0sCgogIG5leHRfc2libGluZ19lbGVtZW50OiBmdW5jdGlvbiAoZWwpIHsKICAgIGVsID0gZWwubmV4dFNpYmxpbmc7CgogICAgd2hpbGUgKGVsICYmIGVsLm5vZGVUeXBlICE9IDEpCiAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7CgogICAgcmV0dXJuIGVsOwogIH0sCgogIGZpcnN0X2NoaWxkX2VsZW1lbnQ6IGZ1bmN0aW9uIChlbCkgewogICAgdmFyIG5vZGU7CgogICAgZm9yIChub2RlID0gZWwuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpCiAgICB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpCiAgICAgICAgYnJlYWs7CiAgICB9CgogICAgcmV0dXJuIG5vZGU7CiAgfSwKCiAgZmlyc3RfdGFnOiBmdW5jdGlvbiAoZWxlbWVudCwgdGFnKSB7CiAgICB2YXIgbm9kZTsKCiAgICBpZiAoIXRoaXMuaXNfeGh0bWwpCiAgICAgIHRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpOwoKICAgIGZvciAobm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpCiAgICB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5ub2RlTmFtZSA9PSB0YWcpCiAgICAgICAgYnJlYWs7CiAgICB9CgogICAgcmV0dXJuIG5vZGU7CiAgfSwKCiAgaGlkZV9zZWxlY3Rpb246IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSAvLyBGaXJlZm94LCBDaHJvbWl1bSwgU2FmYXJpLCBPcGVyYQogICAgewogICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpOwoKICAgICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkKICAgICAgewogICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApOwogICAgICAgIHJhbmdlLmNvbGxhcHNlIChmYWxzZSk7CiAgICAgIH0KICAgIH0KICAgIGVsc2UgLy8gSW50ZXJuZXQgRXhwbG9yZXIKICAgIHsKICAgICAgdmFyIHRleHRSYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSAoKTsKICAgICAgdGV4dFJhbmdlLmNvbGxhcHNlIChmYWxzZSk7CiAgICB9CiAgfSwKCiAgZ2V0X3NlbGVjdGVkX3RleHQ6IGZ1bmN0aW9uICgpIHsKICAgIHRyeQogICAgewogICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikKICAgICAgICByZXR1cm4gd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7CgogICAgICBpZiAoZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKQogICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpOwoKICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikKICAgICAgICByZXR1cm4gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkudGV4dDsKICAgIH0KICAgIGNhdGNoIChlKQogICAgewogICAgfQoKICAgIHJldHVybiAiIjsKICB9LAoKICAvLyBtYWtlIG5vdGUgb2YgbGVuZ3RoIG9mIHNlbGVjdGVkIHRleHQKICAvLyBhcyB0aGlzIGV2YWx1YXRlcyB0byB6ZXJvIGluIGNsaWNrIGV2ZW50CiAgbW91c2VfYnV0dG9uX3VwOiBmdW5jdGlvbiAoZSkgewogICAgdzNjX3NsaWR5LnNlbGVjdGVkX3RleHRfbGVuID0gdzNjX3NsaWR5LmdldF9zZWxlY3RlZF90ZXh0KCkubGVuZ3RoOwogIH0sCgogIG1vdXNlX2J1dHRvbl9kb3duOiBmdW5jdGlvbiAoZSkgewogICAgdzNjX3NsaWR5LnNlbGVjdGVkX3RleHRfbGVuID0gdzNjX3NsaWR5LmdldF9zZWxlY3RlZF90ZXh0KCkubGVuZ3RoOwogICAgdzNjX3NsaWR5Lm1vdXNlX3ggPSBlLmNsaWVudFg7CiAgICB3M2Nfc2xpZHkubW91c2VfeSA9IGUuY2xpZW50WTsKICB9LAoKICAvLyByaWdodCBtb3VzZSBidXR0b24gY2xpY2sgaXMgcmVzZXJ2ZWQgZm9yIGNvbnRleHQgbWVudXMKICAvLyBpdCBpcyBtb3JlIHJlbGlhYmxlIHRvIGRldGVjdCByaWdodGNsaWNrIHRoYW4gbGVmdGNsaWNrCiAgbW91c2VfYnV0dG9uX2NsaWNrOiBmdW5jdGlvbiAoZSkgewogICAgaWYgKCFlKQogICAgICB2YXIgZSA9IHdpbmRvdy5ldmVudDsKCiAgICBpZiAoTWF0aC5hYnMoZS5jbGllbnRYIC13M2Nfc2xpZHkubW91c2VfeCkgKwogICAgICAgIE1hdGguYWJzKGUuY2xpZW50WSAtdzNjX3NsaWR5Lm1vdXNlX3kpID4gMTApCiAgICAgIHJldHVybiB0cnVlOwoKICAgIGlmICh3M2Nfc2xpZHkuc2VsZWN0ZWRfdGV4dF9sZW4gPiAwKQogICAgICByZXR1cm4gdHJ1ZTsKCiAgICB2YXIgcmlnaHRjbGljayA9IGZhbHNlOwogICAgdmFyIGxlZnRjbGljayA9IGZhbHNlOwogICAgdmFyIG1pZGRsZWNsaWNrID0gZmFsc2U7CiAgICB2YXIgdGFyZ2V0OwoKICAgIGlmICghZSkKICAgICAgdmFyIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgaWYgKGUudGFyZ2V0KQogICAgICB0YXJnZXQgPSBlLnRhcmdldDsKICAgIGVsc2UgaWYgKGUuc3JjRWxlbWVudCkKICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgIC8vIHdvcmsgYXJvdW5kIFNhZmFyaSBidWcKICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMykKICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7CgogICAgaWYgKGUud2hpY2gpIC8vIGFsbCBicm93c2VycyBleGNlcHQgSUUKICAgIHsKICAgICAgbGVmdGNsaWNrID0gKGUud2hpY2ggPT0gMSk7CiAgICAgIG1pZGRsZWNsaWNrID0gKGUud2hpY2ggPT0gMik7CiAgICAgIHJpZ2h0Y2xpY2sgPSAoZS53aGljaCA9PSAzKTsKICAgIH0KICAgIGVsc2UgaWYgKGUuYnV0dG9uKQogICAgewogICAgICAvLyBLb25xdWVyb3IgZ2l2ZXMgMSBmb3IgbGVmdCwgNCBmb3IgbWlkZGxlCiAgICAgIC8vIElFNiBnaXZlcyAwIGZvciBsZWZ0IGFuZCBub3QgMSBhcyBJIGV4cGVjdGVkCgogICAgICBpZiAoZS5idXR0b24gPT0gNCkKICAgICAgICBtaWRkbGVjbGljayA9IHRydWU7CgogICAgICAvLyBhbGwgYnJvd3NlcnMgYWdyZWUgb24gMiBmb3IgcmlnaHQgYnV0dG9uCiAgICAgIHJpZ2h0Y2xpY2sgPSAoZS5idXR0b24gPT0gMik7CiAgICB9CiAgICBlbHNlCiAgICAgIGxlZnRjbGljayA9IHRydWU7CgogICAgaWYgKHczY19zbGlkeS5zZWxlY3RlZF90ZXh0X2xlbiA+IDApCiAgICB7CiAgICAgIHczY19zbGlkeS5zdG9wX3Byb3BhZ2F0aW9uKGUpOwogICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIC8vIGRpc21pc3MgdGFibGUgb2YgY29udGVudHMKICAgIHczY19zbGlkeS5oaWRlX3RhYmxlX29mX2NvbnRlbnRzKGZhbHNlKTsKCiAgICAvLyBjaGVjayBpZiB0YXJnZXQgaXMgc29tZXRoaW5nIHRoYXQgcHJvYmFibHkgd2FudCdzIGNsaWNrcwogICAgLy8gZS5nLiBhLCBlbWJlZCwgb2JqZWN0LCBpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCwgb3B0aW9uCiAgICB2YXIgdGFnID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7CgogICAgaWYgKHczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkICYmIGxlZnRjbGljayAmJgogICAgICAgICF3M2Nfc2xpZHkuc3BlY2lhbF9lbGVtZW50KHRhcmdldCkgJiYKICAgICAgICAhdGFyZ2V0Lm9uY2xpY2spCiAgICB7CiAgICAgIHczY19zbGlkeS5uZXh0X3NsaWRlKHRydWUpOwogICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKICAgICAgZS5jYW5jZWwgPSB0cnVlOwogICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KCiAgICByZXR1cm4gdHJ1ZTsKICB9LAoKICBzcGVjaWFsX2VsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7CiAgICBpZiAodGhpcy5oYXNfY2xhc3MoZWxlbWVudCwgIm5vbi1pbnRlcmFjdGl2ZSIpKQogICAgICByZXR1cm4gZmFsc2U7CgogICAgdmFyIHRhZyA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsKCiAgICByZXR1cm4gZWxlbWVudC5vbmtleWRvd24gfHwKICAgICAgZWxlbWVudC5vbmNsaWNrIHx8CiAgICAgIHRhZyA9PSAiYSIgfHwKICAgICAgdGFnID09ICJlbWJlZCIgfHwKICAgICAgdGFnID09ICJvYmplY3QiIHx8CiAgICAgIHRhZyA9PSAidmlkZW8iIHx8CiAgICAgIHRhZyA9PSAiYXVkaW8iIHx8CiAgICAgIHRhZyA9PSAic3ZnIiB8fAogICAgICB0YWcgPT0gImNhbnZhcyIgfHwKICAgICAgdGFnID09ICJpbnB1dCIgfHwKICAgICAgdGFnID09ICJ0ZXh0YXJlYSIgfHwKICAgICAgdGFnID09ICJzZWxlY3QiIHx8CiAgICAgIHRhZyA9PSAib3B0aW9uIjsKICB9LAoKICBzbGlkeV9jaHJvbWU6IGZ1bmN0aW9uIChlbCkgewogICAgd2hpbGUgKGVsKQogICAgewogICAgICBpZiAoZWwgPT0gdzNjX3NsaWR5LnRvYyB8fAogICAgICAgICAgZWwgPT0gdzNjX3NsaWR5LnRvb2xiYXIgfHwKICAgICAgICAgIHczY19zbGlkeS5oYXNfY2xhc3MoZWwsICJvdXRsaW5lIikpCiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgICBlbCA9IGVsLnBhcmVudE5vZGU7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIGdldF9rZXk6IGZ1bmN0aW9uIChlKQogIHsKICAgIHZhciBrZXk7CgogICAgLy8ga2x1ZGdlIGFyb3VuZCBOUy9JRSBkaWZmZXJlbmNlcyAKICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9ICJ1bmRlZmluZWQiKQogICAgICBrZXkgPSB3aW5kb3cuZXZlbnQua2V5Q29kZTsKICAgIGVsc2UgaWYgKGUud2hpY2gpCiAgICAgIGtleSA9IGUud2hpY2g7CgogICAgcmV0dXJuIGtleTsKICB9LAoKICBnZXRfdGFyZ2V0OiBmdW5jdGlvbiAoZSkgewogICAgdmFyIHRhcmdldDsKCiAgICBpZiAoIWUpCiAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgaWYgKGUudGFyZ2V0KQogICAgICB0YXJnZXQgPSBlLnRhcmdldDsKICAgIGVsc2UgaWYgKGUuc3JjRWxlbWVudCkKICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgIGlmICh0YXJnZXQubm9kZVR5cGUgIT0gMSkKICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7CgogICAgcmV0dXJuIHRhcmdldDsKICB9LAoKICAvLyBkb2VzIGRpc3BsYXkgcHJvcGVydHkgcHJvdmlkZSBjb3JyZWN0IGRlZmF1bHRzPwogIGlzX2Jsb2NrOiBmdW5jdGlvbiAoZWxlbSkgewogICAgdmFyIHRhZyA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsKCiAgICByZXR1cm4gdGFnID09ICJvbCIgfHwgdGFnID09ICJ1bCIgfHwgdGFnID09ICJwIiB8fCB0YWcgPT0gImRsIiB8fAogICAgICAgICAgIHRhZyA9PSAibGkiIHx8IHRhZyA9PSAidGFibGUiIHx8IHRhZyA9PSAicHJlIiB8fAogICAgICAgICAgIHRhZyA9PSAiaDEiIHx8IHRhZyA9PSAiaDIiIHx8IHRhZyA9PSAiaDMiIHx8CiAgICAgICAgICAgdGFnID09ICJoNCIgfHwgdGFnID09ICJoNSIgfHwgdGFnID09ICJoNiIgfHwKICAgICAgICAgICB0YWcgPT0gImJsb2NrcXVvdGUiIHx8IHRhZyA9PSAiYWRkcmVzcyI7IAogIH0sCgogIGFkZF9saXN0ZW5lcjogZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7CiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpCiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgZmFsc2UpOwogICAgZWxzZQogICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCJvbiIrZXZlbnQsIGhhbmRsZXIpOwogIH0sCgogIC8vIHVzZWQgdG8gcHJldmVudCBldmVudCBwcm9wYWdhdGlvbiBmcm9tIGZpZWxkIGNvbnRyb2xzCiAgc3RvcF9wcm9wYWdhdGlvbjogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICBldmVudCA9IGV2ZW50ID8gZXZlbnQgOiB3aW5kb3cuZXZlbnQ7CiAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlOyAgLy8gZm9yIElFCgogICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikKICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgY2FuY2VsOiBmdW5jdGlvbiAoZXZlbnQpIHsKICAgIGlmIChldmVudCkKICAgIHsKICAgICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7CiAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlOwoKICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KQogICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7CiAgICB9CgogICAgdzNjX3NsaWR5LmtleV93YW50ZWQgPSBmYWxzZTsKICAgIHJldHVybiBmYWxzZTsKICB9LAoKLy8gZm9yIGVhY2ggbGFuZ3VhZ2UgZGVmaW5lIGFuIGFzc29jaWF0aXZlIGFycmF5Ci8vIGFuZCBhbHNvIHRoZSBoZWxwIHRleHQgd2hpY2ggaXMgbG9uZ2VyCgogIHN0cmluZ3NfZXM6IHsKICAgICJzbGlkZSI6InDDoWcuIiwKICAgICJoZWxwPyI6IkF5dWRhIiwKICAgICJjb250ZW50cz8iOiLDjW5kaWNlIiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6InRhYmxhIGRlIGNvbnRlbmlkb3MiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiVGFibGEgZGUgQ29udGVuaWRvcyIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJSZWluaWNpYXIgcHJlc2VudGFjacOzbiIsCiAgICAicmVzdGFydD8iOiJJbmljaW8iCiAgfSwKICBoZWxwX2VzOgogICAgIlV0aWxpY2UgZWwgcmF0w7NuLCBiYXJyYSBlc3BhY2lhZG9yYSwgdGVjbGFzIEl6ZGEvRGNoYSwgIiArCiAgICAibyBSZSBww6FnIHkgQXYgcMOhZy4gVXNlIFMgeSBCIHBhcmEgY2FtYmlhciBlbCB0YW1hw7FvIGRlIGZ1ZW50ZS4iLAoKICBzdHJpbmdzX2NhOiB7CiAgICAic2xpZGUiOiJww6BnLi4iLAogICAgImhlbHA/IjoiQWp1ZGEiLAogICAgImNvbnRlbnRzPyI6IsONbmRleCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJ0YXVsYSBkZSBjb250aW5ndXRzIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlRhdWxhIGRlIENvbnRpbmd1dHMiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUmVpbmljaWFyIHByZXNlbnRhY2nDsyIsCiAgICAicmVzdGFydD8iOiJJbmljaSIKICB9LAogIGhlbHBfY2E6CiAgICAiVXRpbGl0emkgZWwgcmF0b2zDrSwgYmFycmEgZXNwYWlhZG9yYSwgdGVjbGVzIEVzcS4vRHRhLiAiICsKICAgICJvIFJlIHDDoGcgeSBBdiBww6BnLiBVc2kgUyBpIEIgcGVyIGNhbnZpYXIgZ3JhbmTDoHJpYSBkZSBmb250LiIsCgogIHN0cmluZ3NfY3M6IHsKICAgICJzbGlkZSI6InNuw61tZWsiLAogICAgImhlbHA/IjoibsOhcG92xJtkYSIsCiAgICAiY29udGVudHM/Ijoib2JzYWgiLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoib2JzYWggcHJlemVudGFjZSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJPYnNhaCBwcmV6ZW50YWNlIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6Inpub3Z1IHNwdXN0aXQgcHJlemVudGFjaSIsCiAgICAicmVzdGFydD8iOiJyZXN0YXJ0IgogIH0sCiAgaGVscF9jczoKICAgICJQcmV6ZW50YWNpIG3Fr8W+ZXRlIHByb2Now6F6ZXQgcG9tb2PDrSBrbGlrbnV0w60gbXnFoWksIG1lemVybsOta3UsICIgKwogICAgIsWhaXBlayB2bGV2byBhIHZwcmF2byBuZWJvIGtsw6F2ZXMgUGFnZVVwIGEgUGFnZURvd24uIFDDrXNtbyBzZSAiICsKICAgICJkw6EgenbEm3TFoWl0IGEgem1lbsWhaXQgcG9tb2PDrSBrbMOhdmVzIEIgYSBTLiIsCgogIHN0cmluZ3Nfbmw6IHsKICAgICJzbGlkZSI6InBhZ2luYSIsCiAgICAiaGVscD8iOiJIZWxwPyIsCiAgICAiY29udGVudHM/IjoiSW5ob3VkPyIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJpbmhvdWRzb3BnYXZlIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IkluaG91ZHNvcGdhdmUiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiaGVyc3RhcnQgcHJlc2VudGF0aWUiLAogICAgInJlc3RhcnQ/IjoiSGVyc3RhcnQ/IgogIH0sCiAgaGVscF9ubDoKICAgICAiTmF2aWdlZXIgZC5tLnYuIGhldCBtdWlzLCBzcGF0aWViYXIsIExpbmtzL1JlY2h0cyB0b2V0c2VuLCAiICsKICAgICAib2YgUGdVcCBlbiBQZ0RuLiBHZWJydWlrIFMgZW4gQiBvbSBkZSBrYXJha3Rlcmdyb290dGUgdGUgdmVyYW5kZXJlbi4iLAoKICBzdHJpbmdzX2RlOiB7CiAgICAic2xpZGUiOiJTZWl0ZSIsCiAgICAiaGVscD8iOiJIaWxmZSIsCiAgICAiY29udGVudHM/Ijoiw5xiZXJzaWNodCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJJbmhhbHRzdmVyemVpY2huaXMiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiSW5oYWx0c3ZlcnplaWNobmlzIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IlByw6RzZW50YXRpb24gbmV1IHN0YXJ0ZW4iLAogICAgInJlc3RhcnQ/IjoiTmV1c3RhcnQiCiAgfSwKICBoZWxwX2RlOgogICAgIkJlbnV0emVuIFNpZSBkaWUgTWF1cywgTGVlcnNjaGxhZywgZGllIEN1cnNvcnRhc3RlbiBsaW5rcy9yZWNodHMgb2RlciAiICsKICAgICJQYWdlIHVwL1BhZ2UgRG93biB6dW0gV2VjaHNlbG4gZGVyIFNlaXRlbiB1bmQgUyB1bmQgQiBmw7xyIGRpZSBTY2hyaWZ0Z3LDtnNzZS4iLAoKICBzdHJpbmdzX3BsOiB7CiAgICAic2xpZGUiOiJzbGFqZCIsCiAgICAiaGVscD8iOiJwb21vYz8iLAogICAgImNvbnRlbnRzPyI6InNwaXMgdHJlxZtjaT8iLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoic3BpcyB0cmXFm2NpIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlNwaXMgVHJlxZtjaSIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJSZXN0YXJ0dWogcHJlemVudGFjasSZIiwKICAgICJyZXN0YXJ0PyI6InJlc3RhcnQ/IgogIH0sCiAgaGVscF9wbDoKICAgICJabWllbmlhaiBzbGFqZHkga2xpa2FqxIVjIG15c3rEhSwgbmFjaXNrYWrEhWMgc3BhY2rEmSwgc3RyemHFgmtpIGxld28vcHJhd28iICsKICAgICJsdWIgUGdVcCAvIFBnRG4uIFXFvHlqIGtsYXdpc3p5IFMgaSBCLCBhYnkgem1pZW5pxIcgcm96bWlhciBjemN6aW9ua2kuIiwKCiAgc3RyaW5nc19mcjogewogICAgInNsaWRlIjoicGFnZSIsCiAgICAiaGVscD8iOiJBaWRlIiwKICAgICJjb250ZW50cz8iOiJJbmRleCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJ0YWJsZSBkZXMgbWF0acOocmVzIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlRhYmxlIGRlcyBtYXRpw6hyZXMiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUmVjb21tZW5jZXIgbCdleHBvc8OpIiwKICAgICJyZXN0YXJ0PyI6IkTDqWJ1dCIKICB9LAogIGhlbHBfZnI6CiAgICAiTmF2aWd1ZXogYXZlYyBsYSBzb3VyaXMsIGxhIGJhcnJlIGQnZXNwYWNlLCBsZXMgZmzDqGNoZXMgIiArCiAgICAiZ2F1Y2hlL2Ryb2l0ZSBvdSBsZXMgdG91Y2hlcyBQZyBVcCwgUGcgRG4uIFV0aWxpc2V6ICIgKwogICAgImxlcyB0b3VjaGVzIFMgZXQgQiBwb3VyIG1vZGlmaWVyIGxhIHRhaWxsZSBkZSBsYSBwb2xpY2UuIiwKCiAgc3RyaW5nc19odTogewogICAgInNsaWRlIjoib2xkYWwiLAogICAgImhlbHA/Ijoic2Vnw610c8OpZyIsCiAgICAiY29udGVudHM/IjoidGFydGFsb20iLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoidGFydGFsb21qZWd5esOpayIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJUYXJ0YWxvbWplZ3l6w6lrIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6ImJlbXV0YXTDsyDDumpyYWluZMOtdMOhc2EiLAogICAgInJlc3RhcnQ/Ijoiw7pqcmFpbmTDrXTDoXMiCiAgfSwKICBoZWxwX2h1OgogICAgIkF6IG9sZGFsYWsga8O2enRpIGzDqXBrZWTDqXNoZXoga2F0dGludHNvbiBheiBlZ8OpcnJlbCwgdmFneSAiICsKICAgICJoYXN6bsOhbGphIGEgc3rDs2vDtnosIGEgYmFsLCB2YWd5IGEgam9iYiBuecOtbCwgaWxsZXR2ZSBhIFBhZ2UgRG93biwgIiArCiAgICAiUGFnZSBVcCBiaWxsZW50ecWxa2V0LiBBeiBTIMOpcyBhIEIgYmlsbGVudHnFsWtrZWwgdsOhbHRvenRhdGhhdGphICIgKwogICAgImEgc3rDtnZlZyBtw6lyZXTDqXQuIiwKCiAgc3RyaW5nc19pdDogewogICAgInNsaWRlIjoicGFnLiIsCiAgICAiaGVscD8iOiJBaXV0byIsCiAgICAiY29udGVudHM/IjoiSW5kaWNlIiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6ImluZGljZSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJJbmRpY2UiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUmljb21pbmNpYXJlIGxhIHByZXNlbnRhemlvbmUiLAogICAgInJlc3RhcnQ/IjoiSW5pemlvIgogIH0sCiAgaGVscF9pdDoKICAgICJOYXZpZ2FyZSBjb24gbW91c2UsIGJhcnJhIHNwYXppbywgZnJlY2NlIHNpbmlzdHJhL2Rlc3RyYSBvICIgKwogICAgIlBnVXAgZSBQZ0RuLiBVc2FyZSBTIGUgQiBwZXIgY2FtYmlhcmUgbGEgZGltZW5zaW9uZSBkZWkgY2FyYXR0ZXJpLiIsCgogIHN0cmluZ3NfZWw6IHsKICAgICJzbGlkZSI6Is+DzrXOu86vzrTOsSIsCiAgICAiaGVscD8iOiLOss6/zq7OuM61zrnOsTsiLAogICAgImNvbnRlbnRzPyI6Is+AzrXPgc65zrXPh8+MzrzOtc69zrE7IiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6Is+Azq/Ovc6xzrrOsc+CIM+AzrXPgc65zrXPh86/zrzOrc69z4nOvSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiLOoM6vzr3Osc66zrHPgiDOoM61z4HOuc61z4fOv868zq3Ovc+Jzr0iLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoizrXPgM6xzr3Otc66zrrOr869zrfPg863IM+AzrHPgc6/z4XPg86vzrHPg863z4IiLAogICAgInJlc3RhcnQ/IjoizrXPgM6xzr3Otc66zrrOr869zrfPg863OyIKICB9LAogIGhlbHBfZWw6CiAgICAizqDOu86/zrfOs863zrjOtc6vz4TOtSDOvM61IM+Ezr8gzrrOu86vzrogz4TOv8+FIM+Azr/Ovc+EzrnOus65zr/PjSwgz4TOvyBzcGFjZSwgz4TOsSDOss6tzrvOtyDOsc+BzrnPg8+EzrXPgc6sL860zrXOvs65zqwsICIgKwogICAgIs6uIFBhZ2UgVXAgzrrOsc65IFBhZ2UgRG93bi4gzqfPgc63z4POuc68zr/PgM6/zrnOrs+Dz4TOtSDPhM6xIM+AzrvOrs66z4TPgc6xIFMgzrrOsc65IEIgzrPOuc6xIM69zrEgzrHOu867zqzOvs61z4TOtSAiICsKICAgICLPhM6/IM68zq3Os861zrjOv8+CIM+EzrfPgiDOs8+BzrHOvM68zrHPhM6/z4POtc65z4HOrM+CLiIsCgogIHN0cmluZ3NfamE6IHsKICAgICJzbGlkZSI6IuOCueODqeOCpOODiSIsCiAgICAiaGVscD8iOiLjg5jjg6vjg5ciLAogICAgImNvbnRlbnRzPyI6IuebruasoSIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiLnm67mrKHjgpLooajnpLoiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoi55uu5qyhIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IuacgOWIneOBi+OCieWGjeeUnyIsCiAgICAicmVzdGFydD8iOiLmnIDliJ3jgYvjgokiCiAgfSwKICBoZWxwX2phOgogICAgICLjg57jgqbjgrnlt6bjgq/jg6rjg4Pjgq8g44O7IOOCueODmuODvOOCuSDjg7sg5bem5Y+z44Kt44O8ICIgKwogICAgICLjgb7jgZ/jga8gUGFnZSBVcCDjg7sgUGFnZSBEb3du44Gn5pON5L2c77yMIFMg44O7IELjgafjg5Xjgqnjg7Pjg4jjgrXjgqTjgrrlpInmm7QiLAoKICBzdHJpbmdzX3poOiB7CiAgICAic2xpZGUiOiLlubvnga/niYciLAogICAgImhlbHA/Ijoi5biu5YqpPyIsCiAgICAiY29udGVudHM/Ijoi5YaF5a65PyIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiLnm67lvZUiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoi55uu5b2VIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IumHjeaWsOWQr+WKqOWxleekuiIsCiAgICAicmVzdGFydD8iOiLph43mlrDlkK/liqg/IgogIH0sCiAgaGVscF96aDoKICAgICLnlKjpvKDmoIfngrnlh7ssIOepuuagvOadoSwg5bem5Y+z566t5aS0LCBQZyBVcCDlkowgUGcgRG4g5a+86IiqLiAiICsKICAgICLnlKggUywgQiDmlLnlj5jlrZfkvZPlpKflsI8uIiwKCiAgc3RyaW5nc19ydTogewogICAgInNsaWRlIjoi0YHQu9Cw0LnQtCIsCiAgICAiaGVscD8iOiLQv9C+0LzQvtGJ0Yw/IiwKICAgICJjb250ZW50cz8iOiLRgdC+0LTQtdGA0LbQsNC90LjQtT8iLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoi0L7Qs9C70LDQstC70LXQvdC40LUiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoi0J7Qs9C70LDQstC70LXQvdC40LUiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoi0L/QtdGA0LXQt9Cw0L/Rg9GB0YLQuNGC0Ywg0L/RgNC10LfQtdC90YLQsNGG0LjRjiIsCiAgICAicmVzdGFydD8iOiLQv9C10YDQtdC30LDQv9GD0YHQuj8iCiAgfSwKICBoZWxwX3J1OgogICAgItCf0LXRgNC10LzQtdGJ0LDQudGC0LXRgdGMINC60LvQuNC60LDRjyDQvNGL0YjQutC+0LksINC40YHQv9C+0LvRjNC30YPRjyDQutC70LDQstC40YjRgyDQv9GA0L7QsdC10LssINGB0YLRgNC10LvQutC4IiArCiAgICAi0LLQu9C10LLQvi/QstC/0YDQsNCy0L4g0LjQu9C4IFBnIFVwINC4IFBnIERuLiDQmtC70LDQstC40YjQuCBTINC4IEIg0LzQtdC90Y/RjtGCINGA0LDQt9C80LXRgCDRiNGA0LjRhNGC0LAuIiwKCiAgc3RyaW5nc19zdjogewogICAgInNsaWRlIjoic2lkYSIsCiAgICAiaGVscD8iOiJoasOkbHAiLAogICAgImNvbnRlbnRzPyI6ImlubmVow6VsbCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJpbm5laMOlbGxzZsO2cnRlY2tuaW5nIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IklubmVow6VsbHNmw7ZydGVja25pbmciLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoidmlzYSBwcmVzZW50YXRpb25lbiBmcsOlbiBiw7ZyamFuIiwKICAgICJyZXN0YXJ0PyI6ImLDtnJqYSBvbSIKICB9LAogIGhlbHBfc3Y6CiAgICAiQmzDpGRkcmEgbWVkIGV0dCBrbGljayBtZWQgdsOkbnN0cmEgbXVza25hcHBlbiwgbWVsbGFuc2xhZ3N0YW5nZW50ZW4sICIgKwogICAgInbDpG5zdGVyLSBvY2ggaMO2Z2VycGlsdGFuZ2VudGVybmEgZWxsZXIgdGFuZ2VudGVybmEgUGcgVXAsIFBnIERuLiAiICsKICAgICJBbnbDpG5kIHRhbmdlbnRlcm5hIFMgb2NoIEIgZsO2ciBhdHQgw6RuZHJhIHRleHRlbnMgc3Rvcmxlay4iLAoKICBzdHJpbmdzOiB7IH0sCgogIGxvY2FsaXplOiBmdW5jdGlvbiAoc3JjKSB7CiAgICBpZiAoc3JjID09ICIiKQogICAgICByZXR1cm4gc3JjOwoKICAgICAvLyB0cnkgZnVsbCBsYW5ndWFnZSBjb2RlLCBlLmcuIGVuLVVTCiAgICAgdmFyIHMsIGxvb2t1cCA9IHczY19zbGlkeS5zdHJpbmdzW3czY19zbGlkeS5sYW5nXTsKCiAgICAgaWYgKGxvb2t1cCkKICAgICB7CiAgICAgICBzID0gbG9va3VwW3NyY107CgogICAgICAgaWYgKHMpCiAgICAgICAgcmV0dXJuIHM7CiAgICAgfQoKICAgICAvLyBzdHJpcCBjb3VudHJ5IGNvZGUgc3VmZml4LCBlLmcuCiAgICAgLy8gdHJ5IGVuIGlmIHVuZGVmaW5lZCBmb3IgZW4tVVMKICAgICB2YXIgbGcgPSB3M2Nfc2xpZHkubGFuZy5zcGxpdCgiLSIpOwoKICAgICBpZiAobGcubGVuZ3RoID4gMSkKICAgICB7CiAgICAgICBsb29rdXAgPSB3M2Nfc2xpZHkuc3RyaW5nc1tsZ1swXV07CgogICAgICAgaWYgKGxvb2t1cCkKICAgICAgIHsKICAgICAgICAgcyA9IGxvb2t1cFtzcmNdOwoKICAgICAgICAgaWYgKHMpCiAgICAgICAgICByZXR1cm4gczsKICAgICAgIH0KICAgICB9CgogICAgIC8vIG90aGVyd2lzZSBzdHJpbmcgYXMgaXMKICAgICByZXR1cm4gc3JjOwogIH0sCgogIGluaXRfbG9jYWxpemF0aW9uOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgaTE4biA9IHczY19zbGlkeTsKICAgIHZhciBoZWxwX3RleHQgPSB3M2Nfc2xpZHkuaGVscF90ZXh0OwoKICAgIC8vIGVhY2ggc3VjaCBsYW5ndWFnZSBhcnJheSBpcyBkZWNsYXJlZCBpbiB0aGUgbG9jYWxpemUgYXJyYXkKICAgIC8vIHRoaXMgaXMgdXNlZCBhcyBpbiAgdzNjX3NsaWR5LmxvY2FsaXplKCJmb28iKTsKICAgIHRoaXMuc3RyaW5ncyA9IHsKICAgICAgImVzIjp0aGlzLnN0cmluZ3NfZXMsCiAgICAgICJjYSI6dGhpcy5zdHJpbmdzX2NhLAogICAgICAiY3MiOnRoaXMuc3RyaW5nc19jcywKICAgICAgIm5sIjp0aGlzLnN0cmluZ3NfbmwsCiAgICAgICJkZSI6dGhpcy5zdHJpbmdzX2RlLAogICAgICAicGwiOnRoaXMuc3RyaW5nc19wbCwKICAgICAgImZyIjp0aGlzLnN0cmluZ3NfZnIsCiAgICAgICJodSI6dGhpcy5zdHJpbmdzX2h1LAogICAgICAiaXQiOnRoaXMuc3RyaW5nc19pdCwKICAgICAgImVsIjp0aGlzLnN0cmluZ3NfZWwsCiAgICAgICJqcCI6dGhpcy5zdHJpbmdzX2phLAogICAgICAiemgiOnRoaXMuc3RyaW5nc196aCwKICAgICAgInJ1Ijp0aGlzLnN0cmluZ3NfcnUsCiAgICAgICJzdiI6dGhpcy5zdHJpbmdzX3N2CiAgICB9LAoKICAgIGkxOG4uc3RyaW5nc19lc1toZWxwX3RleHRdID0gaTE4bi5oZWxwX2VzOwogICAgaTE4bi5zdHJpbmdzX2NhW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfY2E7CiAgICBpMThuLnN0cmluZ3NfY3NbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9jczsKICAgIGkxOG4uc3RyaW5nc19ubFtoZWxwX3RleHRdID0gaTE4bi5oZWxwX25sOwogICAgaTE4bi5zdHJpbmdzX2RlW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfZGU7CiAgICBpMThuLnN0cmluZ3NfcGxbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9wbDsKICAgIGkxOG4uc3RyaW5nc19mcltoZWxwX3RleHRdID0gaTE4bi5oZWxwX2ZyOwogICAgaTE4bi5zdHJpbmdzX2h1W2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfaHU7CiAgICBpMThuLnN0cmluZ3NfaXRbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9pdDsKICAgIGkxOG4uc3RyaW5nc19lbFtoZWxwX3RleHRdID0gaTE4bi5oZWxwX2VsOwogICAgaTE4bi5zdHJpbmdzX2phW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfamE7CiAgICBpMThuLnN0cmluZ3NfemhbaGVscF90ZXh0XSA9IGkxOG4uaGVscF96aDsKICAgIGkxOG4uc3RyaW5nc19ydVtoZWxwX3RleHRdID0gaTE4bi5oZWxwX3J1OwogICAgaTE4bi5zdHJpbmdzX3N2W2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfc3Y7CgogICAgdzNjX3NsaWR5LmxhbmcgPSBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCJsYW5nIik7CgogICAgaWYgKCF3M2Nfc2xpZHkubGFuZykKICAgICAgdzNjX3NsaWR5LmxhbmcgPSBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCJ4bWw6bGFuZyIpOwoKICAgIGlmICghdzNjX3NsaWR5LmxhbmcpCiAgICAgIHczY19zbGlkeS5sYW5nID0gImVuIjsKICB9Cn07CgovLyBoYWNrIGZvciBiYWNrIGJ1dHRvbiBiZWhhdmlvcgppZiAodzNjX3NsaWR5LmllNiB8fCB3M2Nfc2xpZHkuaWU3KQp7CiAgZG9jdW1lbnQud3JpdGUoIjxpZnJhbWUgaWQ9J2hpc3RvcnlGcmFtZScgIiArCiAgInNyYz0namF2YXNjcmlwdDpcIjxodG1sIisiPjwvIisiaHRtbD5cIicgIiArCiAgImhlaWdodD0nMScgd2lkdGg9JzEnICIgKwogICJzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7bGVmdDotODAwcHgnPjwvaWZyYW1lPiIpOwp9CgovLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIGZvciBpbml0aWFsaXphdGlvbgp3M2Nfc2xpZHkuc2V0X3VwKCk7CgovLyBoaWRlIHRoZSBzbGlkZXMgYXMgc29vbiBhcyBib2R5IGVsZW1lbnQgaXMgYXZhaWxhYmxlCi8vIHRvIHJlZHVjZSBhbm5veWluZyBzY3JlZW4gbWVzcyBiZWZvcmUgdGhlIG9ubG9hZCBldmVudApzZXRUaW1lb3V0KHczY19zbGlkeS5oaWRlX3NsaWRlcywgNTApOwoK"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">The dplyr package</h1>
  <h1 class="subtitle">Data analysis and visualization using R 2</h1>
  <p class="author">
Michiel Noback
  </p>
  <p class="date">April 2020</p>
</div>
<div id="data-mangling-with-package-dplyr" class="title-slide slide section level1"><h1>Data mangling with package <code>dplyr</code></h1></div><div id="intro" class="slide section level2">
<h1>Intro</h1>
<p>This package can be used for a wide range of activities such as:</p>
<ul>
<li>summarizing data; e.g.counting, ranking,</li>
<li>selecting, filtering and sampling cases</li>
<li>manipulating data; creating new or changing existing variables</li>
<li>combining tables</li>
</ul>
<p>There is an excellent cheat sheet for this package: <a href="https://rstudio.com/resources/cheatsheets/">https://rstudio.com/resources/cheatsheets/</a>.</p>
</div><div id="terminology" class="slide section level2">
<h1>Terminology</h1>
<ul>
<li>The <strong>row</strong> of a dataframe represents a <strong><em>case</em></strong> or <strong><em>example</em></strong> with one or more <strong><em>measurements</em></strong></li>
<li>The <strong>column</strong> represents a <strong><em>variable</em></strong>: all measurements of a single <strong><em>property</em></strong></li>
</ul>
</div>
<div id="tibbles" class="title-slide slide section level1"><h1>Tibbles</h1></div><div id="what-are-tibbles" class="slide section level2">
<h1>What are tibbles?</h1>
<ul>
<li>Tibbles are a modern take on data frames. They keep the good, and drop the ugly (i.e.converting character vectors to factors).</li>
<li>The package <code>tibble</code> holds all functionality revolving around tibbles.</li>
<li>You usually do not have to load the package because dplyr and tidyr do that already.</li>
</ul>
</div><div id="creating-tibbles" class="slide section level2">
<h1>Creating tibbles</h1>
<ul>
<li><strong>Literal</strong>: Use the <code>tibble()</code> constructor to create them as literals.</li>
<li><strong>Coercion</strong>: Use the <code>as_tibble()</code> function to coerce objects into tibbles.</li>
</ul>
</div><div id="advantages" class="slide section level2">
<h1>Advantages</h1>
<ul>
<li><p>There are several advantages over the old <code>data.frame</code> constructor:</p>
<ul>
<li>It never changes an inputs type (i.e., no more <code>stringsAsFactors = FALSE</code>!).</li>
<li>It never adjusts the names of variables.</li>
<li>It evaluates its arguments lazily and sequentially:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">y =</span> x <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)</a></code></pre></div>
<pre><code>## # A tibble: 5 x 2
##       x     y
##   &lt;int&gt; &lt;dbl&gt;
## 1     1     1
## 2     2     4
## 3     3     9
## 4     4    16
## 5     5    25</code></pre>
<ul>
<li>It never uses <code>row.names()</code>.</li>
</ul></li>
</ul>
</div><div id="by-row-constructor" class="slide section level2">
<h1>By-row constructor</h1>
<ul>
<li>There is a third function, <code>tribble()</code> that you can use to define a table in an alternative way: row-wise.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">tribble</span>(</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="op">~</span>colA, <span class="op">~</span>colB,</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="st">&quot;a&quot;</span>,   <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="st">&quot;b&quot;</span>,   <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="st">&quot;c&quot;</span>,   <span class="dv">3</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">)</a></code></pre></div>
<pre><code>## # A tibble: 3 x 2
##   colA   colB
##   &lt;chr&gt; &lt;dbl&gt;
## 1 a         1
## 2 b         2
## 3 c         3</code></pre>
</div><div id="tibbles-vs-data-frames" class="slide section level2">
<h1>Tibbles vs data frames</h1>
<p>There are three key differences between tibbles and data frames: printing, subsetting, and recycling rules.</p>
<p><strong>Printing</strong></p>
<ul>
<li>Printing only shows the first ten rows and the columns that fit on one screen.<br />
</li>
<li>It also prints an abbreviated description of the column type, and uses font styles and color for highlighting.<br />
</li>
<li><p>You can control the default appearance with options:</p>
<ul>
<li><code>options(tibble.print_max = n, tibble.print_min = m)</code>. Use <code>options(tibble.print_max = Inf)</code> to always show all rows.<br />
</li>
<li><code>options(tibble.width = Inf)</code> will always print all columns, regardless of the width of the screen.</li>
</ul></li>
<li><p>To print all rows occasionaly, use <code>print(the_tibble, n = Inf)</code>.</p></li>
</ul>
</div><div class="slide section level2">

<p><strong>Subsetting</strong></p>
<ul>
<li>Tibbles are quite strict about subsetting.</li>
<li><code>[</code> always returns another tibble. Contrast this with a data frame: sometimes <code>[</code> returns a data frame and sometimes it just returns a vector.</li>
</ul>
<p><strong>Recycling</strong></p>
<ul>
<li>When constructing a tibble, only values of length 1 are recycled.</li>
<li>The first column with length other than one determines the number of rows in the tibble</li>
<li>Conflicts lead to an error. This also extends to tibbles with zero rows, which is sometimes important for programming.</li>
</ul>
</div><div id="the-str-equivalent-glimpse" class="slide section level2">
<h1>The <code>str()</code> equivalent: <code>glimpse()</code></h1>
<p>The <code>glimpse()</code> function is the dplyr equivalent of <code>str()</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">glimpse</span>(dose_response_long)</a></code></pre></div>
<pre><code>## Observations: 52
## Variables: 4
## $ patient  &lt;chr&gt; &quot;001&quot;, &quot;002&quot;, &quot;003&quot;, &quot;004&quot;, &quot;005&quot;, &quot;006&quot;, &quot;007&quot;, &quot;008&quot;,
## $ sex      &lt;fct&gt; f, f, m, m, f, f, f, m, f, m, m, m, m, f, m, f, f, m, m
## $ Dose     &lt;chr&gt; &quot;dose10mg&quot;, &quot;dose10mg&quot;, &quot;dose10mg&quot;, &quot;dose10mg&quot;, &quot;dose10
## $ Response &lt;int&gt; 12, 11, 54, 71, 19, 22, 23, 68, 30, 83, 72, 48, 67, 13,</code></pre>
</div>
<div id="the-chaining-operator" class="title-slide slide section level1"><h1>The chaining operator <code>%&gt;%</code></h1></div><div id="effecient-workflows-through-chaining" class="slide section level2">
<h1>Effecient workflows through chaining</h1>
<ul>
<li>In any workflow, it happens all the time that you apply some function to a dataframe, store the result in a new variable (or overwrite the first) and apply a second function to this dataframe. And so on.<br />
</li>
<li>There are two undesirable results with this.
<ul>
<li>The first is cluttered code: many variables; how are you going to name them?<br />
</li>
<li>The second is cluttering of the environment and memory footprint.</li>
</ul></li>
<li>The chaining operator helps you create clean workflows where intermediate results are only stored when opportune.</li>
</ul>
</div><div id="chaining-defined" class="slide section level2">
<h1>Chaining defined</h1>
<p>It comes down to this simple notion:</p>
<blockquote>
<p><strong><code>x %&gt;% f(y))</code></strong> is equivalent to <strong><code>f(x, y)</code></strong> where <strong><code>f</code></strong> is any function.</p>
</blockquote>
</div><div id="example" class="slide section level2">
<h1>Example</h1>
<p>Here is the good old dose-response example again, converted to a tibble.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">dose_response_long</a></code></pre></div>
<pre><code>## # A tibble: 52 x 4
##    patient sex   Dose     Response
##    &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;       &lt;int&gt;
##  1 001     f     dose10mg       12
##  2 002     f     dose10mg       11
##  3 003     m     dose10mg       54
##  4 004     m     dose10mg       71
##  5 005     f     dose10mg       19
##  6 006     f     dose10mg       22
##  7 007     f     dose10mg       23
##  8 008     m     dose10mg       68
##  9 009     f     dose10mg       30
## 10 010     m     dose10mg       83
## #  with 42 more rows</code></pre>
</div><div class="slide section level2">

<p>Suppose I want to remove cases with missing values (there arent any - this is for the sake of argument), select the female subjects and then calculate the mean response for the two doses. In base R, you could do something like this.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">dr_long_no_na &lt;-<span class="st"> </span><span class="kw">na.omit</span>(dose_response_long)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">dr_long_no_na_only_female &lt;-<span class="st"> </span><span class="kw">subset</span>(<span class="dt">x =</span> dr_long_no_na, </a>
<a class="sourceLine" id="cb9-3" data-line-number="3">                                        <span class="dt">subset =</span> sex <span class="op">==</span><span class="st"> &quot;f&quot;</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">aggregate</span>(Response <span class="op">~</span><span class="st"> </span>Dose, </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">          <span class="dt">data =</span> dr_long_no_na_only_female, </a>
<a class="sourceLine" id="cb9-6" data-line-number="6">          <span class="dt">FUN =</span> mean)</a></code></pre></div>
<p>I know, I exaggerated a bit with the variable names.</p>
</div><div class="slide section level2">

<p>Here is the same workflow, using <code>dplyr</code>, again with the intermediate variables. It even has an explicit operation extra (<code>group_by()</code>).</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">dr_long_no_na &lt;-<span class="st"> </span><span class="kw">drop_na</span>(dose_response_long)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">dr_long_no_na_only_female &lt;-<span class="st"> </span><span class="kw">filter</span>(dr_long_no_na, </a>
<a class="sourceLine" id="cb10-3" data-line-number="3">                                    sex <span class="op">==</span><span class="st"> &quot;f&quot;</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">dr_long_no_na_only_female_grouped &lt;-<span class="st"> </span><span class="kw">group_by</span>(dr_long_no_na_only_female, </a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                                              Dose)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw">summarize</span>(dr_long_no_na_only_female_grouped, </a>
<a class="sourceLine" id="cb10-7" data-line-number="7">          <span class="dt">mean_response =</span> <span class="kw">mean</span>(Response))</a></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   Dose      mean_response
##   &lt;chr&gt;             &lt;dbl&gt;
## 1 dose100mg          80.9
## 2 dose10mg           19.6</code></pre>
</div><div class="slide section level2">

<p>And, finally, how dplyr is supposed to be used.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="st">    </span><span class="kw">drop_na</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="st">    </span><span class="kw">filter</span>(sex <span class="op">==</span><span class="st"> &quot;f&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="st">    </span><span class="kw">group_by</span>(Dose) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">mean_response =</span> <span class="kw">mean</span>(Response))</a></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   Dose      mean_response
##   &lt;chr&gt;             &lt;dbl&gt;
## 1 dose100mg          80.9
## 2 dose10mg           19.6</code></pre>
<p>If you do actually want the result stored, you only need to assign to a single variable at the beginning of the chain.</p>
</div><div class="slide section level2">

<p>For completeness sake, this the equivalent in base R without intermediate variables.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">aggregate</span>(Response <span class="op">~</span><span class="st"> </span>Dose, </a>
<a class="sourceLine" id="cb14-2" data-line-number="2">          <span class="dt">data =</span> <span class="kw">subset</span>(<span class="dt">x =</span> <span class="kw">na.omit</span>(dose_response_long), </a>
<a class="sourceLine" id="cb14-3" data-line-number="3">                        <span class="dt">subset =</span> sex <span class="op">==</span><span class="st"> &quot;f&quot;</span>), </a>
<a class="sourceLine" id="cb14-4" data-line-number="4">          <span class="dt">FUN =</span> mean)</a></code></pre></div>
</div><div id="chaining-and-ggplot2" class="slide section level2">
<h1>Chaining and <code>ggplot2</code></h1>
<p>Does it work with <code>ggplot2</code> as well?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="st">    </span><span class="kw">drop_na</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="st">    </span><span class="kw">ggplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> sex, <span class="dt">y =</span> Response)) <span class="op">+</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="st">        </span><span class="kw">geom_boxplot</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="st">        </span><span class="kw">facet_wrap</span>(Dose <span class="op">~</span><span class="st"> </span>.)</a></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABgAAAANMCAYAAACaTGbbAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N0JmBxVuTDgk2SyAAlbgCRIICIhIIgBBOIVkUUWHxSFiFxFiWx6RRBRBFF+wCCoiIjLvXoVFBQQLqDsiJdFZBMum2BYBMIiixCykIRA9t+vtNqeSWYy3dMzVFe/53kmXV1Vp+qc9/RMquurc06/pX9PSSJAgAABAgQIECBAgAABAgQIECBAgAABAgRKJdC/VLVRGQIECBAgQIAAAQIECBAgQIAAAQIECBAgQCATEADwQSBAgAABAgQIECBAgAABAgQIECBAgAABAiUUEAAoYaOqEgECBAgQIECAAAECBAgQIECAAAECBAgQEADwGSBAgAABAgQIECBAgAABAgQIECBAgAABAiUUEAAoYaOqEgECBAgQIECAAAECBAgQIECAAAECBAgQEADwGSBAgAABAgQIECBAgAABAgQIECBAgAABAiUUEAAoYaOqEgECBAgQIECAAAECBAgQIECAAAECBAgQEADwGSBAgAABAgQIECBAgAABAgQIECBAgAABAiUUEAAoYaOqEgECBAgQIECAAAECBAgQIECAAAECBAgQEADwGSBAgAABAgQIECBAgAABAgQIECBAgAABAiUUEAAoYaOqEgECBAgQIECAAAECBAgQIECAAAECBAgQEADwGSBAgAABAgQIECBAgAABAgQIECBAgAABAiUUEAAoYaOqEgECBAgQIECAAAECBAgQIECAAAECBAgQaENQPIEXX3wxvfLKK8UrmBIRIECAAAECBAgQaLDAxhtvXPcR//KXv9SdV0YCBAgQIECAAAECzSLQk2tmAYACtvKCBQvSa6+9VsCSKRIBAgQIECBAgACB4gi4Zi5OWygJAQIECBAgQIBAMQUMAVTMdlEqAgQIECBAgAABAgQIECBAgAABAgQIECDQIwEBgB7xyUyAAAECBAgQIECAAAECBAgQIECAAAECBIopIABQzHZRKgIECBAgQIAAAQIECBAgQIAAAQIECBAg0CMBAYAe8clMgAABAgQIECBAgAABAgQIECBAgAABAgSKKSAAUMx2USoCBAgQIECAAAECBAgQIECAAAECBAgQINAjAQGAHvHJTIAAAQIECBAgQIAAAQIECBAgQIAAAQIEiikgAFDMdlEqAgQIECBAgAABAgQIECBAgAABAgQIECDQIwEBgB7xyUyAAAECBAgQIECAAAECBAgQIECAAAECBIopIABQzHZRKgIECBAgQIAAAQIECBAgQIAAAQIECBAg0CMBAYAe8clMgAABAgQIECBAgAABAgQIECBAgAABAgSKKSAAUMx2USoCBAgQIECAAAECBAgQIECAAAECBAgQINAjAQGAHvHJTIAAAQIECBAgQIAAAQIECBAgQIAAAQIEiinQVsxiKRUBAgQIFF3gRz/6UXrggQfSgQcemLbddtuiF3eZ8s2bNy995StfSSNGjEjHHXfcMtvzFfPnz0+XXXZZuueee9LMmTPT2LFj09ve9ra02267pQEDBuS7tXutJ0+7A3hDgAABAgQIECBQegHX051fT5e+8VWQAAECfSggANCH2E5FgACBMgk899xz6bHHHktz5sxpumotXbo0feMb30h//vOfO72JH5V65ZVX0pFHHpmeffbZrI5rrLFG+t3vfpf93HnnnVkAYdCgQe3qX0+edgfwhgABAgQIECBAoCUEXE8v/3q6JRpfJQkQINCHAoYA6kNspyJAgACBN17gtddeS9/5znfSHXfcscLCRJAgbv5vs8026dJLL00XX3xx+sUvfpHe/OY3p1tvvTX913/91zLHqCfPMgexggABAgQIECBAgEBBBXr7erqg1VYsAgQINK2AAEDTNp2CEyBAgECtAjGMzyGHHJJ++9vfpv79u/4v8JFHHkl33313GjJkSDrxxBPTaqutlp1u3XXXTaeddlrWcyB6A1T3gKgnT611sD8BAgQIECBAgACBN0qgt6+n36h6OS8BAgTKLGAIoDK3rroRIECgQQLxlM+9996bHW3zzTev3Azv6vAvv/xymjp1anrppZfSm970prThhht2mS+G5Xn44Ycrw+1ssMEGaf31108rrbRSp6eZO3duevzxx1N0nx41alR6y1ve0uk5brjhhmzYnzhYPNH/rne9K5155pmdHvsPf/hDtm2HHXbIggDVO8ZQQO94xztSDAMUQYCJEydmm+vJE0MGxdwCa621Vho6dGiKOj344INpwYIFaYsttkhxrjzFujCK+oZpzEXQVSAjhmiKNhg8eHDadNNNs/kOZs+enWbMmJEdNw9q5Mf3SoAAAQIECBAg0DsCfXE9HdeU8UDK9OnT0zrrrJPiejrmu+oqFe16ureujaOeMX9ZXAdHb96Y1yuG8vzrX/+alixZkll15WQbAQIEmllAAKCZW0/ZCRAg0MsCMVHuKaeckk2Au2jRosrZ4in6zlI8Ef/zn/88XXXVVdnFdL5f3Kj+8Ic/nD75yU9mF9v5+nh94okn0te//vXsArx6fdz8P/zww9Puu+9evTotXrw4XXDBBemXv/zlMuf42Mc+lj7xiU8sM7Z/fCGKIMH++++fHe+2225rd8yObx566KFsVQQLlpfyAEDMI5AHAOrJEwGE//7v/05f+MIXsmBJ1Cu+hOTpgx/8YDriiCPSXXfdlSZPnpxef/31fFMaN25c1j6rr756ZV0svPrqq+n444/PAgnVG97//ven0aNHp5hwLiZvDguJAAECBAgQIECg9wT66nr6xz/+cbrssstS9TV71CquWb/0pS+l4cOHt6tkUa+ne+PaOI75wx/+MEVb5Ck8vva1r2VzekVwIPaRCBAgUFYBAYCytqx6ESBAoIcC8UT+N7/5zewp93h6f6+99korr7xyihvnZ511Vho4cOAyZ4g8cSF9//33Z18y9t577+yG89NPP52Nof8///M/6dFHH02nn3566tevX5Y/LsS/8pWvZE8q7bnnntnT+QsXLkz/93//l2688cb07W9/O3syPp7Yz9PJJ5+cjcEfN7733XffrKdAjNX/m9/8Jp133nkpzhfD9lSnHXfcMUV5BgwYUL260+Xnn38+29bZU/L5Tfd8guDYuZ48eQHCJvK/+93vTtHLIuofP5dffnn2Re66665L2267beYTvSquuOKKzDKCLUcddVR+mJRPcBy9COLppg984ANp2LBhWQAhgjJd9aioHMQCAQIECBAgQIBAjwX66no65qm65JJLsodd9ttvv+zp/+gle9NNN2VDWsa1djxwUp2Kej2dl7FR18ZTpkxJZ5xxRvaATXwXiB60cS3961//OruGrn7wJj+3VwIECJRNQACgbC2qPgQIEGiQQHyJuP3229NGG22UDZUTY+FH2nnnnVOMg/+rX/1qmTPFU0dx8z+etP/+979fGb4mbt7vtttu6bOf/Wz605/+lOJm9h577JHlj6640U05hrupvpG90047pVVXXTX7MhP75wGAeBI+JuCNoXF+8pOfVM4RB4tzHHbYYemWW27JvuzEE095iiF2akn5E0KdBQDipnqkeNo+T/XkyfNGIOFTn/pU+shHPpKtii8oESiJ+QquvvrqFF/mDj300Hz3rNty9AiIIEF1uuiii9If//jHrHdATHact1t4RlvG0/8SAQIECBAgQIBA7wv01fV03OiP9MUvfjGNHz8+W44HR+J6+4ADDsh620ZAIK4FIxX5ejor4N//acS1cTzZf9JJJ2UP05xwwgkphvbM06677pr1NH7hhRe6HFIz398rAQIEmlmg6xkQm7lmyk6AAAECPRK44447svwf//jHKzeR8wPGMDv5DfB8XbxeeeWV2dsY5qd67PpYGTfgJ02alG2Pp5TyFN2PI82aNSvFmJ/VKb6w/OxnP8uGs8nX54GHOFbHc8TN+ghQRIovXPWmeBIoH2pnefWM48Z4/ZHmz5+fvdaTJ8v4z3/WXHPNys3/fH0ERfLUcbieGNM/0rRp07IhkfL9IjgS6aCDDlqm3T70oQ+l9dZbL9/VKwECBAgQIECAQC8K9PX1dIxnX53i+jKGBopr7/zmf2wv6vV0x7LnD8bk62u9No7hOWMY0M0226zdzf84XnxvyL+b5Mf3SoAAgbIK6AFQ1pZVLwIECPRQIMbljxTdZDumGEYmLqTjSfM8xY38mJw2UvWT9/n26vWxX+wfw/HEU0qrrLJKeuaZZ7KL8O222y4b5ibG3o8L85gIuDrF8D6RYk6B6G3QMeXjm8bx6k1x7KhjTNaW3+DveKx8fUweFqmePNXHjF4VHVNM9Bsp6hTDL1WnPPgRXctjrNewDNOY9DfS8tot9okvTtXDFlUf0zIBAgQIECBAgEDjBPrqenr77bfPnvL/3ve+l/Uejevp6AGw8cYbL/fhj6JeT1fLN+LaOHo9RKoOHFSfI+8tUb3OMgECBMooIABQxlZVJwIECPRQ4MUXX8yGtolx/jsbAqfjkDoxfn3cgI4hZ7rKEzeh44Z1nCMu7OPm/5lnnpmiW250wb3hhhuyn5gj4K1vfWs298Auu+yS1Si68c6ePTtbjrE8u0rxZPyCBQuWmXC4qzzV2+Kme9woj0mNl5fy9VH+PNWTJ887YsSIfLHyms+TUH2OfGO+Ld7ny/HUV9Q55ifIAxP5/vnr8s6Tb/NKgAABAgQIECDQGIG+vJ6OHrsxFGX0gI35tuLnF7/4RXZNHvNLxfb82r3o19O5/vKuWfNr3u5eGz/22GPZ4dZee+38sO1e49o9vpvEAzUSAQIEyiwgAFDm1lU3AgQI1CkwePDgLGcMaxM/8XR7x9TW1v6/kLh4jhRBgLiIzi/Qq/PFtviJVJ0/Jqs955xz0n333ZdNOhzj2sfN95i0K36i++4RRxzR7uL8kEMOaXeM6vM0Yjm/mR9fkpaX8gBAPhlw7FNPnvzYy7th390vI/l+uWn1vAT58fPX6NUgESBAgAABAgQI9K5AX15Px3X3pz/96TRx4sTKXFjRUzaG17zqqqvSbbfdlk477bQU19z5dWPUvojX03mrNOLaOB5mipTP05UfO39duHBh9t1ked918n28EiBAoAwC7e/elKFG6kCAAAECPRaIm9rrrLNOeumll7IJepf31Ew81VSd4imdCALEhXSMtRljjnZMcbw8Vd84j3WRN4YOyocPit4AMaFtfGm54oorsgnMomdBTAwcvQC23nrrbCLc/HiNfo36R3ryySezLtQdjx/rI40bN66yqZ48lcwNWIjJl+MLTN4G+TBB1Yf+29/+Vv3WMgECBAgQIECAQC8IvBHX0/GU/9577539RK/Qe+65J+tpO3369HTNNdekz372s9k8XkW+nm5kU+TDaXZ2/dvZ+kaWwbEIECBQBIFlH+ksQqmUgQABAgTecIEYMzTSH/7wh2XKEk/RxJP51Slu4Ofj9d90003VmyrL+fq4aZ4/1ROTkMWEtRdccEFlv1iIm9nx1H98QYknlfIb7vHkUqRbbrkle+34T3y5OfDAA9O3vvWtjptqer/jjjtm++dlrs4cvSJuvvnmbNXb3/72yqZ68lQyN2Ah2iAvz7XXXrvMESMwk09Gt8xGKwgQIECAAAECBBoq0BfX0/GAzVFHHZXNpVXdczWutd/5znemfCLdfD6CqGCRr6cb2QBbbbVVdri4bl9eL4D43iARIECgFQQEAFqhldWRAAECdQjsscce2TA+cYO+ekLduBl/1llnVcbirz70pEmTsrdxMz+fjDbfHmORXnzxxdnbeDIpT8OGDcuOH0/75+P759seeeSRbF10od50002z1Z/4xCey1zjWAw88kO+avUavhB/96EcpxsJf3rih7XZewZuYOC0CGjF52HXXXddu7wsvvDDrGRHbY7LiPNWTJ8/bqNdPfvKT2aGi3aonaY4u4Keeemqnkxo36vyOQ4AAAQIECBAg8A+Bvriejp66MRfXc889l80B0NH+rrvuylZtueWWlU1Fvp6uFLIBC29729uyXsMxdOc3v/nNdkGAG2+8MV1++eUNOItDECBAoPgChgAqfhspIQECBN4QgQkTJmTjgv70pz9Nhx9+eNp5552zMe5jfP4Ykz8m8I0vG9Vp++23TzvssEPWayDyxBPx6623XnaD//e//302+e9hhx2W3vve91ayxXIM8xM32j/60Y+meFInnpaKHgb5Df54cikfR3X8+PHp/e9/f5bni1/8Yna+DTfcMMUkX3fffXd6/fXX0yabbJL222+/yjnqWYixVKNnwuTJk9O3v/3tbG6CjTbaKCvXnXfemWJM0Xjaqnqug3ry1FO2rvJsttlmWQ+In//85+n444/P2im6oIdv3ksjAjqxLBEgQIAAAQIECPSeQF9cT+fj/8eDHuedd17WSzXOO3/+/OzaOK7XY5jKXXfdtVLRIl9PVwrZoIUjjzwyffWrX02333571hviLW95S3r55ZdTPDgUDxg9/PDDrosbZO0wBAgUV0AAoLhto2QECBB4wwXiJnqMHxpP28dN+khDhw5Nxx57bHZD+dJLL12mjCeccEK68sors0l9f/e732XbY3LauCm/++67p/e9733t8gwZMiSdcsop6eyzz07XX399NkRNPkxNPMUfT7RXf2GJzJ///OdTPNETwYno0psPxxNdnaN3wQEHHJBWWmmlduep500ENOLmf0yaFkMh5cMhbbDBBtnwRFGGjqmePB2P0dP3+++/f4qgSHRr/stf/pJ9wdluu+2ywED0zogAwMorr9zT08hPgAABAgQIECCwAoG+uJ6OB3UinXvuuVlP2OgNGykeoIlhgI4++ugUc2lVpyJfT1eXs6fL8dDSD37wg8wmHjCKXsrRi3evvfZKcd0ePZhXWWWVnp5GfgIECBRaoN/fh3JYWugStmDh4j/rGTNmtGDNVZkAgaIKxFP18bcpnnqPm9/VT713VeaYcCyeromb0XGjf0XptddeyyYejm66cZ4YHmhFKYa2efbZZ7PARMwbkM8tsKJ8tW6Pv8txnuhmHYGJmGx3RamePCs6Zk+3R6+AGBroK1/5Staro6fHk58AAQI9FcjnLqnnOH/605/qySYPAQIE+lygL66n4/ZOfv0dD+2MHj26W9esRb6e7s2Gih7En/nMZ7Iey+ecc05vnsqxCRAg0GOBnlwz6wHQY34HIECAQPkF4ub92LFja67o8OHDs2GDupsxntqPG/+1pHiaqeMTTbXk7+6+a665ZoqfWlI9eWo5/vL2jR4Y0a3505/+dGVC4Hy/mCQuH1YpemRIBAgQIECAAAECfSPQF9fT8ZDOWmutlf3UUqsiX0/XUo+O+z744IPpW9/6Vtpiiy3SMccc03Fz1vs4Vo4bN26ZbVYQIECgTAIrfnyxTLVVFwIECBAgUHKB6OYcw/7EZMhPPfVUpbZPP/10Ov3007PJz2KehdhPIkCAAAECBAgQIFBWgTFjxqRp06alGJY0JvydN29eVtV4jaFHf/3rX2fj/3ccorSsHupFgEDrChgCqIBtbwigAjaKIhEgQKBJBObOnZtN2hzDFUWKXhhLlixJM2fOzN5vvvnm6Rvf+EZD5kjIDugfAgQI9FCgJ92ZDQHUQ3zZCRAgUHKBmJvse9/7XlbLGMJzvfXWy4b1jOvjeP///t//S+9+97tLrqB6BAiUQaAn18wCAAX8BAgAFLBRFIkAAQJNJBBzKcSkzTGZ8t/+9rdsYrO3vvWtKX522GEHN/+bqC0VlUArCPTky4wAQCt8QtSRAAECPRN45JFHsqf9o3dszHcQ85PFdfE222yTDIvZM1u5CRDoO4GeXDMLAPRdO3X7TAIA3aayIwECBAgQIECAQJML9OTLjABAkze+4hMgQIAAAQIECHRLoCfXzOYA6BaxnQgQIECAAAECBAgQIECAAAECBAgQIECAQHMJCAA0V3spLQECBAgQIECAAAECBAgQIECAAAECBAgQ6JaAAEC3mOxEgAABAgQIECBAgAABAgQIECBAgAABAgSaS0AAoLnaS2kJECBAgAABAgQIECBAgAABAgQIECBAgEC3BAQAusVkJwIECBAgQIAAAQIECBAgQIAAAQIECBAg0FwCAgDN1V5KS4AAAQIECBAgQIAAAQIECBAgQIAAAQIEuiUgANAtJjsRIECAAAECBAgQIECAAAECBAgQIECAAIHmEmhrruK2Rmn79++fBgwY0BqVVUsCBAgQIECAAAECdQq4Zq4TTjYCBAgQIECAAIGWERAAKGBTr7rqqmnw4MEFLJkiEeg9gfjMDxs2LDvBq6++ml577bXeO5kjEyBAoEACw4cPT/369UuLFy9OM2fOLFDJFIVA8QVGjhxZ/EIqIYEGCsT/F/H/RqSFCxemV155pYFHdygCBAgUVyDuF+T3yuKaOa6dJQIEuicgANA9pz7dK/6IxcWcRKCVBNra/vXnyO9AK7W8uhIgkAssXbrU//85hlcC3RRwzdxNKLuVRiB6i+fJ/xu5hFcCBFpBYMmSJZVqLlq0KMWPRIBA9wT+dfXQvf3tRYAAAQIECBAgQIAAAQIECBAgQIAAAQIECDSBgABAEzSSIhIgQIAAAQIECBAgQIAAAQIECBAgQIAAgVoFBABqFbM/AQIECBAgQIAAAQIECBAgQIAAAQIECBBoAgEBgCZoJEUkQIAAAQIECBAgQIAAAQIECBAgQIAAAQK1CggA1CpmfwIECBAgQIAAAQIECBAgQIAAAQIECBAg0AQCAgBN0EiKSIAAAQIECBAgQIAAAQIECBAgQIAAAQIEahUQAKhVzP4ECBAgQIAAAQIECBAgQIAAAQIECBAgQKAJBAQAmqCRFJEAAQIECBAgQIAAAQIECBAgQIAAAQIECNQqIABQq5j9CRAgQIAAAQIECBAgQIAAAQIECBAgQIBAEwgIADRBIykiAQIECBAgQIAAAQIECBAgQIAAAQIECBCoVUAAoFYx+xMgQIAAAQIECBAgQIAAAQIECBAgQIAAgSYQEABogkZSRAIECBAgQIAAAQIECBAgQIAAAQIECBAgUKuAAECtYvYnQIAAAQIECBAgQIAAAQIECBAgQIAAAQJNICAA0ASNpIgECBAgQIAAAQIECBAgQIAAAQIECBAgQKBWAQGAWsXsT4AAAQIECBAgQIAAAQIECBAgQIAAAQIEmkCgrQnKWHcR582bl44++ug0cuTIdMIJJ3R6nPnz56dLLrkk3X333WnmzJlp7Nixafz48WmPPfZIAwYMWG6+evIs90BWEiBAgAABAgQIECBAgAABAgQIECBAgACBXhAobQBg6dKlafLkyenBBx9MbW2dV3PWrFnpsMMOS3/9618z3jXXXDP99re/zX5uv/32dOKJJ6ZBgwa1o68nT7sDeEOAAAECBAgQIECAAAECBAgQIECAAAECBHpZoJRDAL322mvpW9/6VrrttttWyHfyySdnN/+32267dNVVV6XLL788XXjhhektb3lL+sMf/pC+//3vL3OMevIscxArCBAgQIAAAQIECBAgQIAAAQIECBAgQIBALwqULgAQw/gccMAB6eqrr079+3ddvYceeijdddddaaWVVkpf//rX02qrrZZRv+lNb0pnnHFGNvzPtddem+bMmVNpgnryVDJbIECAAAECBAgQIECAAAECBAgQIECAAAECfSTQ9R3yPipEo07zv//7v+moo45Kf/vb31I80f+FL3yhy0P//ve/z7a/5z3vSUOGDGm3bwwFtO2226YFCxakCALkqZ48eV6vBAgQIECAAAECBAgQIECAAAECBAgQIECgrwRKFQCYMWNGWnfdddOXv/zl9O1vfzutscYaXTpOmTIl2x7BguWlCABEeuCBByqb68lTyWyBAAECBAgQIECAAAECBAgQIECAAAECBAj0kUDns+P2UQEaeZpddtklTZw4sctJf6vP99xzz2VvV1999erVleV8fT5BcGyoJ0/lgFULhxxySIrJhJeXDjzwwLTrrrsub5N1BEorUD1k18orr7xMr5zSVlzFCBAg8E+BAQMGpOHDh/MgQKAGAb8zNWDZtXQCbW1t/t8oXauqEAECnQnE37w85UN45++9EiDQtcC/fnu63q8ptq611lo1lfPVV1/N9s9v9HfMvOqqq2ar8v3iTb5cS56Ox4330ZMgeiwsL82cOTMNGjRoeZusI9ASAtX/sbdEhVWSAAECfxfo16+f//99EgjUKOCauUYwu5dKIB6g8TtQqiZVGQIEuingb183oexG4J8CpRoCqJZWXbJkSXr99dezLMOGDVtu1qFDh2br58+fn73Wk2e5B7aSAAECBAgQIECAAAECBAgQIECAAAECBAj0skCpegDUYhVPS6y00krptddeS/kN/o758/V5ZLGePB2Pmb+//vrr09KlS/O37V4jMBETGUsEWkkgfh/zbnxz5syp9LZpJQN1JUCgNQVGjBiRPf2/aNGi9PLLL7cmglq3tMDIkSPrrr9r5rrpZGxSgegtFv9vRFqwYEGnvcqbtHqKTYAAgU4FYiSOIUOGZNunTZuWFi9e3Om+NhAoo0BPrplbNgAQH4QYMijG94+bjctL+fpVVlmlsrmePJXMVQvVx6xanS3GDYCFCxd2XO09gVILVAfEYrn6fakrrnIECBCoEvC3rwrDIoFuCPid6QaSXUolEAGA6uR3oFrDMgECZRbo+Peu4/sy113dCPRUoGWHAAq4fM6A/EZ/R8zZs2dnq9ZYY43KpnryVDJbIECAAAECBAgQIECAAAECBAgQIECAAAECfSTQ0gGAddZZJ2OeOnXqcrnz9Ztuumllez15KpktECBAgAABAgQIECBAgAABAgQIECBAgACBPhJo6QDALrvskjHHePwdU0z4e+ONN2arx48fX9lcT55KZgsECBAgQIAAAQIECBAgQIAAAQIECBAgQKCPBFo6ADBhwoQ0ZsyY9Nhjj6Vrr722Hfn555+fpk+fnjbYYIO03XbbVbbVk6eS2QIBAp0KzJo1Kz344IPZT/zuSQQIECBAgAABAgQIECBAgAABAgQI9EygpScBjgmUDj300HTCCSekU089Nd1xxx1p7Nix2Q3IWB44cGA65phjUvVES/Xk6VkTyU2gNQRuvvnm7PcwanvEEUekiRMntkbF1ZIAAQIECBAgQIAAAQIECBAgQIBALwm0dA+AMN1hhx3Sd7/73TRy5Mh00003pZ/85CdZICB6Bpx++ulpiy22WIa+njzLHMQKAgQIECBAgAABAgQIECBAgAABAgQIECDQiwKl7gEQN+pvueWWFfJtueWW6eKLL86G/PnrX/+aYqLfCAj07995fKSePCssiB0IECBAgAABAgQIECBAgAABAgQIECBAgECDBEodAKjVaPjw4Sl+akn15Knl+PYlQIAAAQIECBAgQIAAAQIECBAgQIAAAQL1CHT+iHs9R5OHAAECBAgQIECAAAECBAgQIECAAAECBAgQKISAAEAhmkEhCBAgQIAAAQIECBAgQIAAAQIECBAgQIBAYwUEABrr6WgECBAgQIAAAQIECBAgQIAAAQIECBAgQKAQAgIAhWgGhSBAgAABAgQIECBAgAABAgQIECBAgAABAo0VEABorKejESBAgAABAgQIECBAgAABAgQIECBAgACBQggIABSiGRSCAAECBAgQIECAAAECBAgQIECAAAECBAg0VkAAoLGejkaAAAECBAgQIECAAAECBAgQIECAAAECBAohIABQiGZQCAIECBAgQIAAAQIECBAgQIAAAQIECBAg0FgBAYDGejoaAQIECBAgQIAAAQIECBAgQIAAAQIECBAohIAAQCGaQSEIECBAgAABAgQIECBAgAABAgQIECBAgEBjBQQAGuvpaAQIECBAgAABAgQIECBAgAABAgQIECBAoBACAgCFaAaFIECAAAECBAgQIECAAAECBAgQIECAAAECjRUQAGisp6MRIECAAAECBAgQIECAAAECBAgQIECAAIFCCAgAFKIZFIIAAQIECBAgQIAAAQIECBAgQIAAAQIECDRWQACgsZ6ORoAAAQIECBAgQIAAAQIECBAgQIAAAQIECiEgAFCIZlAIAgQIECBAgAABAgQIECBAgAABAgQIECDQWAEBgMZ6OhoBAgQIECBAgAABAgQIECBAgAABAgQIECiEgABAIZpBIQgQIECAAAECBAgQIECAAAECBAgQIECAQGMFBAAa6+loBAgQIECAAAECBAgQIECAAAECBAgQIECgEAICAIVoBoUgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKNFRAAaKynoxEgQIAAAQIECBAgQIAAAQIECBAgQIAAgUIICAAUohkUggABAgQIECBAgAABAgQIECBAgAABAgQINFZAAKCxno5GgAABAgQIECBAgAABAgQIECBAgAABAgQKISAAUIhmUAgCBAgQIECAAAECBAgQIECAAAECBAgQINBYAQGAxno6GgECBAgQIECAAAECBAgQIECAAAECBAgQKISAAEAhmkEhCBAgQIAAAQIECBAgQIAAAQIECBAgQIBAYwUEABrr6WgECBAgQIAAAQIECBAgQIAAAQIECBAgQKAQAgIAhWgGhSBAgAABAgQIECBAgAABAgQIECBAgAABAo0VEABorKejESBAgAABAgQIECBAgAABAgQIECBAgACBQggIABSiGRSCAAECBAgQIECAAAECBAgQIECAAAECBAg0VkAAoLGejkaAAAECBAgQIECAAAECBAgQIECAAAECBAohIABQiGZQCAIECBAgQIAAAQIECBAgQIAAAQIECBAg0FgBAYDGejoaAQIECBAgQIAAAQIECBAgQIAAAQIECBAohIAAQCGaQSEIECBAgAABAgQIECBAgAABAgQIECBAgEBjBQQAGuvpaAQIECBAgAABAgQIECBAgAABAgQIECBAoBACAgCFaAaFIECAAAECBAgQIECAAAECBAgQIECAAAECjRUQAGisp6MRIECAAAECBAgQIECAAAECBAgQIECAAIFCCAgAFKIZFIIAAQIECBAgQIAAAQIECBAgQIAAAQIECDRWQACgsZ6ORoAAAQIECBAgQIAAAQIECBAgQIAAAQIECiEgAFCIZlAIAgQIECBAgAABAgQIECBAgAABAgQIECDQWAEBgMZ6OhoBAgQIECBAgAABAgQIECBAgAABAgQIECiEgABAIZpBIQgQIECAAAECBAgQIECAAAECBAgQIECAQGMFBAAa6+loBAgQIECAAAECBAgQIECAAAECBAgQIECgEAICAIVoBoUgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKNFRAAaKynoxEgQIAAAQIECBAgQIAAAQIECBAgQIAAgUIICAAUohkUggABAgQIECBAgAABAgQIECBAgAABAgQINFZAAKCxno5GgAABAgQIECBAgAABAgQIECBAgAABAgQKISAAUIhmUAgCBAgQIECAAAECBAgQIECAAAECBAgQINBYAQGAxno6GgECBAgQIECAAAECBAgQIECAAAECBAgQKISAAEAhmkEhCBAgQIAAAQIECBAgQIAAAQIECBAgQIBAYwUEABrr6WgECBAgQIAAAQIECBAgQIAAAQIECBAgQKAQAgIAhWgGhSBAgAABAgQIECBAgAABAgQIECBAgAABAo0VEABorKejESBAgAABAgQIECBAgAABAgQIECBAgACBQggIABSiGRSCAAECBAgQIECAAAECBAgQIECAAAECBAg0VkAAoLGejkaAAAECBAgQIECAAAECBAgQIECAAAECBAohIABQiGZQCAIECBAgQIAAAQIECBAgQIAAAQIECBAg0FgBAYDGejoaAQIECBAgQIAAAQIECBAgQIAAAQIECBAohIAAQCGaQSEIECBAgAABAgQIECBAgAABAgQIECBAgEBjBQQAGuvpaAQIECBAgAABAgQIECBAgAABAgQIECBAoBACAgCFaAaFIECAAAECBAgQIECAAAECBAgQIECAAAECjRUQAGisp6MRIECAAAECBAgQIECAAAECBAgQIECAAIFCCAgAFKIZFIIAAQIECBAgQIAAAQIECBAgQIAAAQIECDRWQACgsZ6ORoAAAQIECBAgQIAAAQIECBAgQIAAAQIECiEgAFCIZlAIAgQIECBAgAABAgQIECBAgAABAgQIECDQWAEBgMZ6OhoBAgQIECBAgAABAgQIECBAgAABAgQIECiEQFshSqEQBGoQWLJkSVq6dGkNOezaDALRrnmK5cWLF+dvvZZEoF+/fql/f3HnkjSnahAgQIAAAQIECBAgQIAAAQJNICAA0ASNpIj/EIgbwscdd1y66667kJRc4D//8z9T/EjlE9h8883TGWeckQYNGlS+yqkRAQIECBAgQIAAAQIECBAgQKBgAh7FLFiDKE7nAi+88IKb/53z2EKgKQT+/Oc/p8cff7wpyqqQBAgQIECAAAECBAgQIECAAIFmF9ADoNlbsIXKv2jRokptV1lllTRq1KjKewsECBRb4MUXX0xz5szJCln9u1zsUisdAQIECBAgQIAAAQIECBAgQKC5BQQAmrv9Wrb073znOw0R07Ktr+LNKPDVr341XXLJJc1YdGUmQIAAAQIECBAgQIAAAQIECDStgCGAmrbpFJwAAQIECBAgQIAAAQIECBAgQIAAAQIECHQuIADQuY0tBAgQIECAAAECBAgQIECAAAECBAgQIECgaQUEAJq26RScAAECBAgQIECAAAECBAgQIECAAAECBAh0LiAA0LmNLQQIECBAgAABAgQIECBAgAABAgQIECBAoGkFBACatukUnAABAgQIECBAgAABAgQIECBAgAABAgQIdC4gANC5jS0ECBAgQIAAAQIECBAgQIAAAQIECBAgQKBpBQQAmrbpFJwAAQIECBAgQIAAAQIECBAgQIAAAQIECHQu0Nb5JlveKIEBAwakVVdd9Y06fWHPO3To0MKWTcEIEOi+wCqrrOJvXPe57NlCAv379/e70ULtraqNEXDN3BhHR2lOAd8bm7PdlJoAgfoEBg4cWMkY3ymXLl1aeW+BAIGuBQQAuvZ5Q7bGDYDBgwe/Iecu8kmr/9gXuZzKRoBA1wLxu+xvXNdGtramQL9+/fxutGbTq3UPBPx/0gM8WZtewPfGpm9CFSBAoAaB+JuXp0GDBuWLXgkQ6IaAAEA3kPp6l4ULF6bZs2f39WkLf76ZM2cWvowKSIDAigVmzZqVpk2btuId7UGgRQRGjhyZ1XTx4sV+N1qkzVWzvcCoUaPar6jhnf9PasCyaykE4gbYiBEjsrrE98bp06eXol4qQYAAgRUJrL766mmllVbKdov7Q4sWLVpRFtsJlEqgJ9fM/wqflYpEZQgQIECAAAECBAgQIECAAAECBAgQIECAQGsLCAC0dvurPQECBAgQIECAAAECBAgQIECAAAECBAiUVEAAoKQNq1oECBAgQIAAAQIECBAgQIAAAQIECBAg0NoCAgCt3f5qT4AAAQIECBAgQIAAAQIECBAgQIAAAQIlFRAAKGnDqhYBAgQIECBAgAABAgQIECBAgAABAgQItLaAAEBrt7/aEyBAgAABAgQIECBAgAABAgQIECBAgEBJBQQAStqwqkWAAAECBAgQIECAAAECBAgQIECAAAECrS0gANDa7a/2BAgQIECAAAECBAgQIECAAAECBAgQIFBSAQGAkjasahEgQIAAAQIECBAgQIAAAQIECBAgQIBAawsIALR2+6s9AQIECBAgQIAAAQIECBAgQIAAAQIECJRUQACgpA2rWgQIECBAgAABAgQIECBAgAABAgQIECDQ2gICAK3d/mpPgAABAgQIECBAgAABAgQIECBAgAABAiUVEAAoacOqFgECBAgQIECAAAECBAgQIECAAAECBAi0toAAQGu3v9oTIECAAAECBAgQIECAAAECBAgQIECAQEkFBABK2rCqRYAAAQIECBAgQIAAAQIECBAgQIAAAQKtLSAA0Nrtr/YECBAgQIAAAQIECBAgQIAAAQIECBAgUFIBAYCSNqxqESBAgAABAgQIECBAgAABAgQIECBAgEBrCwgAtHb7qz0BAgQIECBAgAABAgQIECBAgAABAgQIlFRAAKCkDataBAgQIECAAAECBAgQIECAAAECBAgQINDaAgIArd3+ak+AAAECBAgQIECAAAECBAgQIECAAAECJRVoK2m9VKvkAlOmTEnHHHNMyWupegTKI3DfffeVpzJqQoAAAQIECBAgQIAAAQIECBBoEgEBgCZpKMVsL/DCCy+kyy+/vP1K7wgQIECAAAECBAgQIECAAAECBAgQIECgImAIoAqFBQIECBAgQIAAAQIECBAgQIAAAQIECBAgUB4BAYDytKWaECBAgAABAgQIECBAgAABAgQIECBAgACBioAAQIXCAgECBAgQIECAAAECBAgQIECAAAECBAgQKI+AAEB52lJNCBAgQIAAAQIECBAgQIAAAQIECBAgQIBARcAkwBUKC80ksOOOO6bTTz+9mYqsrARaWuDkk082cXdLfwJUngABAgQIECBAgAABAgQIEHgjBAQA3gh15+yxQFtbWxo2bFiPj+MABAj0jcDAgQP75kTOQoAAAQIECBAgQIAAAQIECBAgUBEwBFCFwgIBAgQIECBAgAABAgQIECBAgAABAgQIECiPgABAedpSTQgQIECAAAECBAgQIECAAAECBAgQIECAQEXAEEAVCgsECBAgQIAAAQIECBAgQIAAAQIECBRN4MILL0yPPvpoVqxJkyal1VdfvWhFVB4ChRUQAChs0ygYAQIECBAgQIAAAQIECBAgQIAAAQJ33XVXuvHGGzOIffbZRwDAR4JADQKGAKoBy64ECBAgQIAAAQIECBAgQIAAAQIECBAgQKBZBAQAmqWllJMAAQIECBAgQIAAAQIECBAgQIAAAQIECNQgIABQA5ZdCRAgQIAAAQIECBAgQIAAAQIECBAgQIBAswgIADRLSyknAQIECBAgQIAAAQIECBAgQIAAAQIECBCoQUAAoAYsuxIgQIAAAQIECBAgQIAAAQIECBAgQIAAgWYREABolpZSTgIECBAgQIAAAQIECBAgQIAAAQIECBAgUIOAAEANWHYlQIAAAQIECBAgQIAAAQIECBAgQIAAAQLNIiAA0CwtpZwECBAgQIAAAQIECBAgQIAAAQIECBAgQKAGAQGAGrDsSoAAAQIECBAgQIAAAQIECBAgQIAAAQIEmkVAAKBZWko5CRAgQIAAAQIECBAgQIAAAQIECBAgQIBADQICADVg2ZUAAQIECBAgQIAAAQIECBAgQIAAAQIECDSLgABAs7SUchIgQIAAAQIECBAgQIAAAQIECBAgQIAAgRoEBABqwLIrAQIECBAgQIAAAQIECBAgQIAAAQIECBBoFgEBgGZpKeUkQIAAAQIECBAgQIAAAQIECBAgQIAAAQI1CAgA1IBlVwIECBAgQIAAAQIECBAgQIAAAQIECBAg0CwCAgDN0lLKSYAAAQIECBAgQIAAAQIECBAgQIAAAQIEahAQAKgBy64ECBAgQIAAAQIECBAgQIAAAQIECBAgQKBZBAQAmqWllJMAAQIECBAgQIAAAQIECBAgQIAAAQIECNQgIABQA5ZdCRAgQIAAAQIECBAgQIAAAQIECBAgQIBAswgIADRLSyknAQIECBAgQIAAAQIECBAgQIAAAQIECBCoQUAAoAYsuxIgQIAAAQIECBAgQIAAAQIECBAgQIAAgWYREABolpZSTgIECBAgQIAAAQIECBAgQIAAAQIECBAgUIOAAEANWHYlQIAAAQIECBAgQIAAAQIECBAgQIAAAQLNIiAA0CwtpZwECBAgQIAAAQIECBAgQIAAAQIECBAgQKAGAQGAGrDsSoAAAQIECBAgQIAAAQIECBAgQIAAAQIEmkVAAKBZWko5CRAgQIAAAQIECBAgQIAAAQIECBAgQIBADQICADVg2ZUAAQIECBAgQIAAAQIECBAgQIAAAQIECDSLgABAs7SUchIgQIAAAQIECBAgQIAAAQIECBAgQIAAgRoEBABqwLIrAQIECBAgQIAAAQIECBAgQIAAAQIECBBoFgEBgGZpKeUkQIAAAQIECBAgQIAAAQIECBAgQIAAAQI1CAgA1IBlVwIECBAgQIAAAQIECBAgQIAAAQIECBAg0CwCAgDN0lLKSYAAAQIECBAgQIAAAQIECBAgQIAAAQIEahAQAKgBy64ECBAgQIAAAQIECBAgQIAAAQIECBAgQKBZBAQAmqWllJMAAQIECBAgQIAAAQIECBAgQIAAAQIECNQgIABQA5ZdCRAgQIAAAQIECBAgQIAAAQIECBAgQIBAswgIADRLSyknAQIECBAgQIAAAQIECBAgQIAAAQIECBCoQUAAoAYsuxIgQIAAAQIECBAgQIAAAQIECBAgQIAAgWYREABolpZSTgIECBAgQIAAAQIECBAgQIAAAQIECBAgUIOAAEANWHYlQIAAAQIECBAgQIAAAQIECBAgQIAAAQLNItDWLAVVTgLVAgsXLkwzZ86sXmWZAIECCyxYsKDApVM0AgQIECBAgAABAgQIECBAgEA5BQQAytmupa/VzTffnCZMmFD6eqogAQIECBAgQIAAAQIECBAgQIAAAQIE6hUwBFC9cvL1ucBKK63U5+d0QgIEGi/gd7nxpo5IgAABAgQIECBAgAABAgQIEFiegB4Ay1OxrpACI0aMSIceemj64x//mJYuXVrIMipU/QKzZs1Kzz77bHaAUaNGpeHDh9d/MDkLKdCvX7+0xRZbpLFjxxayfApFgAABAgQIECBAgAABAgQIECibgABA2Vq05PXZf//9U/xI5RP43e9+l0499dSsYh/+8IfTxIkTy1dJNSJAgAABAgQIECBAgAABAgQIECDQhwKGAOpDbKciQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ9JSAA0FfSzkOAAAECBAgQIECAAAECBAgQIECAAAECBPpQQACgD7GdigABAgQIECBAgAABAgQIECBAgAABAgQI9JWAAEBfSTsPAQIECBAgQIAAAQIECBAgQIAAAQIECBDoQ4GWngT4pz/9aZozZ84Kufv3758+//nPV/abN29eirxdpT333DNttNFGXe1iGwECBAgQIECAAAECBAgQIECAAAECBAgQ6DWBlg4AXHvttWnatGkrxO0YAHj88cfTJZdc0mW+8ePHCwB0KWQjAQIECBAgQIAAAQIECBAgQIAAAQIECPSmQEsHAP7jP/4jvf7668v1Xbx4cTrrrLPS7NmzUzzNX50ee+yx7O3WW2+ddt555+pNleWxY8dWli0QIECAAAECBAgQIECAAAECBAgQIECAAIG+FmjpAMBuu+3WqffPfvaz7Ob/Zpttlo466qh2++UBgLj5v9dee7Xb5g0BAgQIECBAgAABAgQIECBAgAABAgQIECiCgEmAl9MK999/fzrnnHPS4MGD04knnpgGDhzYbq8YAijSuHHj2q33hgABAgQIECBAgAABAgQIECBAgAABAgQIFEVAAKBDSyxatCh95zvfSUuXLk0HHnhgGjVqVLs9YvvUqVNTW1tb2nDDDbNtMUzQ/Pnz2+3nDQECBAgQIECAAAECBAgQIECAAAECBAgQeCMFWnoIoOXBX3rppempp55Ko0ePTvvtt98yuzz99NNp4cKFaf31108XXHBB+s1vfpOmT5+eYqLgWPeJT3widTW0UH7Aww47LL3yyiv523avH//4xzudW6Ddjt4QKJFA9LjJ06BBg9Kaa66Zv/VKgACBlhAYMGCAv30t0dIq2UgB1wuN1HSsZhOIh9L8DjRbqykvAQL1CsR9tzwNGzbM378cwyuBbggIAFQhxcS/F110UbZm3333zZ7yr9qcLebj/z/zzDPZJMFrrbVWismAI2gQPyeffHK6995705e//OWOWdu9v++++9KMGTParcvfvO9978uGH8rfeyXQCgJx4ytP8R97dUAgX++VAAECZRbo16+fv31lbmB16xUB1wu9wuqgTSLgmrlJGkoxCRBoiEBcK+cphup2DZBreCWwYgEBgCqjO++8M02bNi2tvPLKaffdd6/a8q/FfPz/iDaeeuqpafz48dnGGDIoegOceeaZ6eqrr04TJkxIO+64478yWiJAgAABAgQIECBAgAABAgQIECBAgAABAn0oIABQhX3llVdm7/bYY48sCFC1qbI4adKktMsuu6TVVlstrbvuupX1EYncZ599sl4AEQg477zzugwARJBgyZIllfzVCzHPwIsvvli9yjKB0gu89tprlTrGnBp+ByocFggQKLnAOuusk+I6Iv7/j2EFJQKtJjBixIi6q+x6oW46GZtUIP6/iP83Ii1YsCDNnDmzSWui2AQIEKhNoPoeWvztcw1Qm5+9m1+gJ9fMAgD/bP+XX3453XHHHdm7vffeu9NPRTz5v+mmm3a6/b3vfW/WE+DJJ5/MbvBXj1FWnamrsRpnzZqVqm+GVuezTKCsAtGLJk+xXP2fe77eKwECBMou4G9f2VtY/Rot4Hem0aKOV3SBjt8v/Q4UvcWUjwCBRgm4Z9AoScdpRYF/zaDRirWvqvM111yTYg6ArbbaKo0ZM6ZqS22LeTQmnsZ49dVXa8tsbwIECBAgQIAAAQIECBAgQIAAAQIECBAg0CABPQD+CXnjjTdmSzEBb1fp4osvzrrnxzBBywsU5F2QVl111RS9BSQCBAgQIECAAAECBAgQIECAAAECBAgQIPBGCOgB8Hf1efPmpalTp2b+Y8eO7bIdrr/++nT++eenc889d7n73Xrrrdn6zTbbbLnbrSRAgAABAgQIECBAgAABAgQIECBAgAABAn0hIADwd+VHHnkkxVhiAwYMSOuvv36X7jvttFO2PXoMPPHEE+32veeee1L0EIh08MEHt9vmDQECBAgQIECAAAECBAgQIECAAAECBAgQ6EsBQwD9Xfu5557LzNdbb700cODALv333XffdPvtt6f77rsvffKTn0xbb7119vP444+nm266Kct72GGHpXHjxnV5HBsJECBAgAABAgQIECBAgAABAgQIECBAgEBvCggA/F13+vTpmfGGG264QuvoJXDaaadlwwBdcMEFKZ76j59Io0ePTp/73OfShAkTVngcOxAgQIAAAQIECBAgQIAAAQIECBAgQIAAgd4UEAD4u248yR8/3U1DhgzJhviZNGlSev7559OsWbNSBA+GDh3a3UPYjwABAgQIECBAgAABAgQIECBAgAABAgQI9KqAAEAPeNva2rI5A1Y0b0APTiErAQIECBAgQIAAAQIECBAgQIAAAQIECBCoS8AkwHWxyUSAAAECBAgQIECAAAECBAgQIECAAAECBIotIABQ7PZROgIECBAgQIAAAQIECBAgQIAAAQIECBAgUJeAAEBdbDIRIECAAAECBAgQIECAAAECBAgQIECAAIFiCwgAFLt9lI4AAQIECBAgQIAAAQIECBAgQIAAAQIECNQlIABQF5tMBAgQIECAAAECBAgQIECAAAECBAgQIECg2AICAMVuH6UjQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ1CQgA1MUmEwECBAgQIECAAAECBAgQIECAAAECBAgQKLaAAECx20fpCBAgQIAAAQIECBAgQIAAAQIECBAgQIBAXQICAHWxyUSAAAECBAgQIECAAAECBAgQIECAAAECBIotIABQ7PZROgIECBAgQIAAAQIECBAgQIAAAQIECBAgUJeAAEBdbDIRIECAAAECBAgQIECAAAECBAgQIECAAIFiCwgAFLt9lI4AAQIECBAgQIAAAQIECBAgQIAAAQIECNQlIABQF5tMBAgQIECAAAECBAgQIECAAAECBAgQIECg2AICAMVuH6UjQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ1CQgA1MUmEwG5iw/wAABAAElEQVQCBAgQIECAAAECBAgQIECAAAECBAgQKLZAW7GLp3QECBAgQIAAAQIECBAgQIAAAQIEViwwf/78NHv27BXvaI+mE4i2zdOMGTPSkCFD8rdeSyLQ1taW1lhjjZLUpljVEAAoVnsoDQECBAgQIECAAAECBAgQIECAQI0CU6dOTYcffniaN29ejTnt3mwCRx55ZLMVWXm7KbDnnnumL33pS93c227dFTAEUHel7EeAAAECBAgQIECAAAECBAgQIFBIgbvvvtvN/0K2jEIR6L7AzTff3P2d7dltAT0Auk1lRwIECBAgQIAAAQIECBAgQIAAgSIKLFmypFKsDTfcMI0YMaLy3gIBAsUWiADewoULU/XvcbFL3FylEwBorvZSWgIECBAgQIAAAQIECBAgQIAAgS4EDjrooLTvvvt2sYdNBAgUSWD77bdP06ZNK1KRSlUWQwCVqjlVhgABAgQIECBAgAABAgQIECBAgAABAgQI/ENAAMAngQABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFBAAKCEjapKBAgQIECAAAECBAgQIECAAAECBAgQIEBAAMBngAABAgQIECBAgAABAgQIECBAgAABAgQIlFCgTwMAr776apo7d24JGVWJAAECBAgQIECAAAECBAgQIECAAAECBAgUS6BXAwDTpk1LRx99dHrPe96T1l133TR06NB04oknZgJPPvlkeve7350uueSStGTJkmKpKA0BAgQIECBAgAABAgQIECBAgAABAgQIEGhygbbeKP/SpUvT9773vfS1r30tzZo1a7mneOqpp9Ktt96a/XzsYx9L55xzTho4cOBy97WSAAECBAgQIECAAAECBAgQIECAAAECBAgQqE2gV3oAnHnmmemoo47Kbv63tbWlLbfcMm200UbtSrZo0aLKDf8LLrggfeYzn2m33RsCBAgQIECAAAECBAgQIECAAAECBAgQIECgfoGGBwAefPDBdNxxx2Ul2nPPPdMTTzyR7r333hTL1WnXXXfNtsUwQJGiB8Cjjz5avYtlAgRaSGDMmDFp3333zX423njjFqq5qhIgQIAAAQIECBAgQIAAAQIECBDoHYGGDwH03e9+N82fPz976v/iiy9OK620UqclHz16dLruuuvSeuutl2bMmJHOPvvsdNppp3W6vw0ECJRX4O1vf3s2X0jUcPbs2SkmDZcIECBAgAABAgQIECBAgAABAgQIEKhfoOE9AO6///6sNNELoKub/3mRY5+8d8Bjjz2Wr/ZKgAABAgQIECBAgAABAgQIECBAgAABAgQI9ECgoT0AFi9enKZMmZIVZ+utt+52sfbYY4/0y1/+Mj3zzDPdzlPmHQcMGJCGDRtW5iqqG4FlBGK+kDwNHjw49e/f8PhkfnivBAgQKKRA/N3z/38hm0ahCizgd6bAjaNovS7ge2OvEztBkwnE90iJAIHmFujXr5/vRL3QhP+649aAg8cFyNChQ7PhfF555ZVuH3HatGnZvuuuu26385R5x7gBMGTIkDJXUd0ILCMQf+TzNHDgwFQdEMjXeyVAgECZBeLvYHd6T5bZQN0I1Crgd6ZWMfuXSSC+N/odKFOLqktPBeJ7pESAQPML+L+t8W3Y0ABAFC/G8b7pppvSDTfckM0D0J0ixzwAkTbffPPu7F76fRYuXJiNgV76iqoggSqB+AO/+uqrZ2vmzp1rDoAqG4sECJRbYOTIkVkFoydl/lBEuWusdgTaC4waNar9ihrevfTSSzXsbVcCzS8QN/1HjBiRVSS+N06fPr35K6UGBBokEN8jJQIEmltg6dKlyfXd8tuwJ9fMDR9jY7vttstKOXny5PT4448vv8RVa3/+85+na6+9NltTy7BBVYewSIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHQQaHgA4Nhjj02jR49Oc+bMSe94xzvSj3/84/Tiiy92OG1KTz/9dDrkkEPSwQcfnG3bfvvt0z777LPMflYQIECAAAECBAgQIECAAAECBAgQIECAAAECtQs0PAAQQ3ice+652QSeMQ/AZz7zmRRd2yMQEOlXv/pVWnvttdOYMWPS2WefnaJrx8orr5yiJ0B0Z5QIECBAgAABAgQIECBAgAABAgQIECBAgACBngv0yh33nXbaKf3xj39MEyZMqJRw/vz52fILL7yQXn755cr6XXbZJd19991po402qqyzQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECPRMoOGTAOfF2WabbdLtt9+eLrnkkuz1scceS/ETT/xvvPHGaezYsSkCBXvttVeexSsBAgQIECBAgAABAgQIECBAgAABAgQIECDQIIFeCwBE+fr165f23Xff7KdB5XUYAgQIECBAgAABAgQIECBAgAABAgQIECBAoBsCvRoA6Mb57UKAAAECBAgQIECAAAECBAgQIECgYQKnnnpq+s53vtOw4zkQAQK9KzBr1qzePUGLH/0NCQA899xz6brrrsuGA/rABz6Q1llnnRZvBtUnQIAAAQIECBAgQIAAAQIECBBohMC8efNS/EgECBAgkFKvTAK8aNGidNlll6UPfvCD6cYbb2znfNJJJ6X11lsvHXzwwemQQw5Jo0aNSgcccEAWDGi3ozcECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA3QK9EgA47rjj0t57752uuOKK9Oijj1YKd9VVV6XJkydX3sfCkiVL0i9/+cv0ta99rd16bwgQIECAAAECBAgQIECAAAECBAgQIECAAIH6BRoeALj55pvTGWeckZWora0trbzyypXSff3rX8+e9B8wYEA66qij0j333JMOP/zwbHsEBuK9RIAAAQIECBAgQIAAAQIECBAgQIAAAQIECPRcoOFzAJx99tnZU/2bb755uvTSS9PGG2+clfLpp59Od955Z7a8zz77VIIEW221VXr44YfTDTfckG699da09dZb97xWjkCAAAECBAgQIECAAAECBAgQINCSAuuvv34aPnx4S9ZdpQk0o8CDDz6YYkh5qXcEGh4AeOihh7KSTpo0qXLzP1Zcc801lRpMnDixshwL++67bxYAuPfee9ut94YAAQIECBAgQIAAAQIECBAgQIBALQKf+tSnsntNteSxLwECb5zA9ttvn6ZNm/bGFaDkZ27oEEBLly5NjzzySEa2++67t6O79tprs/cx/M9uu+3WbltMBBxpypQp7dZ7Q4AAAQIECBAgQIAAAQIECBAgQIAAAQIECNQn0NAAQEzou2DBgqwkw4YNq5Qo1t10003Z+2222SatscYalW2x8NJLL2XvV1999XbrvSFAgAABAgQIECBAgAABAgQIECBAgAABAgTqE2hoACCe7t9ggw2ykuQ9AeJNTAw8d+7cbH3HngGxMsb/jxRjtEkECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAzwUaGgCI4kyYMCEr1UknnZSeeOKJNG/evHTcccdVSvqRj3yksvz6669nkwFfdNFF2boY70kiQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEei7Q8EmAjzrqqHTeeeelO++8M2266aZp8ODBlaf/99hjj/TWt741K/Vtt92WIhjw/PPPZ+9Hjx6dPv7xj/e8Ro5AgAABAgQIECBAgAABAgQIECBAgAABAgQIpIb3ANhqq63SOeeckwYOHJgWLlxYufm/2WabpQsvvLBC/sorr1Ru/q+99trZtkGDBlW2WyBAgAABAgQIECBAgAABAgQIECBAgAABAgTqF2h4D4AoyqRJk9LWW2+drrnmmvTkk0+mHXfcMcXT/6uttlqlpJtsskkaMWJEmjhxYjrmmGMqcwdUdrBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1C3QKwGAKM3mm2+e/XRWsje/+c1ZD4D+/RveCaGzU1pPgAABAgQIECBAgAABAgQIECBAgAABAgRaRqDXAgArEuzXr1+KH4kAAQIECBAgQIAAAQIECBAgQIAAAQIECBBovECvBgBeeuml9Oijj6Z58+alRYsWrbD0G2+8cRo7duwK97MDAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0LVArwQA4qb/8ccfny677LJu3fjPi3jiiSemk046KX/rlQABAgQIECBAgAABAgQIECBAgAABAgQIEKhToOEBgDlz5qS99tor/eUvf6mzSLIRIECAAAECBAgQIECAAAECBAgQIECAAAECPRVoeABg8uTJlZv/MZzPRz/60TRmzJg0cuTIFY75v9FGG/W0PvITIECAAAECBAgQIECAAAECBAgQIECAAAECfxdoeADg1ltvzWC33HLLdP3116c111wTNAECBAgQIECAAAECBAgQIECAAAECBAgQINDHAv0beb7FixenP/3pT9khDzroIDf/G4nrWAQIECBAgAABAgQIECBAgAABAgQIECBAoAaBhgYABgwYkFZZZZXs9NEDQCJAgAABAgQIECBAgAABAgQIECBAgAABAgTeGIGGBgCiCu985zuzmjz11FPZq38IECBAgAABAgQIECBAgAABAgQIECBAgACBvhdoeABg5513zmpx1lln9X1tnJEAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIBBoeADjiiCPSPvvsk37/+9+nz33uc2nOnDmoCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgT4WaGv0+aZMmZIOPfTQdNddd6Uf/OAH6cILL0xbb7112mCDDdLaa6/d5emi98BOO+3U5T42EiBAgAABAgQIECBAgAABAgQIECBAgAABAisWaHgA4LjjjkvXXHNN5czTpk1Lv/3tbyvvu1poa2sTAOgKyDYCBAgQIECAAAECBAgQIECAAAECBAgQINBNgYYPAdTN89qNAAECBAgQIECAAAECBAgQIECAAAECBAgQ6EWBhvcAuOiii9KiRYvqKvKQIUPqyicTAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0F6g4QGAoUOHtj+DdwQIECBAgAABAgQIECBAgAABAgQIECBAgECfCxgCqM/JnZAAAQIECBAgQIAAAQIECBAgQIAAAQIECPS+QMN7AHRW5Llz56YnnngiDR48OK2zzjppjTXWSP369etsd+sJECBAgAABAgQIECBAgAABAgQIECBAgACBHgj0ag+AKVOmpA996ENp9OjRadiwYWn8+PFp0003TcOHD09rr712OvTQQ9M999zTg+LLSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECCxPoFcCADEJ8LHHHpu23HLLdPnll6dnn312mXNPnz49nXXWWWnChAnptNNOW2a7FQQIECBAgAABAgQIECBAgAABAgQIECBAgED9Ar0yBNApp5xSuakfw/zsuOOOady4cWmDDTZI8+bNS08//XS6//770wMPPJDyYMHIkSPTAQccUH9N5CRAgAABAgQIECBAgAABAgQIECBAgAABAgQqAg0PANx3330pAgCR/u3f/i398Ic/zHoCVM5YtXDllVemI488Mj355JPps5/9bNprr73S6quvXrWHRQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAegYYPAfT9738/LVy4ML35zW9OV199dac3/6OwH/jAB1IEAVZeeeUUkwSff/759dRBHgIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCDQMMDADGsT6QTTzyxW0/zb7bZZunggw/O8tx0003Zq38IECBAgAABAgQIECBAgAABAgQIECBAgACBngk0NACwePHi9NBDD2Ul2nbbbbtdsnzfmBtAIkCAAAECBAgQIECAAAECBAgQIECAAAECBHou0NAAQP/+/VNb2z+mFXj11Ve7XbqYGDjSaqut1u08diRAgAABAgQIECBAgAABAgQIECBAgAABAgQ6F2hoAKBfv35pk002yc526623dn7WDltuueWWbM3b3va2Dlu8JUCAAAECBAgQIECAAAECBAgQIECAAAECBOoRaGgAIAqw3XbbZeU46aST0tSpU1dYpuuuu64y+e+WW265wv3tQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECKxYoOEBgK9+9atp6NCh6ZVXXknvec970s9+9rMUcwN0THPmzEmTJ09OH/7wh9PSpUtTPP3/7//+7x13854AAQIECBAgQIAAAQIECBAgQIAAAQIECBCoQ+AfA/bXkbGzLKNGjUrf+MY30hFHHJGeffbZdPDBB6ejjz46bbjhhmnMmDFpwYIF6amnnkpPPPFEysf+HzhwYDr33HPToEGDOjus9QQIECBAgAABAgQIECBAgAABAgQIECBAgEANAg0PAMS5Dz/88DRu3Lh00EEHZUGAmTNnpnvuuSf76Vi28ePHpx/+8IfJ8D8dZbwnQIAAAQIECBAgQIAAAQIECBAgQIAAAQL1C/RKACCKs+uuu6Y///nP6Uc/+lH2+vDDD6dHHnkkxdP+Y8eOzX523nnndOCBB6YBAwbUXwM5CRAojcCrr76aDQlWmgqpCAECBAgQIECAAAECBAgQIECAAIE3UKDXAgBRp9VWWy19+ctfrlQvxvrv169f5b0FAgQIxHwgF154Ybr++uvTiy++mIEMHz487bTTTmn//fdPa6yxBiQCBAgQIECAAAECBAgQIECAAAECBOoQaPgkwF2VYfr06WnGjBld7WIbAQItJDB16tRsqLDzzz+/cvM/qh9/Ky655JKsh9BDDz3UQiKqSoAAAQIECBAgQIAAAQIECBAgQKBxAr0aALjrrrvS8ccfn97//venN73pTWnttddO8WTv4MGD07ve9a50+umnp5gfQCJAoPUEZs+enY499tg0bdq0Tis/a9asrBdRV/t0mtkGAgQIECBAgAABAgQIECBAgAABAi0u0CsBgNdffz1NmjQpTZgwIZ1yyinp6quvTs8//3yFesGCBen2229PX/rSl9Imm2ySPelb2WiBAIGWELjgggu6vPmfI0Sg4JxzzsnfeiVAgAABAgQIECBAgAABAgQIECBAoJsCDZ8DYPHixWm//fZLV1xxRVaE/v37Z4GAMWPGpNGjR6e5c+emZ5555v+zdydgclVlwoC/TjoJWQiJQMKSBIxAQCAEohKVfdMRjBIEZY1sgzCowKMYBNlURnBGHBVkWFSGwCOCoqIgIEFlkcWwb04gAZElCUsIWUjSSf+c+08V3Ul30l1V3X2r6r3P06m7nHvud96T7q6+X91zsomBZ82aFXPmzMnK/+pXv4pPfepTHQxbMQIEql3gtttu63AT7rjjjjj55JOjsbHiP7I6HIOCBAgQIECAAAECBAgQIFAdAg899FD06dOnOoIVJQECkT5Mbuk6gYrfTfvFL35RvPk/ceLE+M53vhNbbbXVKi1YsWJF9sn/NATIc889F4cffniWGBgyZMgqZe0gQKC2BNLEv2mc/44uixYtyuYISEOJWQgQIECAAAECBAgQIECAwOoEfvnLX0b6shAgQIBARMWHAPrRj36Uue69996RPtXf1s3/VCA9GXDQQQfFzTffHIMHD450Q/DSSy/VJwQI1IFASgB2dmlubu7sKcoTIECAAAECBAgQIECAQJ0IbLDBBnXSUs0kULsCvo+7pm8r/gTA448/nkWaxv7v3bv3GqNOcwAcd9xx8d3vfjfuvPPOOPXUU9d4jgIECFS3wDrrrJMl/tL4/h1Z+vbtm00i3pGyyhAgQIAAAQIECBAgQIBA/Qnsuuuu8Y1vfCNefvnl+mt8HbR42rRpMXPmzKylBx54YKT7CpbaEkjDPqfvY0vlBSqaAGhqasrGbGpoaIixY8d2ONoPfOADWdlXXnmlw+coSIBAdQvsvvvu8Zvf/KZDjfjoRz8a/fr161BZhQgQIECAAAECBAgQIECg/gTSvag999yz/hpeJy1ON/8LCYA05HiaZ9RCgEDHBCo6BFDK1Gy//faRhuooPAnQkTDSHABpGTduXPbqHwIEal/gsMMOi0GDBq2xoenG/1FHHbXGcgoQIECAAAECBAgQIECAAAECBAgQINBaoKIJgFT1zjvvnF0hDQHUkTG7Fy9eHFOnTs3O8ZhHxuAfAnUhsP7660f6OTFw4MB225tu/p9zzjky++0KOUCAAAECBAgQIECAAAECBAgQIECgfYGKJwDSeGvpKYAbbrghjjnmmHj11VfbvfqcOXPi0EMPjcceeyw+9rGPxcEHH9xuWQcIEKg9ge222y4uv/zySJOGtxzip0+fPrHLLrvEZZddFhMmTKi9hmsRAQIECBAgQIAAAQIECBAgQIAAgW4QaHjnU/rNlbzO9OnT44knnogvfOELkT7dnz7de8ghh8SYMWNi0003zZ4KeOGFF+Kpp56Kq6++OhYtWpRd/sQTT4whQ4a0GcrnPve52Hrrrds8Vos7582bl9nVYtu0iUB7Ar169YoFCxZkPyMGDx4cy5cvb6+o/QQIEKgpgQ022CDSmLVpLqW5c+fWVNs0hkBHBDbccMOOFGuzjIke22Sxs4YF0nvm4cOHZy1cunRpvPbaazXcWk0jQIDAuwLnnntupImA03LVVVcZKeBdGmt1IlDOe+aKTgKcvM8888y46aabivQLFy7MPsVb3NHOyo9+9KN2jkSkTwnXUwKgXQgHCNSwQHoCoPDHzPz58yP97LAQIECAAAECBAgQIECAAAECBAgQIFC6QMWHACo9FGcSIECAAAECBAgQIECAAAECBAgQIECAAAEClRKo+BMA1157bfYIe6UCTPWsbpLQSl5HXQQIECBAgAABAgQIECBAgAABAgQIECBAoFYEKp4AGDRoUK3YaAcBAgQIECBAgAABAgQIECBAgAABAgQIEKhaAUMAVW3XCZwAAQIECBAgQIAAAQIECBAgQIAAAQIECLQvUPEnANq/1LtHXnzxxbjllluiubk5PvnJT8awYcPePWiNAAECBAgQIECAAAECBAgQIECAAAECBAgQKFugS54AaGpqil//+tfxqU99KqZNm9YqyLPPPjtGjBgRRx99dBxzzDGx4YYbxhFHHJElA1oVtEGAAAECBAgQIECAAAECBAgQIECAAAECBAiULNAlCYDTTjst9t9///jtb38bf//734vB/e53v4tzzz23uJ1WVqxYEVdddVWcc845rfbbIECAAAECBAgQIECAAAECBAgQIECAAAECBEoXqHgC4M9//nN873vfyyJqbGyMAQMGFKP71re+lX3Sv3fv3nHyySfH9OnT48QTT8yOp8RA2rYQIECAAAECBAgQIECAAAECBAgQIECAAAEC5QtUfA6AK664IvtU/zbbbBO//OUvY4sttsiifP755+O+++7L1idNmlRMEuywww7x1FNPxe233x533XVXjB8/vvxWqYEAAQIECBAgQIAAAQIECBAgQIAAAQIECNS5QMWfAHjyyScz0smTJxdv/qcdN910U5H6gAMOKK6nlQMPPDDbfvDBB1vtt0GAAAECBAgQIECAAAECBAgQIECAAAECBAiUJlDRBEBzc3M8/fTTWSQf+9jHWkV08803Z9tp+J999tmn1bE0EXBannjiiVb7bRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKlCVQ0AZAm9F26dGkWydprr12MKO274447su0PfvCDMXTo0OKxtDJnzpxse8iQIa322yBAgAABAgQIECBAgAABAgQIECBAgAABAgRKE6hoAiB9un+TTTbJIik8CZA20sTACxYsyPav/GRA2pnG/0/LqFGjslf/ECBAgAABAgQIECBAgAABAgQIECBAgAABAuUJVHwS4AkTJsQzzzwTZ599dmy++eaRhvc57bTTilEedNBBxfW33347Lr744rj22muzfTvttFPxWHetLFq0KC677LLVXm7fffeNzTbbrFWZJUuWxPXXXx9/+9vf4o033sjaOm7cuPj4xz8eKRFiIUCAAAECBAgQIECAAAECBAgQIECAAAECPSlQ8QTAySefHFOnTo377rsvttpqq+jXr1/x0//p5vj73//+rL133313pGTASy+9lG2PHDkyDjvssG63SMmKdCN/dUu6sd8yATBv3rw44YQT4oUXXshOe8973hN/+MMfsq977rknzjrrrOjbt+/qqnSMAAECBAgQIECAAAECBAgQIECAAAECBAh0qUDFEwA77LBD/OxnP4tjjz02li1bln2lFmy99dbx85//vNiYN998s3jzf/3118+O9cRN8xkzZmQxjR8/PvbYY49ifC1X0pMMLZdvfvOb2c3/HXfcMb7xjW/EOuusEy+++GKcfvrp8Ze//CV+8IMfxFe+8pWWp1gnQIAAAQIECBAgQIAAAQIECBAgQIAAAQLdKlDxBECKfvLkyZFuqN90000xa9as2G233bKhcdKN8sKy5ZZbxvDhw+OAAw6IU089tTh3QOF4d70WEgDp5v/EiRPXeNknn3wy7r///ujfv39861vfirXWWis7Z+ONN47vfe97MWnSpLj55pvjuOOOi5YTIa+xYgUIECBAgAABAgQIECBAgAABAgQIECBAgEAFBbokAZDi22abbbKv9mJ973vfmz0B0KtXRechbu9y7e5PQwClZcyYMe2WaXngT3/6U7a56667Fm/+F46noYA+9KEPxV//+tcsCdByvoNCGa8ECBAgQIAAAQIECBAgQIAAAQIECBAgQKA7BLr17vvChQuL8wE0NDRET9/8b2pqipkzZ0ZjY2OMHj06854/f36kCX7bW5544onsUBr+p60lJQDS8uijj7Z12D4CBAgQIECAAAECBAgQIECAAAECBAgQINAtAl32BECKfu7cuXH++efHAw88EGmonZdffjlOOeWU+M///M9saKAjjjgivvzlL2fD5vREMuD555/P5igYNWpUXHPNNXHDDTfEa6+9liUm0r7DDz889tlnn1Ydkcb6T8uQIUNa7S9sFPYXJggu7F/5NU2WnJINbS2f/exnIz1hYCFQTwItfwYMGDAgm0C8ntqvrQQIEOjdu3ekpwktBAh0XMD3TMetlKw9gfRBNt8DtdevWkSAQNsCLe8ZpCG3/fxr28leAm0JdEkCoLm5Of7rv/4rzjnnnJg3b15b143nnnsu7rrrruzrkEMOySYO7tOnT5tlu2pnYfz/f/zjH3H55ZfHeuutl81dkGJLX2my3wcffDCmTJlSDCE9xZCWwo3+4oH/Wxk8eHC2Vii38vHC9r333huvv/56YbPV6+677+7mZysRG/UmkP6YSV8WAgQI1JNAejqyX79+9dRkbSVQtoDvmbIJVVDFAulmmO+BKu5AoRMg0CmB9F65sKT7h37+FTS8ElizQJfcYfv+97+ffdI/XT7dxNt2223jrbfeisJ4+2l/Gn4nfcMuW7Ys+/R9mlQ33YTvzqUQT8ocnnfeeTFu3Ljs8imBkZ4GSO34/e9/HxMmTMgmMl6xYkW8/fbbWZn2JvgdNGhQdnx1wwh1ZxtdiwABAgQIECBAgAABAgQIECBAgAABAgTqU6DiCYDHHnssTjvttExz3333jYsvvjjScDonnXRS9lRAgXnvvfeOZ599Ng499NC48847sycAvvrVr3Z4Mt5CPeW8Tp48Ofbcc89YZ511YqONNipWlbKKkyZNyp4CSImAqVOnZgmA9AmLlKhYvHhxu/MEFG789+3bt1hfWyup3uXLl7d1KNL158yZ0+YxOwnUqsBaa60VhSdoFixYEIsWLarVpmoXAQIEWgmsv/762e/+9L4gDUVoIVBvAsOGDSu5yd4zl0znxCoVSH8rpt8baVm6dGm7T9xXafOETYAAgXYF0odyC0sabcR7gIKG13oRKOc9c8UTABdeeGF2c3z77beP6667Lrth3l5HjBw5Mm655ZYYMWJENhzOFVdcERdccEF7xSu+P32Kf6uttmq33r322it7EmDWrFmRftCkBEAaJiiN75+eaGhrKewfOHBgW4eL+zbYYIPi+sor6QdZSjJYCNSTQMtf5mm9vQRZPZloKwEC9SWQnkD0s6+++lxryxfwPVO+oRqqS6DlGNgpct8D1dV/oiVAoHSB9F65sLhnUJDwSqBjAr06VqzjpR5++OGscHoKIH1afk1LKpOeFEhLYUz+NZ3TXceHDx+eXSp9sqIwpn9KAKSlcKM/22jxT2Fi36FDh7bYa5UAAQIECBAgQIAAAQIECBAgQIAAAQIECHSvQEUTAOnTB0888UTWgvHjx3e4JR//+Mezsmky3u5c0hMKl1xySTbUT1vXnT17drY7DUtSGPO/8LjFzJkz2zolCvtX92RBmyfaSYAAAQIECBAgQIAAAQIECBAgQIAAAQIEKihQ0QRA7969ozAJ7ptvvtnhMOfOnZuVbTkOf4dPLqPgH//4x7j66qvjyiuvbLOWu+66K9u/9dZbF4+nOQPSks5deUmPIE2bNi3bXZhQeOUytgkQIECAAAECBAgQIECAAAECBAgQIECAQHcIVDQBkALebrvtsrhvv/32Dsef5gFIyzbbbNPhcypRcPfdd8+qSTft04TELZfp06dncxikfUcffXTx0IQJE2LTTTfNhiu6+eabi/vTSkompMn7Ntlkk9hxxx1bHbNBgAABAgQIECBAgAABAgQIECBAgAABAgS6U6DikwCnG9933HFHnHvuufHpT386Nttss9W256c//WkUbqR3Ztig1VbawYMHHnhg3HPPPfHQQw/F5z//+UjXT1/PPPNM1oZUzQknnBBjxowp1tjQ0BDHHntsnHnmmXHeeefFX//619h8883jsccey9b79OkTp556aqRyFgIECBAgQIAAAQIECBAgQIAAAQIECBAg0FMCFX8C4Gtf+1qMHDkymyT3Ax/4QDbGfmEs/ZaNfP755+OYY44pfrp+p512ikmTJrUs0uXraciiCy64ILv537dv30if+r/00kuzYXxGjBiRHTv44INXiWOXXXaJCy+8MDbYYIMsUZDOSYmA9GTAf/zHf8TYsWNXOccOAgQIECBAgAABAgQIECBAgAABAgQIECDQnQINze8slb5gegJgr732ijQmfmHp169fLFmyJDbccMNYtmxZvPrqq4VDMWDAgHjkkUfW+LRA8YQuWGlqaoqXXnop5s2bF6NHjy7OZbCmS6Uhf1544YVIkwOnhECvXuXnVFIMixcvXtOlHSdQUwL9+/ePIUOGZG2aP39+LFy4sKbapzEECBBoTyC9f0hPDqb3IoV5kdoraz+BWhRIfx+Uurz88sulnuo8AlUpkP7eHD58eBb70qVLsyFoq7IhgiZAgEAnBdJII4V5N6+66qrsw8edrEJxAlUtUM575vLvVrdBl8bWv/feeyONl19Y0s3/tKQ36S1v/qdJdf/2t7/16M3/FFdjY2OMGjUq+/R+YSLjtH9Ny7rrrhtpwt80gXElbv6v6XqOEyBAgAABAgQIECBAgAABAgQIECBAgACBjghUfA6AwkU/+MEPZuPrX3/99dnrjBkzsolz0wMHW2yxRTZufkoUTJw4sXCKVwIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBCAl2WAEjxpcfZ00S76ctCgAABAgQIECBAgAABAgQIECBAgAABAgQIdJ9AlwwBVEr4Dz/8cPzyl78s5VTnECBAgAABAgQIECBAgAABAgQIECBAgAABAisJVDQBsHz58li0aNFKl1j9ZprsdsqUKZGGDHrsscdWX9hRAgQIECBAgAABAgQIECBAgAABAgQIECBAoEMCZScAmpqa4pJLLskmwl1rrbUiTaA7evToOPHEE+PNN99cbRBp9u6xY8fG+eefH6keCwECBAgQIECAAAECBAgQIECAAAECBAgQIFAZgbISAAsWLIhPfOITcfzxx8cjjzyS3cRPk/zOmjUrLrroothqq63imWeeWSXSefPmxdFHHx177rlnq+Prr7/+KmXtIECAAAECBAgQIECAAAECBAgQIECAAAECBDovUFYC4IwzzojbbruteNV0Az99+r+wvPzyy/H5z38+VqxYUdgVTz/9dHzoQx+Kn/zkJ8V9G220UfzqV7+Kf/u3fyvus0KAAAECBAgQIECAAAECBAgQIECAAAECBAiULlByAiCN9X/xxRdnVx48eHBcf/31MWfOnHj22Wfjf//3f2O33XbLjt19991xww03ZOt/+MMfYsKECTFjxoxsu6GhIb7whS/Ek08+Gfvvv3+2zz8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA+QKNpVZx3333xbJly7LTzzrrrDjggAOKVW2++eZx7bXXxvbbbx8vvfRS9pTABhtsEPvtt1+kiYLTssUWW8QVV1wRO+20U/E8KwQIECBAgAABAgQIECBAgAABAgQIECBAgEBlBEp+AmDmzJnFCP71X/+1uF5YGTZsWBx77LHZ5q233hrHHXdcdvM/fer/5JNPzuYMcPO/oOWVAAECBAgQIECAAAECBAgQIECAAAECBAhUVqDkJwDefPPNLJI07v+gQYPajGq77bbL9qdJgdMyYMCAuO6667KJg7Md/iFAgAABAgQIECBAgAABAgQIECBAgAABAgS6RKDkBMCCBQuygIYPH95uYEOGDCke69+/f/z+978vzg1QPGCFAAECBAgQIECAAAECBAgQIECAAAECBAgQqLhAyUMANTc3Z8GkIX3aW/r161c8lIYAKkwMXNxphQABAgQIECBAgAABAgQIECBAgAABAgQIEOgSgZITAJ2NZuLEiZ09RXkCBAgQIECAAAECBAgQIECAAAECBAgQIECgRIFuSwAMHTq0xBCdRoAAAQIECBAgQIAAAQIECBAgQIAAAQIECHRWoNsSAL179+5sbMoTIECAAAECBAgQIECAAAECBAgQIECAAAECJQp0WwKgxPicRoAAAQIECBAgQIAAAQIECBAgQIAAAQIECJQg0FjCOa1OaWpqirlz57baV9h44403CquR1tsrVyg0cODAGDBgQGHTKwECBAgQIECAAAECBAgQIECAAAECBAgQIFCiQNkJgKeeeiqGDRu2xsvvuuuuayxz9tlnx1lnnbXGcgoQIECAAAECBAgQIECAAAECBAgQIECAAAECqxcwBNDqfRwlQIAAAQIECBAgQIAAAQIECBAgQIAAAQJVKVDyEwBjxoyJiRMnVrTRqU4LAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUL5AyQmAz33uc5G+LAQIECBAgAABAgQIECBAgAABAgQIECBAgED+BAwBlL8+EREBAgQIECBAgAABAgQIECBAgAABAgQIEChbQAKgbEIVECBAgAABAgQIECBAgAABAgQIECBAgACB/AlIAOSvT0REgAABAgQIECBAgAABAgQIECBAgAABAgTKFpAAKJtQBQQIECBAgAABAgQIECBAgAABAgQIECBAIH8CEgD56xMRESBAgAABAgQIECBAgAABAgQIECBAgACBsgUkAMomVAEBAgQIECBAgAABAgQIECBAgAABAgQIEMifgARA/vpERAQIECBAgAABAgQIECBAgAABAgQIECBAoGwBCYCyCVVAgAABAgQIECBAgAABAgQIECBAgAABAgTyJyABkL8+EREBAgQIECBAgAABAgQIECBAgAABAgQIEChbQAKgbEIVECBAgAABAgQIECBAgAABAgQIECBAgACB/AlIAOSvT0REgAABAgQIECBAgAABAgQIECBAgAABAgTKFpAAKJtQBQQIECBAgAABAgQIECBAgAABAgQIECBAIH8CEgD56xMRESBAgAABAgQIECBAgAABAgQIECBAgACBsgUkAMomVAEBAgQIECBAgAABAgQIECBAgAABAgQIEMifgARA/vpERAQIECBAgAABAgQIECBAgAABAgQIECBAoGwBCYCyCVVAgAABAgQIECBAgAABAgQIECBAgAABAgTyJyABkL8+EREBAgQIECBAgAABAgQIECBAgAABAgQIEChbQAKgbEIVECBAgAABAgQIECBAgAABAgQIECBAgACB/AlIAOSvT0REgAABAgQIECBAgAABAgQIECBAgAABAgTKFpAAKJtQBQQIECBAgAABAgQIECBAgAABAgQIECBAIH8CEgD56xMRESBAgAABAgQIECBAgAABAgQIECBAgACBsgUkAMomVAEBAgQIECBAgAABAgQIECBAgAABAgQIEMifgARA/vpERAQIECBAgAABAgQIECBAgAABAgQIECBAoGwBCYCyCVVAgAABAgQIECBAgAABAgQIECBAgAABAgTyJyABkL8+EREBAgQIECBAgAABAgQIECBAgAABAgQIEChbQAKgbEIVECBAgAABAgQIECBAgAABAgQIECBAgACB/AlIAOSvT0REgAABAgQIECBAgAABAgQIECBAgAABAgTKFpAAKJtQBQQIECBAgAABAgQIECBAgAABAgQIECBAIH8CEgD56xMRESBAgAABAgQIECBAgAABAgQIECBAgACBsgUkAMomVAEBAgQIECBAgAABAgQIECBAgAABAgQIEMifgARA/vpERAQIECBAgAABAgQIECBAgAABAgQIECBAoGwBCYCyCVVAgAABAgQIECBAgAABAgQIECBAgAABAgTyJyABkL8+EREBAgQIECBAgAABAgQIECBAgAABAgQIEChbQAKgbEIVECBAgAABAgQIECBAgAABAgQIECBAgACB/AlIAOSvT0REgAABAgQIECBAgAABAgQIECBAgAABAgTKFpAAKJtQBQQIECBAgAABAgQIECBAgAABAgQIECBAIH8CEgD56xMRESBAgAABAgQIECBAgAABAgQIECBAgACBsgUkAMomVAEBAgQIECBAgAABAgQIECBAgAABAgQIEMifQGP+QhIRAQIECBAgQIAAAQIECBAgQIAAAQIE/r/AkUceGZMmTco2hg8fjoUAgU4ISAB0AktRAgQIECBAgAABAgQIECBAgAABAgS6V2DbbbeN/v37ZxedO3duNDU1dW8ArkagigUMAVTFnSd0AgQIECBAgAABAgQIECBAgAABAgQIECDQnoAEQHsy9hMgQIAAAQIECBAgQIAAAQIECBAgQIAAgSoWkACo4s4TOgECBAgQIECAAAECBAgQIECAAAECBAgQaE9AAqA9GfsJECBAgAABAgQIECBAgAABAgQIECBAgEAVC0gAVHHnCZ0AAQIECBAgQIAAAQIECBAgQIAAAQIECLQnIAHQnoz9BAgQIECAAAECBAgQIECAAAECBAgQIECgigUkAKq484ROgAABAgQIECBAgAABAgQIECBAgAABAgTaE5AAaE/GfgIECBAgQIAAAQIECBAgQIAAAQIECBAgUMUCEgBV3HlCJ0CAAAECBAgQIECAAAECBAgQIECAAAEC7QlIALQnYz8BAgQIECBAgAABAgQIECBAgAABAgQIEKhiAQmAKu48oRMgQIAAAQIECBAgQIAAAQIECBAgQIAAgfYEJADak7GfAAECBAgQIECAAAECBAgQIECAAAECBAhUsYAEQBV3ntAJECBAgAABAgQIECBAgAABAgQIECBAgEB7AhIA7cnYT4AAAQIECBAgQIAAAQIECBAgQIAAAQIEqlhAAqCKO0/oBAgQIECAAAECBAgQIECAAAECBAgQIECgPYHG9g7Y33MCvXr1ikGDBvVcAK5MoAcE+vTpU7xq3759o6GhobhthQABAvUg4Pd/PfSyNlZawHvmSouqL+8CLd8j+72R994SHwEClRRobHz3FuaAAQNixYoVlaxeXQRqWqCh+Z2lpltYhY1buHBh9O/fvwojFzKB8gTSHzFp8Yu8PEdnEyBQXQLpZk76Sm/JvC2rrr4TbWUECr//S6nNe4ZS1JxT7QKF7xm/N6q9J8VPgEBnBArvmdM5fv93Rk7ZWhEo/P4vpT3vps9KOds5XSKwbNmymD9/fpfUrVICeRVISa8hQ4Zk4S1YsCBSIsxCgACBehDYYIMNsmYuX7485s6dWw9N1kYCrQQ23HDDVtud2Zg9e3ZniitLoOoF0h//w4cPz9qR/m587bXXqr5NGkCAAIGOCKT7BYUPy6affU1NTR05TRkCNSNQzntmcwDUzH8DDSFAgAABAgQIECBAgAABAgQIECBAgAABAu8KeALgXQtrBAgQIECAAIFuF3jiiSeya/bu3bv4JFS3B+GCBAgQIECAAAECBAgQIFCTAhIANdmtGkWAAAECBAhUi8BBBx0UafifESNGxNSpU6slbHESIECAAAECBAgQIECAQBUIGAKoCjpJiAQIECBAgAABAgQIECBAgAABAgQIECBAoLMCEgCdFVOeAAECBAgQIECAAAECBAgQIECAAAECBAhUgYAEQBV0khAJECBAgAABAgQIECBAgAABAgQIECBAgEBnBSQAOiumPAECBAgQIECAAAECBAgQIECAAAECBAgQqAIBCYAq6CQhEiBAgAABAgQIECBAgAABAgQIECBAgACBzgpIAHRWTHkCBAgQIECAAAECBAgQIECAAAECBAgQIFAFAhIAVdBJQiRAgAABAgQIECBAgAABAgQIECBAgAABAp0VkADorJjyBAgQIECAAAECBAgQIECAAAECBAgQIECgCgQkAKqgk4RIgAABAgQIECBAgAABAgQIECBAgAABAgQ6KyAB0Fkx5QkQIECAAAECBAgQIECAAAECBAgQIECAQBUISABUQScJkQABAgQIECBAgAABAgQIECBAgAABAgQIdFZAAqCzYsoTIECAAAECBAgQIECAAAECBAgQIECAAIEqEJAAqIJOEiIBAgQIECBAgAABAgQIECBAgAABAgQIEOisgARAZ8WUJ0CAAAECBAgQIECAAAECBAgQIECAAAECVSAgAVAFnSREAgQIECBAgAABAgQIECBAgAABAgQIECDQWQEJgM6KKU+AAAECBAgQIECAAAECBAgQIECAAAECBKpAQAKgCjpJiAQIECBAgAABAgQIECBAgAABAgQIECBAoLMCEgCdFVOeAAECBAgQIECAAAECBAgQIECAAAECBAhUgYAEQBV0khAJECBAgAABAgQIECBAgAABAgQIECBAgEBnBSQAOiumPAECBAgQIECAAAECBAgQIECAAAECBAgQqAIBCYAq6CQhEiBAgAABAgQIECBAgAABAgQIECBAgACBzgpIAHRWTHkCBAgQIECAAAECBAgQIECAAAECBAgQIFAFAhIAVdBJQiRAgAABAgQIECBAgAABAgQIECBAgAABAp0VkADorJjyBAgQIECAAAECBAgQIECAAAECBAgQIECgCgQkAKqgk4RIgAABAgQIECBAgAABAgQIECBAgAABAgQ6KyAB0Fkx5QkQIECAAAECBAgQIECAAAECBAgQIECAQBUISABUQScJkQABAgQIECBAgAABAgQIECBAgAABAgQIdFZAAqCzYsoTIECAAAECBAgQIECAAAECBAgQIECAAIEqEJAAqIJOEiIBAgQIECBAgAABAgQIECBAgAABAgQIEOisgARAZ8WUJ0CAAAECBAgQIECAAAECBAgQIECAAAECVSAgAVAFnSREAgQIECBAgAABAgQIECBAgAABAgQIECDQWQEJgM6KKU+AAAECBAgQIECAAAECBAgQIECAAAECBKpAQAKgCjpJiAQIECBAgAABAgQIECBAgAABAgQIECBAoLMCEgCdFVOeAAECBAgQIECAAAECBAgQIECAAAECBAhUgYAEQBV0khAJECBAgAABAgQIECBAgAABAgQIECBAgEBnBSQAOiumPAECBAgQIECAAAECBAgQIECAAAECBAgQqAIBCYAq6CQhEiBAgAABAgQIECBAgAABAgQIECBAgACBzgpIAHRWTHkCBAgQIECAAAECBAgQIECAAAECBAgQIFAFAhIAVdBJQiRAgAABAgQIECBAgAABAgQIECBAgAABAp0VkADorJjyBAgQIECAAAECBAgQIECAAAECBAgQIECgCgQkAKqgk4RIgAABAgQIECBAgAABAgQIECBAgAABAgQ6KyAB0Fkx5QkQIECAAAECBAgQIECAAAECBAgQIECAQBUISABUQScJkQABAgQIECBAgAABAgQIicLYigAANExJREFUECBAgAABAgQIdFZAAqCzYsoTIECAAAECBAgQIECAAAECBAgQIECAAIEqEJAAqIJOEiIBAgQIECBAgAABAgQIECBAgAABAgQIEOisgARAZ8WUJ0CAAAECBAgQIECAAAECBAgQIECAAAECVSAgAVAFnSREAgQIECBAgAABAgQIECBAgAABAgQIECDQWQEJgM6KKU+AAAECBAgQIECAAAECBAgQIECAAAECBKpAoLEKYhQiAQIECBAgQIAAAQIECBCoe4Hm5uaYN29e5pDWLQQIECBAgACBNQl4AmBNQo4TIECAAAECBAgQIECAAIEcCLz55pux4447Zl/HH398DiISAgECBAgQIJB3AQmAvPeQ+AgQIECAAAECBAgQIECAAAECBAgQIECAQAkCEgAloDmFAAECBAgQIECAAAECBAgQIECAAAECBAjkXUACIO89JD4CBAgQIECAAAECBAgQIECAAAECBAgQIFCCgARACWhOIUCAAAECBAgQIECAAAECBAgQIECAAAECeReQAMh7D4mPAAECBAgQIECAAAECBAgQIECAAAECBAiUICABUAKaUwgQIECAAAECBAgQIECAAAECBAgQIECAQN4FJADy3kPiI0CAAAECBAgQIECAAAECBAgQIECAAAECJQhIAJSA5hQCBAgQIECAAAECBAgQIECAAAECBAgQIJB3AQmAvPeQ+AgQIECAAAECBAgQIECAAAECBAgQIECAQAkCEgAloDmFAAECBAgQIECAAAECBAgQIECAAAECBAjkXUACIO89JD4CBAgQIECAAAECBAgQIECAAAECBAgQIFCCQGMJ5ziFAAECBAgQ6GaBV155JRYvXtzNV3W57hBobm7OLrNs2bKYNWtWd1zSNbpZYO2114711luvm6/qcgQIECBAgAABAgQIEIiQAPC/gAABAgQI5FzgmmuuiUsvvTTnUQqvXIHZs2fHkUceWW41zs+pwOmnnx577713TqMTFgECBAgQIECAAAECtSpgCKBa7VntIkCAAIGaEbjvvvtqpi0aQqBeBR544IF6bbp2EyBAgAABAgQIECDQgwKeAOhBfJcmQIAAAQIdEVixYkWx2G677RZ9+/YtblshQCC/AvPnz4977703C7Dl93F+IxYZAQIECBAgQIAAAQK1JiABUGs9qj0ECBAgUNMC5513Xqy77ro13UaNI1ArAo899lh85jOfqZXmaAcBAgQIECBAgAABAlUoYAigKuw0IRMgQIAAAQIECBAgQIAAAQIECBAgQIAAgTUJSACsSchxAgQIECBAgAABAgQIECBAgAABAgQIECBQhQISAFXYaUImQIAAAQIECBAgQIAAAQIECBAgQIAAAQJrEpAAWJOQ4wQIECBAgAABAgQIECBAgAABAgQIECBAoAoFJACqsNOETIAAAQIECBAgQIAAAQIECBAgQIAAAQIE1iQgAbAmIccJECBAgAABAgQIECBAgAABAgQIECBAgEAVCkgAVGGnCZkAAQIECBAgQIAAAQIECBAgQIAAAQIECKxJQAJgTUKOEyBAgAABAgQIECBAgAABAgQIECBAgACBKhSQAKjCThMyAQIECBAgQIAAAQIECBAgQIAAAQIECBBYk4AEwJqEHCdAgAABAgQIECBAgAABAgQIECBAgAABAlUoIAFQhZ0mZAIECBAgQIAAAQIECBAgQIAAAQIECBAgsCaBxjUVqIfjr732WvziF7+IZ599NmbPnh3Dhg2L9773vfHZz3421l9//VUIFi1aFJdddtkq+1vu2HfffWOzzTZrucs6AQIECBAgQIAAAQIECBAgQIAAAQIECBDoNoG6TwD86U9/ivPOOy8WL14cvXv3jnXXXTemT58e999/f/z2t7+Nr33ta7Hnnnu26pBnnnkmrr/++lb7Vt4YN26cBMDKKLYJECBAgAABAgQIECBAgAABAgQIECBAoNsE6joB8OKLLxZv/h955JFx6KGHRr9+/WLJkiXxP//zP9nXd77zndhiiy1i5MiRxU6ZMWNGtj5+/PjYY489ivtbrmy++eYtN60TIECAAAECBAgQIECAAAECBAgQIECAAIFuFajrBMCNN96YffJ/r732iqOOOqoIn5IAxx57bPzjH/+I9IRAKnfCCScUjxcSAOnm/8SJE4v7rRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgbwI1PUkwA899FDWDzvvvHOb/bHjjjtm+9OQPy2XwvaYMWNa7rZOgAABAgQIECBAgAABAgQIECBAgAABAgRyI1DXTwD84Ac/iDQB8JAhQ9rskNdffz3b3/J4U1NTzJw5MxobG2P06NHZ8fnz52dDB6UnBywECBAgQIAAAQIECBAgQIAAAQIECBAgQCAPAnWdAEg37DfaaKM2+yHd6L/55puzY1tvvXWxzPPPPx/Lli2LUaNGxTXXXBM33HBDlkTo1atXtu/www+PffbZp1i+vZUpU6bEW2+91ebhSZMmxUc/+tE2j9lJoFYF0iTchaV///7Rt2/fwqZXAnUvkJLOFgIEqlsg/V4bOnRodTcih9EzzWGnCKlLBZqbm4v1NzQ0+LlS1LBCgECtC/Tp06fYxMGDB0fLn4fFA1YIEGhTwB2FNlki/vu//zv++c9/xsYbbxz77rtvsVRh/P80P8Dll18e6623XqTJgJ977rns65vf/GY8+OCDkW7wr27585//HIUnDFYu9+EPfzjWWmutlXfbJlA3AukXe8tf7nXTcA0l0I5ASjJbCBCoboGU6Pb+rvJ9yLTypmrMt0DL//MpAdByO9+Ri44AAQKVEzACR+Us1VQfAhIAbfTzz3/+80hf6YbL17/+9VZvqgrj/6+99tpx3nnnxbhx47IaUuYxPQ3w/e9/P37/+9/HhAkTYrfddmujdrsIECBAgAABAgQIECBAgAABAgQIECBAgEDXC0gArGR86aWXxlVXXZXd/D/jjDNi7NixrUpMnjw59txzz1hnnXVaDR+UPn2Rhu5JTwKkRMDUqVNXmwBICYY0zFBbS8pkzpkzp61D9hGoWYH06aX0GF9aFixYEIsWLarZtmoYgc4KpKHnLAQIVLfA22+/7f1dO104bNiwdo6sebf3zGs2UqK2BObNm1ds0IoVK/xcKWpYIUCg1gXS/YLCU09pPs/ly5fXepO1j0ArgXLeM0sA/B9lurnyne98J2699dZs7PEzzzwzdt1111bQaSN98n+rrbZaZX9hx1577ZUlAGbNmhXpDVl7wzZssskmhVNWeU1v6hYvXrzKfjsI1LJA+n4pLGndL/OChlcCYXxL/wkI1IBAelrU77bKdyTTypuqMd8CK4957Xsg3/0lOgIEKifQ8uefewaVc1VTfQhIALzTz2ky3tNPPz0eeuih7BPIKRGw7bbblvQ/YPjw4dl5S5cujYULF2YJg5IqchIBAgQIECBAgAABAgQIECBAgAABAgQIEChDoO4TAPPnz48vfelL8eyzz8aIESPiggsuiJEjR7ZLet1110V61OjjH/94bLrppquUmz17drYvPZqUnhawECBAgAABAgQIECBAgAABAgQIECBAgACBnhDo1RMXzcs10+NDU6ZMyW7+jxkzJi655JLV3vxPcf/xj3+Mq6++Oq688so2m3HXXXdl+7feeus2j9tJgAABAgQIECBAgAABAgQIECBAgAABAgS6Q6CuEwA33nhjPPbYY7HeeuvFd7/73Wxi3zWh77777lmRadOmZYmDluWnT58e6QmBtBx99NEtD1knQIAAAQIECBAgQIAAAQIECBAgQIAAAQLdKlC3QwAtWbIk+8R/0n711Vdj//33bxd+s802i8svvzw7fuCBB8Y999yTzRfw+c9/PsaPH599PfPMM3HHHXdkZU444YRITxRYCBAgQIAAAQIECBAgQIAAAQIECBAgQIBATwnUbQJg1qxZ2eS/Bfjly5cXVld5bWpqKu7r3bt3Nk9AGgbommuuifSp//SVljR3QJpPYMKECcXyVggQIECAAAECBAgQIECAAAECBAgQIECAQE8I1G0CYMstt4w777yzJPO11lorG+Jn8uTJ8dJLL8W8efNi9OjRMWjQoJLqcxIBAgQIECBAgAABAgQIECBAgAABAgQIEKi0QN0mACoB2djYGKNGjcq+KlGfOggQIECAAAECBAgQIECAAAECBAgQIECAQKUE6noS4EohqocAAQIECBAgQIAAAQIECBAgQIAAAQIECORNwBMAeesR8RAgQIAAAQIECBAgQKAMgcWLF8d9990XS5YsKaMWp+ZR4O233y6G9frrr8ctt9xS3LZSOwLrr79+7LDDDrXTIC0hQIAAgR4VkADoUX4XJ0CAAAECBAgQIECAQGUFvv3tb8ddd91V2UrVljuB559/Pv793/89d3EJqDICp512WnzsYx+rTGVqIUCAAIG6FjAEUF13v8YTIECAAAECBAgQIFBrAjNnzqy1JmkPgboTmDVrVt21WYMJECBAoGsEPAHQNa5qJUCAAAECBAgQIECAQI8LnHTSST0egwAIEOiYQEre/fa3v+1YYaUIECBAgEAHBSQAOgilGAECBAgQIECAAAECBKpJoFevXnH88cdXU8hiJVDXArfffrsEQF3/D9B4AgQIdI2AIYC6xlWtBAgQIECAAAECBAgQIECAAAECBAgQIECgRwUkAHqU38UJECBAgAABAgQIECBAgAABAgQIECBAgEDXCEgAdI2rWgkQIECAAAECBAgQIECAAAECBAgQIECAQI8KSAD0KL+LEyBAgAABAgQIECBAgAABAgQIECBAgACBrhGQAOgaV7USIECAAAECBAgQIECAAAECBAgQIECAAIEeFZAA6FF+FydAgAABAgQIECBAgAABAgQIECBAgAABAl0jIAHQNa5qJUCAAAECBAgQIECAAAECBAgQIECAAAECPSogAdCj/C5OgAABAgQIECBAgAABAgQIECBAgAABAgS6RqCxa6pVKwECBAgQINAVAlOnTo0BAwZ0RdXqJECgwgKvvPJKhWtUHQECBAgQIECAAAECBDonIAHQOS+lCRAgQIBAjwpcfPHFPXp9FydAgAABAgQIECBAgAABAgSqR8AQQNXTVyIlQIAAAQIECBAgQIAAAQIECBAgQIAAAQIdFpAA6DCVggQIECBAgAABAgQIECBAgAABAgQIECBAoHoEJACqp69ESoAAAQIECBAgQIAAAQIECBAgQIAAAQIEOiwgAdBhKgUJECBAgAABAgQIECBAgAABAgQIECBAgED1CJgEuHr6SqQECBAgQCAuueSSWGeddUgQIFAFAs8++2ycccYZVRCpEAkQIECAAAECBAgQqFUBCYBa7VntIkCAAIGaFBg7dmysu+66Ndk2jSJQawJ9+vSptSZpT5UJNDc3x7Rp06osauESqF+BRx99tH4br+UECBAg0GUCEgBdRqtiAgQIECBAgAABAgQI9JxASgAcf/zxPReAKxMgQIAAAQIECPS4gDkAerwLBECAAAECBAgQIECAAAECBAgQIECAAAECBCovIAFQeVM1EiBAgAABAgQIECBAgAABAgQIECBAgACBHheQAOjxLhAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCovIAEQOVN1UiAAAECBAgQIECAAAECBAgQIECAAAECBHpcwCTAPd4FAiBAgAABAgQIECBAgEDlBRoaGuKb3/xm5StWIwECXSLw1FNPxdVXX90ldauUAAECBOpXQAKgfvteywkQIECAAAECBAgQqGGBlAA48MADa7iFmkagtgRuv/12CYDa6lKtIUCAQC4EDAGUi24QBAECBAgQIECAAAECBAgQIECAAAECBAgQqKyABEBlPdVGgAABAgQIECBAgAABAgQIECBAgAABAgRyISABkItuEAQBAgQIECBAgAABAgQIECBAgAABAgQIEKisgARAZT3VRoAAAQIECBAgQIAAAQIECBAgQIAAAQIEciEgAZCLbhAEAQIECBAgQIAAAQIECBAgQIAAAQIECBCorIAEQGU91UaAAAECBAgQIECAAAECBAgQIECAAAECBHIhIAGQi24QBAECBAgQIECAAAECBAgQIECAAAECBAgQqKyABEBlPdVGgAABAgQIECBAgAABAgQIECBAgAABAgRyISABkItuEAQBAgQIECBAgAABAgQIECBAgAABAgQIEKisgARAZT3VRoAAAQIECBAgQIAAAQIECBAgQIAAAQIEciEgAZCLbhAEAQIECBAgQIAAAQIECBAgQIAAAQIECBCorIAEQGU91UaAAAECBAgQIECAAAECBAgQIECAAAECBHIhIAGQi24QBAECBAgQIECAAAECBAgQIECAAAECBAgQqKyABEBlPdVGgAABAgQIECBAgAABAgQIECBAgAABAgRyISABkItuEAQBAgQIECBAgAABAgQIECBAgAABAgQIEKisgARAZT3VRoAAAQIECBAgQIAAAQIECBAgQIAAAQIEciEgAZCLbhAEAQIECBAgQIAAAQIECBAgQIAAAQIECBCorIAEQGU91UaAAAECBAgQIECAAAECBAgQIECAAAECBHIhIAGQi24QBAECBAgQIECAAAECBAgQIECAAAECBAgQqKyABEBlPdVGgAABAgQIECBAgAABAgQIECBAgAABAgRyISABkItuEAQBAgQIECBAgAABAgQIECBAgAABAgQIEKisgARAZT3VRoAAAQIECBAgQIAAAQIECBAgQIAAAQIEciEgAZCLbhAEAQIECBAgQIAAAQIECBAgQIAAAQIECBCorIAEQGU91UaAAAECBAgQIECAAAECBAgQIECAAAECBHIhIAGQi24QBAECBAgQIECAAAECBAgQIECAAAECBAgQqKyABEBlPdVGgAABAgQIECBAgAABAgQIECBAgAABAgRyISABkItuEAQBAgQIECBAgAABAgQIECBAgAABAgQIEKisgARAZT3VRoAAAQIECBAgQIAAAQIECBAgQIAAAQIEciEgAZCLbhAEAQIECBAgQIAAAQIECBAgQIAAAQIECBCorIAEQGU91UaAAAECBAgQIECAAAECBAgQIECAAAECBHIhIAGQi24QBAECBAgQIECAAAECBAgQIECAAAECBAgQqKyABEBlPdVGgAABAgQIECBAgAABAgQIECBAgAABAgRyISABkItuEAQBAgQIECBAgAABAgQIECBAgAABAgQIEKisgARAZT3VRoAAAQIECBAgQIAAAQIECBAgQIAAAQIEciEgAZCLbhAEAQIECBAgQIAAAQIECBAgQIAAAQIECBCorIAEQGU91UaAAAECBAgQIECAAAECBAgQIECAAAECBHIhIAGQi24QBAECBAgQIECAAAECBAgQIECAAAECBAgQqKxAY2WrUxsBAgQIECDQlQL77rtvNDQ0dOUl1E2AQIUEmpqaKlSTaggQIECAAAECBAgQIFCagARAaW7OIkCAAAEC3SbQp0+f4rXeeOON4roVAgSqR6Dl93H1RC1SAgQIECBAgAABAgSqXUACoNp7UPwECBAgUPMCBxxwQLzwwguxePHimm9rPTZwwYIFWbPTkx0DBw6sR4Kab/PgwYNjv/32q/l2aiABAgQIECBAgAABAvkTkADIX5+IiAABAgQItBL46Ec/GunLUpsCe+65Zyxfvjw23njjmDp1am02UqsIECBAgAABAgQIECBAoEcETALcI+wuSoAAAQIECBAgQIAAAQIECBAgQIAAAQIEulZAAqBrfdVOgAABAgQIECBAgAABAgQIECBAgAABAgR6REACoEfYXZQAAQIECBAgQIAAAQIECBAgQIAAAQIECHStgDkAutZX7QQIECBAgAABAgQIEOgRgRUrVsRhhx3WI9d2UQIEOi8wb968zp/kDAIECBAgsAYBCYA1ADlMgAABAgQIECBAgACBahLo1evdB70feOCBagpdrAQI/J9Ay+9jKAQIECBAoByBd98ZllOLcwkQIECAAAECBAgQIEAgFwJ77LFHLuIQBAECpQn069cvPvzhD5d2srMIECBAgMBKAp4AWAnEJgECBAgQIECAAAECBKpZ4KijjooDDzwwli5dWs3NEHsbAgsWLIjJkydnR7bZZps455xz2ihlV7ULDBo0KFISwEKAAAECBCohIAFQCcUK15Ee9Rs4cGCFa1UdgXwL9OnTpxhg3759i+tWCBAgUE8Cfv/XU29rayUEfM+0r8imfZtqPtJyjPj0nnnUqFHV3ByxEyBAoMMCjY3v3sLs379/pHluLAQIdEzg3e+ejpVXqhsEevfuHQMGDOiGK7kEgXwKpE+7+MRLPvtGVAQIdK3A2muv3bUXUDuBGhPwPVNjHao5axRYtmxZqzK+B1px2CBAoE4EJLnrpKM1s2ICEgAVo6xcRelN3SuvvFK5CtVEoAoEUgZ/yJAhWaRvvfVWLFy4sAqiFiIBAgQqK+D3f2U91VYdAhtuuGHJgfqeKZnOiVUqMH/+/GLkzc3N/m4salghQKDWBdL9gnTfIC2vvvpqNDU11XqTtY9AK4Fy3jObBLgVpQ0CBAgQIECAAAECBAgQIECAAAECBAgQIFAbAhIAtdGPWkGAAAECBAgQIECAAAECBAgQIECAAAECBFoJSAC04rBBgAABAgQIECBAgAABAgQIECBAgAABAgRqQ0ACoDb6USsIECBAgAABAgQIECBAgAABAgQIECBAgEArAQmAVhw2CBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQhIANRGP2oFAQIECBAgQIAAAQIECBAgQIAAAQIECBBoJSAB0IrDBgECBAgQIECAAAECBAgQIECAAAECBAgQqA0BCYDa6EetIECAAAECBAgQIECAAAECBAgQIECAAAECrQQkAFpx2CBAgAABAgQIECBAgAABAvkXaGhoyH+QIiRAgAABAgR6XKCxxyMQAAECBAgQIECAAAECBAgQILBGgSFDhsTf//73rNzSpUvjtddeW+M5ChAgQIAAAQL1LeAJgPruf60nQIAAAQIECBAgQIAAAQIECBAgQIAAgRoVkACo0Y7VLAIECBAgQIAAAQIECBAgQIAAAQIECBCobwEJgPruf60nQIAAAQIECBAgQIAAAQIECBAgQIAAgRoVkACo0Y7VLAIECBAgQIAAAQIECBAgQIAAAQIECBCobwEJgPruf60nQIAAAQIECBAgQIAAAQIECBAgQIAAgRoVkACo0Y7VLAIECBAgQIAAAQIECBAgQIAAAQIECBCob4HG+m6+1hMgQIAAAQIEelbgxhtvzALo1cvnMnq2J1ydAAECBAgQIECAAAECtScgAVB7fapFBAgQIECAQBUJjB49OhoaGqKpqSnmzp1bRZELlQABAgQIECBAgAABAgTyLuCjZnnvIfERIECAAAECBAgQIECAAAECBAgQIECAAIESBCQASkBzCgECBAgQIECAAAECBAgQIECAAAECBAgQyLuABEDee0h8BAgQIECAAAECBAgQIECAAAECBAgQIECgBAEJgBLQnEKAAAECBAgQIECAAAECBAgQIECAAAECBPIuIAGQ9x4SHwECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAqAENKcQIECAAAECBAgQIECAAAECBAgQIECAAIG8C0gA5L2HxEeAAAECBAgQIECAAAECBAgQIECAAAECBEoQkAAoAc0pBAgQIECAAAECBAgQIECAAAECBAgQIEAg7wISAHnvIfERIECAAAECBAgQIECAAAECBAgQIECAAIESBCQASkBzCgECBAgQIECAAAECBAgQIECAAAECBAgQyLuABEDee0h8BAgQIECAAAECBAgQIECAAAECBAgQIECgBAEJgBLQnEKAAAECBAgQIECAAAECBAgQIECAAAECBPIuIAGQ9x4SHwECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAqAENKcQIECAAAECBAgQIECAAAECBAgQIECAAIG8C0gA5L2HxEeAAAECBAgQIECAAAECBAgQIECAAAECBEoQkAAoAc0pBAgQIECAAAECBAgQIECAAAECBAgQIEAg7wISAHnvIfERIECAAAECBAgQIECAAAECBAgQIECAAIESBCQASkBzCgECBAgQIECAAAECBAgQIECAAAECBAgQyLuABEDee0h8BAgQIECAAAECBAgQIECAAAECBAgQIECgBAEJgBLQnEKAAAECBAgQIECAAAECBAgQIECAAAECBPIuIAGQ9x4SHwECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAqAENKcQIECAAAECBAgQIECAAAECBAgQIECAAIG8C0gA5L2HxEeAAAECBAgQIECAAAECBAgQIECAAAECBEoQkAAoAc0pBAgQIECAAAECBAgQIECAAAECBAgQIEAg7wISAHnvIfERIECAAAECBAgQIECAAAECBAgQIECAAIESBCQASkBzCgECBAgQIECAAAECBAgQIECAAAECBAgQyLuABEDee0h8BAgQIECAAAECBAgQIECAAAECBAgQIECgBAEJgBLQnEKAAAECBAgQIECAAAECBAgQIECAAAECBPIuIAGQ9x4SHwECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAqAENKcQIECAAAECBAgQIECAAAECBAgQIECAAIG8CzQ0v7PkPch6jE+31GOv13ebf/WrX8VZZ52VIZxyyilx5JFH1jeI1hMgUDcC48aNi+XLl8eIESPi5ptvrpt2ayiBgkBDQ0NhtdOv3jN3mswJVS7wxhtvxC677JK1Yocddogrr7yyylskfAIECHRM4OSTT44//vGPWeFf//rX8b73va9jJypFoEYEynnP3FgjBjXXjHI6teYwNKguBFasWBHLli3L2prWfQ/URbdrJAEC7wikn30pAZBe/ezzX4JA5wR8z3TOS+naECi8Z25qavJ7oza6VCsIEOiAQPqZV/j5l4p7D9ABNEUI/J+AIYD8VyBAgAABAgQIECBAgAABAgQIECBAgAABAjUoIAFQg52qSQQIECBAgAABAgQIECBAgAABAgQIECBAQALA/wECBAgQIECAAAECBAgQIECAAAECBAgQIFCDAhIANdipmkSAAAECBAgQIECAAAECBAgQIECAAAECBCQA/B8gQIAAAQIECBAgQIAAAQIECBAgQIAAAQI1KNDQ/M5Sg+3SJAIEqkzgn//8Zzz++ONZ1GPGjIn3vve9VdYC4RIgQKA0gVtvvTVWrFgRAwYMiF122aW0SpxFgAABAnUhsHTp0pg2bVrW1qFDh8aOO+5YF+3WSAIECDz88MPxyiuvZBA77bRTDBo0CAoBAh0UkADoIJRiBAgQIECAAAECBAgQIECAAAECBAgQIECgmgQMAVRNvSVWAgQIECBAgAABAgQIECBAgAABAgQIECDQQQEJgA5CKUaAAAECBAgQIECAAAECBAgQIECAAAECBKpJQAKgmnpLrAQIECBAgAABAgQIECBAgAABAgQIECBAoIMCEgAdhFKMAIHuE2hqaoply5Z13wVdiQABAgQIECBAgEAVCixevLgKoxYyAQIECBAg0J0Cjd15MdciQIDA6gQefPDB+OlPfxpPPvlkLF26ND7ykY/E+eefv7pTHCNAgAABAgQIECBQVwLpwzI/+MEP4t57742XX345+vbtGxdeeGGMHTu2rhw0lgABAgQIEOiYgARAx5yUIkCgiwXmzJkTZ5xxRrz11lvRu3fvGDVqVGyyySZdfFXVEyBAgAABAgQIEKgugUsvvTRuuOGGLOh11103+vTpExtvvHF1NUK0BAgQIECAQLcJSAB0G7ULESCwOoHHH388u/n/nve8J6ZOnRprr7326oo7RoAAAQIECBAgQKAuBe65556s3V/4whfikEMOiYaGhrp00GgCBAgQIECgYwLmAOiYk1IECHSxwNy5c7MrbL/99m7+d7G16gkQIECAAAECBKpXoPC+eeedd3bzv3q7UeQECBAgQKDbBDwB0G3ULkSAQFsCixYtitmzZ0fhD5nm5uaYNWtW9sfMpptu2tYp9hEgQKDqBJ577rno1atXNrxZ+jmXtp966qlIP+fGjBmTDX1WaFT6mfjQQw9Fv3794v3vf38MHz68cMgrAQIECNSxwEsvvRRLliyJNAdAWl5//fVYvnx5pCdo11lnnTqW0XQCBGpFwHvmWulJ7cibQMM7f4Q25y0o8RAgUD8CafKyr371q6s0OE1mdvvtt6+y3w4CBAhUo8A+++wTAwcOjIsuuihOOeWUePHFF4vNGDx4cPz4xz/ObvSfeeaZURjaIRVIPwu/9KUvxac+9alieSsECBAgUJ8Cxx13XDz55JOrND4NBXTooYeust8OAgQIVJuA98zV1mPirRYBCYBq6SlxEqhRgVdeeSXuvPPOmD59etx9992x7bbbxu677559GnbSpEk12mrNIkCg3gTSHzNpGTBgQPTv37/4c+7GG2+M1157LXsSIH2Cc+bMmbH//vvHkCFD4i9/+Uv2szFN7nj11VfHhhtuWG9s2kuAAAECLQTSh2PSp/5TMjl98v+YY47Jfq+MHTs2e5qsRVGrBAgQqEoB75mrstsEXQUCEgBV0ElCJFAPAtdcc032Cdj0KdevfOUr9dBkbSRAoI4E0h8zixcvzj7lf/nll2c3+FPz58yZEwcccEAmMWjQoGwS9HXXXTfbTkM8pJs7zz77bEyZMiX23XffbL9/CBAgQKC+Bfbaa69sKKDf/OY32fA/9a2h9QQI1JKA98y11JvakicBkwDnqTfEQoAAAQIECNS0wBFHHFG8+Z8aOmzYsOIn+/fbb78o3PxPxxobG2PLLbdMq5GelrIQIECAAAECBAgQqAcB75nroZe1sTsFJAC6U9u1CBAgQIAAgboW2GijjVZp/4gRI7J9I0eOXOVYGhYoLUuXLl3lmB0ECBAgQIAAAQIEalHAe+Za7FVt6kkBCYCe1HdtAgQIECBAoK4E2hrHv6GhITNIQwCtvBSOFV5XPm6bAAECBAgQIECAQK0JeM9caz2qPT0tIAHQ0z3g+gQIECBAgEDdCPTt23eVtjY3N6+yb+UdHSmz8jm2CRAgQIAAAQIECFSjgPfM1dhrYs6zgARAnntHbAQIECBAgAABAgQIECBAgAABAgQIECBAoEQBCYAS4ZxGgAABAgQIECBAgAABAgQIECBAgAABAgTyLCABkOfeERsBAgQIECBAgAABAgQIECBAgAABAgQIEChRQAKgRDinESBAgAABAgQIECBAgAABAgQIECBAgACBPAtIAOS5d8RGgAABAgQIECBAgAABAgQIECBAgAABAgRKFGhofmcp8VynESBAgAABAgQIECBAgAABAgQIECBAgAABAjkV8ARATjtGWAQIECBAgAABAgQIECBAgAABAgQIECBAoBwBCYBy9JxLgAABAgQIECBAgAABAgQIECBAgAABAgRyKiABkNOOERYBAgQIECBAgAABAgQIECBAgAABAgQIEChHQAKgHD3nEiBAgAABAgQIECBAgAABAgQIECBAgACBnApIAOS0Y4RFgAABAgQIECBAgAABAgQIECBAgAABAgTKEZAAKEfPuQQIECBAgAABAgQIECBAgAABAgQIECBAIKcCEgA57RhhESBAgAABAgQIECBAgAABAgQIECBAgACBcgQkAMrRcy4BAgQIECBAgAABAgQIECBAgAABAgQIEMipgARATjtGWAQIECBAgAABAgQIECBAgAABAgQIECBAoBwBCYBy9JxLgAABAgQIECBAgAABAgQIECBAgAABAgRyKiABkNOOERYBAgQIECBAgAABAgQIECBAgAABAgQIEChHQAKgHD3nEiBAgAABAgQIECBAgAABAgQIECBAgACBnApIAOS0Y4RFgAABAgQIECBAgAABAgQIECBAgAABAgTKEZAAKEfPuQQIECBAgAABAgQIECBAgAABAgQIECBAIKcCEgA57RhhESBAgAABAgQIECBAgAABAgQIECBAgACBcgQkAMrRcy4BAgQIECBAgAABAgQIECBAgAABAgQIEMipgARATjtGWAQIECBAgAABAgQIECBAgAABAgQIECBAoByBxnJOdi4BAgQIECBAgAABAgRaCixdujTuuOOOmDFjRsyePTtGjx4d73//+7Ovtddeu2XRNtfffPPNeOSRR7KvtD527NgYN25cjBo1qs3yTz75ZCxYsCA7tummm8awYcPaLPfcc8/FnDlzsmMjR46MDTfcsM1ydhIgQIAAAQIECBCoJQEJgFrqTW0hQIAAAQIECBAg0IMCV111VUyZMiVeeumlVaIYNGhQXHjhhXHMMcesciztaG5uju9973tx+umnx5IlS1Ypc8ghh8RFF10UQ4YMaXXsb3/7W0yePDnbt8MOO8R9990XjY2t/8x58cUXY/z48fH666/HeuutFw8//HCrOmwQIECAAAECBAgQqFWBhnfeaDfXauO0iwABAgQIECBAgACB7hG44YYb4jOf+UysWLEihg4dGnvssUe85z3vifvvvz/7NH8hipNOOilLBBS20+vixYtjv/32i2nTpmW7hw8fHjvuuGOss846MX369Eif8k9Legrg1ltvjTFjxmTbhX8OOuiguO6667LN8847L0477bTCoSyevffeu1j3jTfemF2rWMAKAQIECBAgQIAAgRoWkACo4c7VNAIECBAgQIAAAQLdJbDVVlvF008/nQ358+ijj8bAgQOLl05PBHzkIx+J559/Ptv/yiuvRHoioLCce+65cdZZZ2Wbxx9/fHz3u99tdf7Pf/7z7MmBhQsXRrqZn5IALZc33ngjtt1220if9O/Xr1/2Cf8tt9wyK3LBBRfE1772tWy9reRDy3qsEyBAgAABAgQIEKg1AZMA11qPag8BAgQIECBAgACBbhZ49dVXs5v/6bJf/OIXW928T/s22mij+Na3vpXdnB8xYkT2qf60Py0vvPBCnH/++dn6v/zLv8TFF1+8yvmf+9zn4pJLLsnK3HbbbfGb3/wmWy/8k544uPLKK6OhoSEbPigNM5QedH7ooYfijDPOyIql4YEK1ymc55UAAQIECBAgQIBArQtIANR6D2sfAQIECBAgQIAAgS4WGDx4cPGm/fXXX5+Ntb/yJQ899NBYtGhRlijYddddi4fTjfu0Py3pSYD2lnR+GhooLemclZc999wzTj755Gz33XffHT/84Q/jsMMOi2XLlkWafPjaa6+Nvn37rnyabQIECBAgQIAAAQI1LSABUNPdq3EECBAgQIAAAQIEul4g3VhPY/6nJd1832KLLeKoo46KX/ziF5GG50lL+nR+r16r/vkxY8aM7Phaa60Vm2yySVY+nbPy17x582KbbbbJyhbOyTZa/JPG/09DAaXly1/+cnHugB//+Mex2WabtShplQABAgQIECBAgEB9CJgDoD76WSsJECBAgAABAgQIdKnAnDlz4pOf/GQ26W/LC/Xu3TsmTJgQEydOjIMPPjhGjhzZ8nB8+MMfjnvvvbfVvjVt9O/fP9J8ACmpsPLy2GOPxQc/+MFsKKB0bPLkyfGzn/1s5WK2CRAgQIAAAQIECNSFwKofwamLZmskAQIECBAgQIAAAQKVFBg2bFjccccd8e1vfzvGjBlTrHr58uXZUwFpIt70KfzCWP6FAv/85z8Lqx1+Xbx4caR5B9pa1l9//VYTDL/11lttFbOPAAECBAgQIECAQF0IeAKgLrpZIwkQIECAAAECBAh0r8Czzz4bf/jDH+KWW26JadOmZZ/YL0Rw0UUXxQknnJBtFp4A2GqrreK+++4rFFnj66BBg9p8AuATn/hE3Hzzza3Ov+KKK7IhiVrttEGAAAECBAgQIECgDgQkAOqgkzWRAAECBAgQIECAQE8KvP322/H9738/TjvttCyM3XbbLXtaIG0cccQRcdVVV0VjY2OkT+unuQBKXVJi4cQTT8xO//rXvx6/+93v4tFHH82eCHjkkUdi9OjRpVbtPAIECBAgQIAAAQJVKWAIoKrsNkETIECAAAECBAgQyI/AjTfeGOmT9+kGe7rhvvKSbupPmTIlPvCBD2SH7r///mhubs7Wt9xyy+y1qakpbrrpppVPLW6vWLEidt9999h1112zCX6LB/5v5emnn46vfvWr2da4cePi7LPPjp/85CeR5iBYsGBBHHbYYZGGI7IQIECAAAECBAgQqCcBCYB66m1tJUCAAAECBAgQINAFAoMHD86G3Zk1a1acddZZ7V6hcNM/DftTmMD36KOPjnR+Wk455ZRWQwW1rCjdzP/Tn/4Uf/nLX6Jv374tD8WyZcvi0EMPjTQ3QJ8+feKnP/1p9jp+/Pg49dRTs7J//etf47zzzmt1ng0CBAgQIECAAAECtS4gAVDrPax9BAgQIECAAAECBLpYYOedd473ve992VV+/etfx49+9KPspnzhsvPnz4+TTjoppk+fnu369Kc/XTgUw4cPj3POOSfbfv755+NDH/pQpCcECsvMmTPjggsuKM4ZMGTIkPjiF79YOJy9nnnmmfHggw9m62non/QEQGFJCYk0v0Bazj333FZ1F8p4JUCAAAECBAgQIFCrAuYAqNWe1S4CBAgQIECAAAEC3Sjw+OOPx0c+8pFsHP902YEDB8amm24aaWifdGM/zQOQluOOOy5++MMfZp/Qz3a8808qkyYFvuyyywq7YujQobHeeuvFjBkzivsGDBgQt912W3adws4777wz0pwCaYig7bbbLh544IFWdadyaXLhFFsqs/nmm8dDDz2UxVeowysBAgQIECBAgACBWhXwBECt9qx2ESBAgAABAgQIEOhGgW222SbuvffeOPjgg6NXr17ZUD5PPPFE/P3vf4+lS5dmn8K/5JJLIn2lYXpaLmkC4EsvvTRuueWW2HrrrbPz33jjjeLN/zSOfxrDP924TzfyC0t6suDwww/PbuynOn/2s5+tUncqu+OOO2bDC6X1lFBIQw1ZCBAgQIAAAQIECNSDgCcA6qGXtZEAAQIECBAgQIBANwqkG/PpU///+Mc/sk/yp0/mpycCOrosWvT/2rtjGwBhKIaCWSArZP+NskFGoEaKGID66Xoo/tmdJXjG3nucc8Za6/5ceM7593XPESBAgAABAgQIECDwCRgAVIEAAQIECBAgQIAAAQIECBAgQIAAAQIECAQFfAIoGKqTCBAgQIAAAQIECBAgQIAAAQIECBAgQICAAUAHCBAgQIAAAQIECBAgQIAAAQIECBAgQIBAUMAAEAzVSQQIECBAgAABAgQIECBAgAABAgQIECBAwACgAwQIECBAgAABAgQIECBAgAABAgQIECBAIChgAAiG6iQCBAgQIECAAAECBAgQIECAAAECBAgQIGAA0AECBAgQIECAAAECBAgQIECAAAECBAgQIBAUMAAEQ3USAQIECBAgQIAAAQIECBAgQIAAAQIECBAwAOgAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIChgAgqE6iQABAgQIECBAgAABAgQIECBAgAABAgQIGAB0gAABAgQIECBAgAABAgQIECBAgAABAgQIBAUMAMFQnUSAAAECBAgQIECAAAECBAgQIECAAAECBAwAOkCAAAECBAgQIECAAAECBAgQIECAAAECBIICBoBgqE4iQIAAAQIECBAgQIAAAQIECBAgQIAAAQIGAB0gQIAAAQIECBAgQIAAAQIECBAgQIAAAQJBAQNAMFQnESBAgAABAgQIECBAgAABAgQIECBAgAABA4AOECBAgAABAgQIECBAgAABAgQIECBAgACBoIABIBiqkwgQIECAAAECBAgQIECAAAECBAgQIECAgAFABwgQIECAAAECBAgQIECAAAECBAgQIECAQFDgBZpWUqjN82YoAAAAAElFTkSuQmCC" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="dplyr-essentials" class="title-slide slide section level1"><h1><code>dplyr</code> essentials</h1></div><div id="the-verbs" class="slide section level2">
<h1>The verbs</h1>
<p>Dplyr aims to provide a function for each basic verb of data manipulation:</p>
<ul>
<li><code>filter()</code> and <code>unique()</code> to select cases based on (the uniqueness of) their values.<br />
</li>
<li><code>arrange()</code> to reorder the cases.<br />
</li>
<li><code>select()</code> and <code>rename()</code> to select variables based on their names.<br />
</li>
<li><code>mutate()</code> and <code>transmute()</code> to add new variables that are functions of existing variables.<br />
</li>
<li><code>summarise()</code> to condense multiple values to a single value.<br />
</li>
<li><code>sample_n()</code> and <code>sample_frac()</code> to take random samples.</li>
</ul>
</div>
<div id="selecting" class="title-slide slide section level1"><h1>Selecting</h1></div><div id="selecting-rows-by-index-slice" class="slide section level2">
<h1>Selecting rows by index: <code>slice()</code></h1>
<p>If you simply want to select rows by index, use <code>slice()</code></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">slice</span>(dose_response_long, <span class="dv">2</span><span class="op">:</span><span class="dv">4</span>)</a></code></pre></div>
<pre><code>## # A tibble: 3 x 4
##   patient sex   Dose     Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;       &lt;int&gt;
## 1 002     f     dose10mg       11
## 2 003     m     dose10mg       54
## 3 004     m     dose10mg       71</code></pre>
<p>The functions <code>head()</code> and <code>tail()</code> work with tibbles as well, and also in the context of chained actions.</p>
<p><strong>Note</strong> all functions work equally well with dataframes so instead of <code>tbl</code> you can read &quot; and <code>data.frame</code>&quot;.</p>
</div><div id="get-unique-cases-with-distinct" class="slide section level2">
<h1>Get unique cases with <code>distinct()</code></h1>
<ul>
<li>The <code>distinct()</code> function retains only unique/distinct cases from a <code>tbl</code>.<br />
</li>
<li>The provided variables are used when determining uniqueness. If omitted, it will use all variables.</li>
<li>If there are multiple cases for a given combination of inputs, only the first case will be preserved.<br />
</li>
<li><code>.keep_all</code> specifies whether all variables in the tbl should be kept.</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>(sex, Dose, <span class="dt">.keep_all =</span> T)</a></code></pre></div>
<pre><code>## # A tibble: 4 x 4
##   patient sex   Dose      Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;        &lt;int&gt;
## 1 001     f     dose10mg        12
## 2 003     m     dose10mg        54
## 3 001     f     dose100mg       88
## 4 003     m     dose100mg       14</code></pre>
</div><div class="slide section level2">

<p>Without <code>.keep_all = T</code></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>(Dose)</a></code></pre></div>
<pre><code>## # A tibble: 2 x 1
##   Dose     
##   &lt;chr&gt;    
## 1 dose10mg 
## 2 dose100mg</code></pre>
</div><div id="filter-cases" class="slide section level2">
<h1><code>filter()</code> cases</h1>
<ul>
<li>The function <code>filter()</code> allows you to select a subset of cases in a data frame.<br />
</li>
<li>The first argument is the tibble or data frame.<br />
</li>
<li>The second and subsequent arguments refer to variables within that data frame, selecting cases where the expression is TRUE.</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(Dose <span class="op">==</span><span class="st"> &quot;dose10mg&quot;</span> <span class="op">&amp;</span><span class="st"> </span>Response <span class="op">&gt;</span><span class="st"> </span><span class="dv">60</span>)</a></code></pre></div>
<pre><code>## # A tibble: 7 x 4
##   patient sex   Dose     Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;       &lt;int&gt;
## 1 004     m     dose10mg       71
## 2 008     m     dose10mg       68
## 3 010     m     dose10mg       83
## 4 011     m     dose10mg       72
## 5 013     m     dose10mg       67
## 6 015     m     dose10mg       73
## 7 024     m     dose10mg       61</code></pre>
</div><div class="slide section level2">

<p>When you want to filter rows based on a regular expression pattern matching a character value you can do something like shown in the chunk below because the only thing filter needs is a logical vector.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1">(t &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;abb&quot;</span>, <span class="st">&quot;bbc&quot;</span>, <span class="st">&quot;dbbd&quot;</span>, <span class="st">&quot;aacc&quot;</span>), <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>))</a></code></pre></div>
<pre><code>## # A tibble: 4 x 2
##   x         y
##   &lt;chr&gt; &lt;int&gt;
## 1 abb       1
## 2 bbc       2
## 3 dbbd      3
## 4 aacc      4</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1">t <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="kw">grepl</span>(<span class="st">&quot;bb&quot;</span>, x))</a></code></pre></div>
<pre><code>## # A tibble: 3 x 2
##   x         y
##   &lt;chr&gt; &lt;int&gt;
## 1 abb       1
## 2 bbc       2
## 3 dbbd      3</code></pre>
</div><div class="slide section level2">

<p>Using <code>str_detect()</code> from the <code>stringr</code> tidyverse package this is also possible:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" data-line-number="1">t <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="kw">str_detect</span>(x, <span class="st">&quot;bb&quot;</span>))</a></code></pre></div>
<pre><code>## # A tibble: 3 x 2
##   x         y
##   &lt;chr&gt; &lt;int&gt;
## 1 abb       1
## 2 bbc       2
## 3 dbbd      3</code></pre>
</div><div id="selecting-columns-select" class="slide section level2">
<h1>Selecting columns: <code>select()</code></h1>
<ul>
<li>Choose variables from a table.</li>
<li>Closely related to <code>rename()</code> discussed below; <code>select()</code> keeps only the listed variables and <code>rename()</code> keeps all variables.</li>
</ul>
<p>When you use the <code>key = value</code> format this will result in a rename of the variable.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">select</span>(dose_response_long, patient, <span class="dt">gender =</span> sex)</a></code></pre></div>
<pre><code>## # A tibble: 52 x 2
##    patient gender
##    &lt;chr&gt;   &lt;fct&gt; 
##  1 001     f     
##  2 002     f     
##  3 003     m     
##  4 004     m     
##  5 005     f     
##  6 006     f     
##  7 007     f     
##  8 008     m     
##  9 009     f     
## 10 010     m     
## #  with 42 more rows</code></pre>
</div><div class="slide section level2">

<p>Use the minus sign when you want to select everything <em>but</em> a variable:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">select</span>(dose_response_long, <span class="op">-</span>patient, <span class="op">-</span>sex)</a></code></pre></div>
<pre><code>## # A tibble: 52 x 2
##    Dose     Response
##    &lt;chr&gt;       &lt;int&gt;
##  1 dose10mg       12
##  2 dose10mg       11
##  3 dose10mg       54
##  4 dose10mg       71
##  5 dose10mg       19
##  6 dose10mg       22
##  7 dose10mg       23
##  8 dose10mg       68
##  9 dose10mg       30
## 10 dose10mg       83
## #  with 42 more rows</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="co">## same as </span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="co">#select(dose_response_long, -c(patient, sex))</span></a></code></pre></div>
</div><div class="slide section level2">

<p>You can use the colon operator to indicate a range of variables:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">select</span>(dose_response_long, patient<span class="op">:</span>Dose)</a></code></pre></div>
<pre><code>## # A tibble: 52 x 3
##    patient sex   Dose    
##    &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;   
##  1 001     f     dose10mg
##  2 002     f     dose10mg
##  3 003     m     dose10mg
##  4 004     m     dose10mg
##  5 005     f     dose10mg
##  6 006     f     dose10mg
##  7 007     f     dose10mg
##  8 008     m     dose10mg
##  9 009     f     dose10mg
## 10 010     m     dose10mg
## #  with 42 more rows</code></pre>
</div><div class="slide section level2">

<p>Or with one of the the <code>tidyselect</code> helpers:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">select</span>(dose_response, <span class="kw">starts_with</span>(<span class="st">&quot;dose&quot;</span>))</a></code></pre></div>
<pre><code>## # A tibble: 26 x 2
##    dose10mg dose100mg
##       &lt;int&gt;     &lt;int&gt;
##  1       12        88
##  2       11        54
##  3       54        14
##  4       71        21
##  5       19        89
##  6       22        99
##  7       23        69
##  8       68        31
##  9       30        85
## 10       83        18
## #  with 16 more rows</code></pre>
</div><div id="tidyselect-helpers" class="slide section level2">
<h1>Tidyselect helpers</h1>
<p>Both with <code>select()</code> and <code>rename()</code> and also with <code>mutate_at()</code> you can use the special helper functions of the tidyselect package:</p>
<ul>
<li><code>starts_with()</code>: Starts with a prefix.<br />
</li>
<li><code>ends_with()</code>: Ends with a suffix.<br />
</li>
<li><code>contains()</code>: Contains a literal string.<br />
</li>
<li><code>matches()</code>: Matches a regular expression.<br />
</li>
<li><code>num_range()</code>: Matches a numerical range like x01, x02, x03.<br />
</li>
<li><code>one_of()</code>: Matches variable names in a character vector.<br />
</li>
<li><code>everything()</code>: Matches all variables.<br />
</li>
<li><code>last_col()</code>: Select last variable, possibly with an offset.</li>
</ul>
</div><div class="slide section level2">

<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">select</span>(dose_response_long, <span class="kw">contains</span>(<span class="st">&quot;o&quot;</span>))</a></code></pre></div>
<pre><code>## # A tibble: 52 x 2
##    Dose     Response
##    &lt;chr&gt;       &lt;int&gt;
##  1 dose10mg       12
##  2 dose10mg       11
##  3 dose10mg       54
##  4 dose10mg       71
##  5 dose10mg       19
##  6 dose10mg       22
##  7 dose10mg       23
##  8 dose10mg       68
##  9 dose10mg       30
## 10 dose10mg       83
## #  with 42 more rows</code></pre>
</div><div id="renaming-variables-rename" class="slide section level2">
<h1>Renaming variables: <code>rename()</code></h1>
<p>Rename variables from a table.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rename</span>(<span class="dt">Patient =</span> patient, <span class="dt">Gender =</span> sex)</a></code></pre></div>
<pre><code>## # A tibble: 52 x 4
##    Patient Gender Dose     Response
##    &lt;chr&gt;   &lt;fct&gt;  &lt;chr&gt;       &lt;int&gt;
##  1 001     f      dose10mg       12
##  2 002     f      dose10mg       11
##  3 003     m      dose10mg       54
##  4 004     m      dose10mg       71
##  5 005     f      dose10mg       19
##  6 006     f      dose10mg       22
##  7 007     f      dose10mg       23
##  8 008     m      dose10mg       68
##  9 009     f      dose10mg       30
## 10 010     m      dose10mg       83
## #  with 42 more rows</code></pre>
</div><div id="selecting-from-ranked-data" class="slide section level2">
<h1>Selecting from ranked data</h1>
<p>The <code>top_n()</code> function makes it easy to select a few cases that based on the ranking of a value:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">top_n</span>(<span class="dv">3</span>, Response)</a></code></pre></div>
<pre><code>## # A tibble: 4 x 4
##   patient sex   Dose      Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;        &lt;int&gt;
## 1 005     f     dose100mg       89
## 2 006     f     dose100mg       99
## 3 017     f     dose100mg       96
## 4 021     f     dose100mg       89</code></pre>
<p>We see 4 cases returned because the third rank is the same for two cases.</p>
</div><div class="slide section level2">

<p>This is especially interesting with grouped data:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(Dose) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">top_n</span>(<span class="dv">3</span>, <span class="kw">desc</span>(Response))</a></code></pre></div>
<pre><code>## # A tibble: 7 x 4
## # Groups:   Dose [2]
##   patient sex   Dose      Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;        &lt;int&gt;
## 1 001     f     dose10mg        12
## 2 002     f     dose10mg        11
## 3 026     f     dose10mg        11
## 4 003     m     dose100mg       14
## 5 018     m     dose100mg       14
## 6 019     m     dose100mg       12
## 7 024     m     dose100mg       10</code></pre>
<p>Note the use of <code>desc()</code> to reverse the ordering.</p>
</div><div id="extract-a-column-as-vector" class="slide section level2">
<h1>Extract a column as vector</h1>
<p>Using <code>pull()</code> you can obtain atomic vectors.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">pull</span>(dose_response_long, Response)</a></code></pre></div>
<pre><code>##  [1] 12 11 54 71 19 22 23 68 30 83 72 48 67 13 73 20 22 40 57 26 17 29 54
## [24] 61 57 11 88 54 14 21 89 99 69 31 85 18 37 28 16 79 22 84 96 14 12 63
## [47] 89 77 21 10 36 80</code></pre>
<p>This is of course the same as <code>dose_response_long[[4]]</code> or <code>dose_response_long$Response</code> but the difference is that <code>pull()</code> can be applied in a <code>%&gt;%</code> pipeline.</p>
<p>With <code>dose_response_long[, 4]</code> it matters whether you are working with a tibble or a dataframe; a tibble returns a tibble and a dataframe returns a vector.</p>
</div><div id="sorting-with-arrange" class="slide section level2">
<h1>Sorting with <code>arrange()</code></h1>
<p>If you want to sort the rows of a dataframe/tibble by the values of one or more columns, use <code>arrange()</code></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(Response) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)</a></code></pre></div>
<pre><code>## # A tibble: 3 x 4
##   patient sex   Dose      Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;        &lt;int&gt;
## 1 024     m     dose100mg       10
## 2 002     f     dose10mg        11
## 3 026     f     dose10mg        11</code></pre>
</div><div class="slide section level2">

<p>Use the function <code>desc()</code> to reverse the ordering</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(Response)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">head</span>(<span class="dv">1</span>)</a></code></pre></div>
<pre><code>## # A tibble: 1 x 4
##   patient sex   Dose      Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;        &lt;int&gt;
## 1 006     f     dose100mg       99</code></pre>
<p>Note that the previous chunk is equivalent to this</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">top_n</span>(<span class="dv">1</span>, Response)</a></code></pre></div>
<p>So natural ordering is from low to high, but the <code>top_n()</code> function always orders from high to low. You can reverse this as well using the <code>desc()</code> function.</p>
</div><div id="random-sampling" class="slide section level2">
<h1>Random sampling</h1>
<p>There are two functions available for random sampling: <code>sample_n()</code> and <code>sample_frac()</code>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">sample_frac</span>(dose_response_long, <span class="fl">0.05</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## # A tibble: 3 x 4
##   patient sex   Dose      Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;        &lt;int&gt;
## 1 025     m     dose10mg        57
## 2 025     m     dose100mg       36
## 3 026     f     dose100mg       80</code></pre>
<p>The workings of <code>sample_n()</code> are obvious I guess.</p>
</div>
<div id="adding-and-changing-variables" class="title-slide slide section level1"><h1>Adding and changing variables</h1></div><div id="window-functions" class="slide section level2">
<h1>Window functions</h1>
<ul>
<li>A new variable is usually the result of some operation on one or more previous variables.</li>
<li>The data in an original variables is processed such that for each old value a new value is generated.<br />
</li>
<li>Functions that carry out this kind of operation are called <strong><em>window</em></strong> functions.<br />
</li>
<li>Thus, window functions are functions that take a vector and return another vector of the same length.</li>
</ul>
<p>For instance, the <code>cumsum()</code> function returns the cumulative sum of a numeric vector:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">cumsum</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)</a></code></pre></div>
<pre><code>## [1]  1  3  6 10 15</code></pre>
</div><div class="slide section level2">

<p>Here are a few of the main window functions. Note that some of them come from base R. Later you will see the use of several of them in concert with the <code>mutate()</code> function. See the eBook for a more complete listing.</p>
<ul>
<li><p><strong><em><code>dplyr::lead</code></em></strong><br />
Copy with values shifted by 1.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="kw">lead</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">8</span>))</a></code></pre></div>
<pre><code>## [1]  4  2  8 NA</code></pre></li>
<li><p><strong><em><code>dplyr::lag</code></em></strong><br />
Copy with values lagged by 1.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="kw">lag</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">8</span>))</a></code></pre></div>
<pre><code>## [1] NA  1  4  2</code></pre></li>
</ul>
</div><div class="slide section level2">

<ul>
<li><p><strong><em><code>dplyr::between</code></em></strong><br />
Are values between a and b?</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="kw">between</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">8</span>, <span class="dv">1</span>), <span class="dv">3</span>, <span class="dv">5</span>)</a></code></pre></div>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE FALSE</code></pre></li>
<li><p><strong><em><code>pmax</code></em></strong><br />
Element-wise maximum</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb64-1" data-line-number="1"><span class="kw">pmax</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">8</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">3</span>))</a></code></pre></div>
<pre><code>## [1] 5 4 3 8 3</code></pre></li>
</ul>
</div><div id="add-one-or-more-variables-mutate" class="slide section level2">
<h1>Add one or more variables: <code>mutate()</code></h1>
<p>The function <code>mutate()</code> can be used to calculate and append one or more columns.The window functions from the previous section are often-used helpers.</p>
<p>For instance, given the <code>ChickWeight</code> dataset which shows weight gain for 50 chicks:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb66-1" data-line-number="1">chicks &lt;-<span class="st"> </span><span class="kw">as_tibble</span>(ChickWeight) </a>
<a class="sourceLine" id="cb66-2" data-line-number="2">chicks <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">head</span>(<span class="dv">5</span>)</a></code></pre></div>
<pre><code>## # A tibble: 5 x 4
##   weight  Time Chick Diet 
##    &lt;dbl&gt; &lt;dbl&gt; &lt;ord&gt; &lt;fct&gt;
## 1     42     0 1     1    
## 2     51     2 1     1    
## 3     59     4 1     1    
## 4     64     6 1     1    
## 5     76     8 1     1</code></pre>
</div><div class="slide section level2">

<p>Suppose we want to know the daily weight gain of these chicks (as a challenge, you could try to do this in base R).</p>
<p>Using <code>lag()</code> and <code>mutate()</code> this is a breeze (or so it seems):</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb68-1" data-line-number="1">(chicks &lt;-<span class="st"> </span>chicks <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">weight_gain =</span> weight <span class="op">-</span><span class="st"> </span><span class="kw">lag</span>(weight)))</a></code></pre></div>
<pre><code>## # A tibble: 578 x 5
##    weight  Time Chick Diet  weight_gain
##     &lt;dbl&gt; &lt;dbl&gt; &lt;ord&gt; &lt;fct&gt;       &lt;dbl&gt;
##  1     42     0 1     1              NA
##  2     51     2 1     1               9
##  3     59     4 1     1               8
##  4     64     6 1     1               5
##  5     76     8 1     1              12
##  6     93    10 1     1              17
##  7    106    12 1     1              13
##  8    125    14 1     1              19
##  9    149    16 1     1              24
## 10    171    18 1     1              22
## #  with 568 more rows</code></pre>
</div><div class="slide section level2">

<p>but the devil is in the details:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb70-1" data-line-number="1">chicks <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">slice</span>(<span class="dv">10</span><span class="op">:</span><span class="dv">15</span>)</a></code></pre></div>
<pre><code>## # A tibble: 6 x 5
##   weight  Time Chick Diet  weight_gain
##    &lt;dbl&gt; &lt;dbl&gt; &lt;ord&gt; &lt;fct&gt;       &lt;dbl&gt;
## 1    171    18 1     1              22
## 2    199    20 1     1              28
## 3    205    21 1     1               6
## 4     40     0 2     1            -165
## 5     49     2 2     1               9
## 6     58     4 2     1               9</code></pre>
<p>The transition from chick 1 to chick 2 is not taken into account! So to get the weight gain for each chick, we need to split the data first. This is dealt with in a later section but here is a preview:</p>
</div><div class="slide section level2">

<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb72-1" data-line-number="1">chicks &lt;-<span class="st"> </span>chicks <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb72-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(Chick) <span class="op">%&gt;%</span><span class="st"> </span><span class="co">#split on chicks</span></a>
<a class="sourceLine" id="cb72-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">weight_gain =</span> weight <span class="op">-</span><span class="st"> </span><span class="kw">lag</span>(weight)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb72-4" data-line-number="4"><span class="st">    </span><span class="kw">ungroup</span>() <span class="co">#put together again</span></a>
<a class="sourceLine" id="cb72-5" data-line-number="5"><span class="kw">slice</span>(chicks, <span class="dv">10</span><span class="op">:</span><span class="dv">15</span>)</a></code></pre></div>
<pre><code>## # A tibble: 6 x 5
##   weight  Time Chick Diet  weight_gain
##    &lt;dbl&gt; &lt;dbl&gt; &lt;ord&gt; &lt;fct&gt;       &lt;dbl&gt;
## 1    171    18 1     1              22
## 2    199    20 1     1              28
## 3    205    21 1     1               6
## 4     40     0 2     1              NA
## 5     49     2 2     1               9
## 6     58     4 2     1               9</code></pre>
</div><div class="slide section level2">

<p>Can you use a custom function in a <code>mutate</code> context? Of course you can!</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb74-1" data-line-number="1">my_z &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb74-2" data-line-number="2">    <span class="kw">abs</span>((<span class="kw">abs</span>(x <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)) <span class="op">/</span><span class="st"> </span><span class="kw">sd</span>(x)))</a>
<a class="sourceLine" id="cb74-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb74-4" data-line-number="4">women <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb74-5" data-line-number="5"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">z_score =</span> <span class="kw">my_z</span>(weight)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb74-6" data-line-number="6"><span class="st">    </span><span class="kw">head</span>()</a></code></pre></div>
<pre><code>##   height weight z_score
## 1     58    115   1.402
## 2     59    117   1.273
## 3     60    120   1.080
## 4     61    123   0.886
## 5     62    126   0.693
## 6     63    129   0.499</code></pre>
</div><div class="slide section level2">

<p>And whats more, you can make multiple columns in one operation where the calculations for the subsequent columns are interdependent.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb76-1" data-line-number="1">women <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb76-2" data-line-number="2"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">z_score =</span> <span class="kw">my_z</span>(weight),</a>
<a class="sourceLine" id="cb76-3" data-line-number="3">           <span class="dt">z_bin =</span> <span class="kw">ntile</span>(z_score, <span class="dv">3</span>)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb76-4" data-line-number="4"><span class="st">    </span><span class="kw">head</span>()</a></code></pre></div>
<pre><code>##   height weight z_score z_bin
## 1     58    115   1.402     3
## 2     59    117   1.273     3
## 3     60    120   1.080     2
## 4     61    123   0.886     2
## 5     62    126   0.693     2
## 6     63    129   0.499     1</code></pre>
</div><div id="mutate_all" class="slide section level2">
<h1><code>mutate_all()</code></h1>
<ul>
<li>The <code>mutate_all()</code> function is similar to the base R <code>apply()</code> function.<br />
</li>
<li>Suppose you want to calculate the log2 of all numeric values in the <code>iris</code> dataset.  In base R you would probably do it like this:</li>
</ul>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb78-1" data-line-number="1"><span class="kw">head</span>(<span class="kw">apply</span>(iris[, <span class="dv">-5</span>], <span class="dt">MARGIN =</span> <span class="dv">2</span>, <span class="dt">FUN =</span> log2))</a></code></pre></div>
<pre><code>##      Sepal.Length Sepal.Width Petal.Length Petal.Width
## [1,]         2.35        1.81        0.485       -2.32
## [2,]         2.29        1.58        0.485       -2.32
## [3,]         2.23        1.68        0.379       -2.32
## [4,]         2.20        1.63        0.585       -2.32
## [5,]         2.32        1.85        0.485       -2.32
## [6,]         2.43        1.96        0.766       -1.32</code></pre>
</div><div id="there-are-three-ways-to-do-this-with-apply.-we" class="slide section level2">
<h1>There are three ways to do this with apply. We</h1>
<p><strong><em>A simple named list</em></strong>.<br />
This is actually much like the <code>apply()</code> approach.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb80-1" data-line-number="1">iris <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb80-2" data-line-number="2"><span class="st">    </span><span class="kw">select</span>(<span class="op">-</span>Species) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb80-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate_all</span>(<span class="kw">list</span>(<span class="dt">mean =</span> mean)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb80-4" data-line-number="4"><span class="st">    </span><span class="kw">head</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Sepal.Length_mean
## 1          5.1         3.5          1.4         0.2              5.84
## 2          4.9         3.0          1.4         0.2              5.84
##   Sepal.Width_mean Petal.Length_mean Petal.Width_mean
## 1             3.06              3.76              1.2
## 2             3.06              3.76              1.2</code></pre>
<p>So this adds 4 additional columns to the selection and generates variable names by appending <code>_mean</code>. This is different from the first approach in that the old variables are kept beside the new ones.</p>
<p>When you supply two functions, e.g. <code>list(mean = mean, sd = sd)</code>, a variable is added for another four columns (8 in total).</p>
</div><div class="slide section level2">

<p><strong><em>Auto named with</em> <code>tibble::lst()</code></strong>.<br />
This is similar to the previous one; you supply a list of function names. The names of these functions define the postfix of the variable name.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb82-1" data-line-number="1">iris <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb82-2" data-line-number="2"><span class="st">    </span><span class="kw">select</span>(<span class="op">-</span>Species) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb82-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate_all</span>(<span class="kw">lst</span>(mean, sd)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb82-4" data-line-number="4"><span class="st">    </span><span class="kw">head</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Sepal.Length_mean
## 1          5.1         3.5          1.4         0.2              5.84
## 2          4.9         3.0          1.4         0.2              5.84
##   Sepal.Width_mean Petal.Length_mean Petal.Width_mean Sepal.Length_sd
## 1             3.06              3.76              1.2           0.828
## 2             3.06              3.76              1.2           0.828
##   Sepal.Width_sd Petal.Length_sd Petal.Width_sd
## 1          0.436            1.77          0.762
## 2          0.436            1.77          0.762</code></pre>
</div><div class="slide section level2">

<p><strong><em>Using lambdas</em></strong>.<br />
Lambdas are anonymous function-like expressions. Although this form is harder to grasp, it does make it easier to pass arguments to the function you want executed by <code>mutate_all</code> (in this case <code>trim = .2</code> to <code>mean</code>).</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb84-1" data-line-number="1">iris <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb84-2" data-line-number="2"><span class="st">    </span><span class="kw">select</span>(<span class="op">-</span>Species) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb84-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate_all</span>(<span class="kw">list</span>(<span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(., <span class="dt">trim =</span> <span class="fl">0.2</span>), <span class="op">~</span><span class="st"> </span><span class="kw">sd</span>(.))) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb84-4" data-line-number="4"><span class="st">    </span><span class="kw">head</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Sepal.Length_mean
## 1          5.1         3.5          1.4         0.2               5.8
## 2          4.9         3.0          1.4         0.2               5.8
##   Sepal.Width_mean Petal.Length_mean Petal.Width_mean Sepal.Length_sd
## 1             3.04              3.84              1.2           0.828
## 2             3.04              3.84              1.2           0.828
##   Sepal.Width_sd Petal.Length_sd Petal.Width_sd
## 1          0.436            1.77          0.762
## 2          0.436            1.77          0.762</code></pre>
<p>The expression <code>~ mean(., trim = 0.2)</code> is therefore equivalent to something like <code>function (.) mean(., trim = 0.2)</code> so the tilde is shorthand for <code>function (.)</code></p>
</div><div class="slide section level2">

<p>Strangely enough, when experimenting further, I find that this simple solution also works for a single function to be applied:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb86-1" data-line-number="1">iris <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb86-2" data-line-number="2"><span class="st">    </span><span class="kw">select</span>(<span class="op">-</span>Species) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb86-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate_all</span>(my_z) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># or mutate_all(function(x){abs((abs(x - mean(x)) / sd(x)))})</span></a>
<a class="sourceLine" id="cb86-4" data-line-number="4"><span class="st">    </span><span class="kw">head</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1        0.898       1.016         1.34        1.31
## 2        1.139       0.132         1.34        1.31</code></pre>
<p>Again, this gives only the new variables, not the preexisting ones.</p>
<p>It can be concluded that, whatever the approach, a list of executables of some form needs to be provided. Choose the one of your liking.</p>
</div><div id="mutate_at" class="slide section level2">
<h1><code>mutate_at()</code></h1>
<p>In the previous examples, a selection of the numeric columns was required before <code>mutate_all()</code> could be executed. An alternative approach is to use <code>mutate_at()</code> which has an additional argument for the column selection.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb88-1" data-line-number="1">iris <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb88-2" data-line-number="2"><span class="st">    </span><span class="kw">mutate_at</span>(<span class="kw">vars</span>(<span class="kw">contains</span>(<span class="st">&quot;.&quot;</span>)), my_z) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb88-3" data-line-number="3"><span class="st">    </span><span class="kw">head</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1        0.898       1.016         1.34        1.31  setosa
## 2        1.139       0.132         1.34        1.31  setosa</code></pre>
<p>You can see that the original variables are replaced with the original variables - that is, in the modified copy of the tibble.</p>
</div><div class="slide section level2">

<p>The selection can be specified in several ways:</p>
<ul>
<li><code>mutate_at(vars(-Species), my_z)</code></li>
<li><code>mutate_at(1:4, my_z)</code></li>
<li><code>mutate_at(vars(-Species), my_z)</code></li>
<li><code>mutate_at(vars(matches(&quot;Width|Length&quot;)), my_z)</code></li>
<li><code>mutate_at(vars(contains(&quot;.&quot;)), my_z)</code></li>
</ul>
<p>and there are probably more ways to make a column selection.</p>
</div><div id="mutate_if" class="slide section level2">
<h1><code>mutate_if()</code></h1>
<p>Even simpler in the case of the iris data is the <code>mutate_if()</code> function. After all, the entire point was to modify the numeric variables:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb90-1" data-line-number="1">iris <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb90-2" data-line-number="2"><span class="st">    </span><span class="kw">mutate_if</span>(is.numeric, my_z) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb90-3" data-line-number="3"><span class="st">    </span><span class="kw">head</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1        0.898       1.016         1.34        1.31  setosa
## 2        1.139       0.132         1.34        1.31  setosa</code></pre>
</div><div id="change-a-variable-recode-and-recode_factor" class="slide section level2">
<h1>Change a variable: <code>recode()</code> and <code>recode_factor()</code></h1>
<p>These two functions help you to quickly change the values of a variable. Here, the Dose variable is overwritten with new -numeric- values. Note that the original <code>dose_response_long</code> tibble has <strong><em>not</em></strong> been modified!</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb92-1" data-line-number="1"><span class="kw">head</span>(dose_response_long, <span class="dv">2</span>)</a></code></pre></div>
<pre><code>## # A tibble: 2 x 4
##   patient sex   Dose     Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;       &lt;int&gt;
## 1 001     f     dose10mg       12
## 2 002     f     dose10mg       11</code></pre>
</div><div class="slide section level2">

<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb94-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb94-2" data-line-number="2"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">Dose =</span> <span class="kw">recode</span>(Dose, <span class="dt">dose10mg =</span> <span class="dv">10</span>, <span class="dt">dose100mg =</span> <span class="dv">100</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb94-3" data-line-number="3"><span class="st">    </span><span class="kw">head</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>## # A tibble: 2 x 4
##   patient sex    Dose Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;dbl&gt;    &lt;int&gt;
## 1 001     f        10       12
## 2 002     f        10       11</code></pre>
</div><div class="slide section level2">

<p>Similarly, the <code>sex</code> variable can be recoded with the <code>recode_factor()</code> function. In the example below,</p>
<ul>
<li>the Response variable is created based on the <code>sex</code> variable,<br />
</li>
<li>the <code>sex</code> variable is deleted and<br />
</li>
<li>the variables are reordered to the original format</li>
</ul>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb96-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb96-2" data-line-number="2"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">Gender =</span> <span class="kw">recode_factor</span>(sex, <span class="dt">f =</span> <span class="st">&quot;female&quot;</span>, <span class="dt">m =</span> <span class="st">&quot;male&quot;</span>), </a>
<a class="sourceLine" id="cb96-3" data-line-number="3">           <span class="dt">sex =</span> <span class="ot">NULL</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb96-4" data-line-number="4"><span class="st">    </span><span class="kw">select</span>(patient, Gender, Dose, Response) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb96-5" data-line-number="5"><span class="st">    </span><span class="kw">head</span>(<span class="dv">3</span>)</a></code></pre></div>
<pre><code>## # A tibble: 3 x 4
##   patient Gender Dose     Response
##   &lt;chr&gt;   &lt;fct&gt;  &lt;chr&gt;       &lt;int&gt;
## 1 001     female dose10mg       12
## 2 002     female dose10mg       11
## 3 003     male   dose10mg       54</code></pre>
</div><div id="operations-on-groups" class="slide section level2">
<h1>Operations on groups</h1>
<ul>
<li>Often you want to know something about groups in your data.<br />
</li>
<li>This is where the <code>group_by()</code> function comes in, and its counterpart <code>ungroup()</code>.<br />
</li>
<li><code>group_by()</code> does not <strong><em>split</em></strong> your data; it adds metadata that marks how rows should be grouped.<br />
</li>
<li>As long as that metadata is there you wont be able to change the factors of the columns involved in the grouping.<br />
</li>
<li>If you really want to split, like the <code>split()</code> function, you should use the <code>group_split()</code> function.</li>
</ul>
</div><div id="group_by-and-ungroup" class="slide section level2">
<h1><code>group_by()</code> and <code>ungroup()</code></h1>
<p>This is the most-used set of grouping functions. It is usually followed by some summary function but sometimes you want to progress with all data combined. In that case you need to ungroup again.</p>
<p>Here is the summary use case. No need for ungrouping.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb98-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb98-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(sex) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb98-3" data-line-number="3"><span class="st">    </span><span class="kw">summarise</span>(<span class="dt">mean =</span> <span class="kw">mean</span>(Response))</a></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   sex    mean
##   &lt;fct&gt; &lt;dbl&gt;
## 1 f      50.3
## 2 m      41.7</code></pre>
</div><div class="slide section level2">

<p>Of course you can group by multiple variables.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb100-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb100-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(Dose, sex) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb100-3" data-line-number="3"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">mean =</span> <span class="kw">mean</span>(Response))</a></code></pre></div>
<pre><code>## # A tibble: 4 x 3
## # Groups:   Dose [2]
##   Dose      sex    mean
##   &lt;chr&gt;     &lt;fct&gt; &lt;dbl&gt;
## 1 dose100mg f      80.9
## 2 dose100mg m      21.5
## 3 dose10mg  f      19.6
## 4 dose10mg  m      61.9</code></pre>
</div><div class="slide section level2">

<ul>
<li>After grouping on a variable, you will sometimes be interested in the top or bottom <em>n</em> rows.</li>
<li>The <code>head()</code> function will not work then, surprisingly enough.</li>
<li>For example, suppose you want the top 2 responses from both the males and females in the dose100mg group.</li>
</ul>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb102-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb102-2" data-line-number="2"><span class="st">    </span><span class="kw">filter</span>(Dose <span class="op">==</span><span class="st"> &quot;dose100mg&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb102-3" data-line-number="3"><span class="st">    </span><span class="kw">group_by</span>(sex) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb102-4" data-line-number="4"><span class="st">    </span><span class="kw">arrange</span>(Response) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb102-5" data-line-number="5"><span class="st">    </span><span class="kw">head</span>(<span class="dv">2</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb102-6" data-line-number="6"><span class="st">    </span><span class="kw">ungroup</span>() </a></code></pre></div>
<pre><code>## # A tibble: 2 x 4
##   patient sex   Dose      Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;        &lt;int&gt;
## 1 024     m     dose100mg       10
## 2 019     m     dose100mg       12</code></pre>
</div><div class="slide section level2">

<p>Instead, to select the top <em>n</em> values after grouping you need to use either <code>slice()</code> or <code>filter(row_number() &lt;some-logical-test&gt;)</code>. Here is the correct solution.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb104-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb104-2" data-line-number="2"><span class="st">    </span><span class="kw">filter</span>(Dose <span class="op">==</span><span class="st"> &quot;dose100mg&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb104-3" data-line-number="3"><span class="st">    </span><span class="kw">group_by</span>(sex) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb104-4" data-line-number="4"><span class="st">    </span><span class="kw">arrange</span>(Response) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb104-5" data-line-number="5"><span class="st">    </span><span class="kw">slice</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb104-6" data-line-number="6"><span class="st">    </span><span class="co">#filter(row_number() %in% 1:2) %&gt;% #also works</span></a>
<a class="sourceLine" id="cb104-7" data-line-number="7"><span class="st">    </span><span class="kw">ungroup</span>() <span class="co">#ungrouping not required but I added it for clarity of code</span></a></code></pre></div>
<pre><code>## # A tibble: 4 x 4
##   patient sex   Dose      Response
##   &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;        &lt;int&gt;
## 1 002     f     dose100mg       54
## 2 020     f     dose100mg       63
## 3 024     m     dose100mg       10
## 4 019     m     dose100mg       12</code></pre>
</div><div id="group_split-and-group_keys" class="slide section level2">
<h1><code>group_split()</code> and <code>group_keys()</code></h1>
<ul>
<li>The <code>group_split()</code> function is equivalent to the base R <code>split()</code> function.</li>
<li>In the example below (unevaluated), <code>split()</code> will return a list with two named elements (<code>$m</code> and <code>$f</code>), but the list returned by <code>group_split()</code> will only be accessible with <code>[[1]]</code> and <code>[[2]]</code>.</li>
</ul>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb106-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb106-2" data-line-number="2"><span class="st">    </span><span class="kw">group_split</span>(sex)</a>
<a class="sourceLine" id="cb106-3" data-line-number="3"><span class="co">##same as</span></a>
<a class="sourceLine" id="cb106-4" data-line-number="4"><span class="kw">split</span>(<span class="kw">as.data.frame</span>(dose_response_long), dose_response_long<span class="op">$</span>sex)</a></code></pre></div>
</div><div class="slide section level2">

<p>The last grouping-related function, <code>group_keys()</code>, only returns a tibble explaining the grouping structure:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb107-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb107-2" data-line-number="2"><span class="st">    </span><span class="kw">group_keys</span>(sex, Dose)</a></code></pre></div>
<pre><code>## # A tibble: 4 x 2
##   sex   Dose     
##   &lt;fct&gt; &lt;chr&gt;    
## 1 f     dose100mg
## 2 f     dose10mg 
## 3 m     dose100mg
## 4 m     dose10mg</code></pre>
</div><div id="apply-a-function-to-each-group" class="slide section level2">
<h1>Apply a function to each group</h1>
<p><code>group_map()</code>, <code>group_modify()</code> and <code>group_walk()</code> are functions that can be used to iterate on grouped tibbles.</p>
<ul>
<li><code>group_modify()</code> returns a grouped tibble. In that case <code>.f</code> must return a data frame.<br />
</li>
<li><code>group_map()</code> returns a list of results from calling <code>.f</code> on each group<br />
</li>
<li><code>group_walk()</code> calls .f for side effects and returns the input <code>.tbl</code>, invisibly</li>
</ul>
</div><div class="slide section level2">

<p>Here is an example of <code>group_map()</code>. As you can see it takes a lambda expression as seen before:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb109-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb109-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(Dose) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb109-3" data-line-number="3"><span class="st">    </span><span class="kw">group_map</span>(<span class="op">~</span><span class="st"> </span><span class="kw">quantile</span>(.x<span class="op">$</span>Response, <span class="dt">probs =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.2</span>)))</a></code></pre></div>
<pre><code>## [[1]]
##   0%  20%  40%  60%  80% 100% 
##   10   18   31   69   85   99 
## 
## [[2]]
##   0%  20%  40%  60%  80% 100% 
##   11   19   26   54   67   83</code></pre>
</div><div class="slide section level2">

<p>Use <code>group_walk()</code> when you only want to have a peek at each group before processing further.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb111-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb111-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(Dose) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb111-3" data-line-number="3"><span class="st">    </span><span class="kw">group_walk</span>(<span class="op">~</span><span class="st"> </span><span class="kw">print</span>(<span class="kw">head</span>(.x, <span class="dv">2</span>))) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb111-4" data-line-number="4"><span class="st">    </span><span class="kw">summarise</span>(<span class="dt">avg =</span> <span class="kw">mean</span>(Response))</a></code></pre></div>
<pre><code>## # A tibble: 2 x 3
##   patient sex   Response
##   &lt;chr&gt;   &lt;fct&gt;    &lt;int&gt;
## 1 001     f           88
## 2 002     f           54
## # A tibble: 2 x 3
##   patient sex   Response
##   &lt;chr&gt;   &lt;fct&gt;    &lt;int&gt;
## 1 001     f           12
## 2 002     f           11</code></pre>
<pre><code>## # A tibble: 2 x 2
##   Dose        avg
##   &lt;chr&gt;     &lt;dbl&gt;
## 1 dose100mg  51.2
## 2 dose10mg   40.8</code></pre>
</div><div id="summarizing-and-counting" class="slide section level2">
<h1>Summarizing and counting</h1>
<ul>
<li>The <code>summarize()</code> function creates one or more summary statistics, for each group, if existing.<br />
</li>
<li>For instance, to calculate the mean and SD of relative weight gain for different diets, this is the workflow for it:</li>
</ul>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb114-1" data-line-number="1">chicks <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb114-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(Chick) <span class="op">%&gt;%</span><span class="st"> </span><span class="co">#split on chicks</span></a>
<a class="sourceLine" id="cb114-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">rel_weight_gain =</span> (weight <span class="op">-</span><span class="st"> </span><span class="kw">lag</span>(weight))<span class="op">/</span>weight) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb114-4" data-line-number="4"><span class="st">    </span><span class="kw">ungroup</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb114-5" data-line-number="5"><span class="st">    </span><span class="kw">group_by</span>(Diet) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb114-6" data-line-number="6"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">mean_rel_gain =</span> <span class="kw">mean</span>(rel_weight_gain, <span class="dt">na.rm =</span> T), </a>
<a class="sourceLine" id="cb114-7" data-line-number="7">              <span class="dt">sd =</span> <span class="kw">sd</span>(rel_weight_gain, <span class="dt">na.rm =</span> T))</a></code></pre></div>
<pre><code>## # A tibble: 4 x 3
##   Diet  mean_rel_gain     sd
##   &lt;fct&gt;         &lt;dbl&gt;  &lt;dbl&gt;
## 1 1             0.111 0.0743
## 2 2             0.131 0.0742
## 3 3             0.153 0.0657
## 4 4             0.142 0.0748</code></pre>
</div><div class="slide section level2">

<p>There is a set of equivalents that create a summary for a group of variables:</p>
<ul>
<li><code>summarize_all()</code><br />
</li>
<li><code>summarize_at()</code><br />
</li>
<li><code>summarize_if()</code></li>
</ul>
<p>They are analogous to the <code>mutate_xxx()</code> methods. Here is an` example.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb116-1" data-line-number="1">iris <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb116-2" data-line-number="2"><span class="st">    </span><span class="kw">summarize_if</span>(is.numeric, <span class="kw">list</span>(<span class="dt">mean =</span> mean, <span class="dt">sd =</span> sd))</a></code></pre></div>
<pre><code>##   Sepal.Length_mean Sepal.Width_mean Petal.Length_mean Petal.Width_mean
## 1              5.84             3.06              3.76              1.2
##   Sepal.Length_sd Sepal.Width_sd Petal.Length_sd Petal.Width_sd
## 1           0.828          0.436            1.77          0.762</code></pre>
<p>You should be able to figure out the rest of them by now.</p>
</div><div id="simple-counting-of-occurrences" class="slide section level2">
<h1>Simple counting of occurrences</h1>
<p>An often used operation is simple counting of occurrences of course:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb118-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb118-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(sex, Dose) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb118-3" data-line-number="3"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">count =</span> <span class="kw">n</span>())</a></code></pre></div>
<pre><code>## # A tibble: 4 x 3
## # Groups:   sex [2]
##   sex   Dose      count
##   &lt;fct&gt; &lt;chr&gt;     &lt;int&gt;
## 1 f     dose100mg    13
## 2 f     dose10mg     13
## 3 m     dose100mg    13
## 4 m     dose10mg     13</code></pre>
</div><div class="slide section level2">

<p>There is a shorthand for this type of count: <code>tally()</code>:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb120-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb120-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(sex, Dose) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb120-3" data-line-number="3"><span class="st">    </span><span class="kw">tally</span>()</a></code></pre></div>
<pre><code>## # A tibble: 4 x 3
## # Groups:   sex [2]
##   sex   Dose          n
##   &lt;fct&gt; &lt;chr&gt;     &lt;int&gt;
## 1 f     dose100mg    13
## 2 f     dose10mg     13
## 3 m     dose100mg    13
## 4 m     dose10mg     13</code></pre>
</div><div class="slide section level2">

<p>And even shorter is this:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb122-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb122-2" data-line-number="2"><span class="st">    </span><span class="kw">count</span>(sex, Dose)</a></code></pre></div>
<pre><code>## # A tibble: 4 x 3
##   sex   Dose          n
##   &lt;fct&gt; &lt;chr&gt;     &lt;int&gt;
## 1 f     dose100mg    13
## 2 f     dose10mg     13
## 3 m     dose100mg    13
## 4 m     dose10mg     13</code></pre>
<p>When you want the counts sorted, use the <code>sort = TRUE</code> argument to count, e.g.<br />
<code>mtcars %&gt;% count(cyl, sort = TRUE)</code></p>
</div><div class="slide section level2">

<p>If you want such a count as a column in your dataset, use <code>add_tally()</code> or <code>add_count()</code></p>
<div class="sourceCode" id="cb124"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb124-1" data-line-number="1">dose_response_long <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb124-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(sex) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb124-3" data-line-number="3"><span class="st">    </span><span class="kw">add_tally</span>()</a></code></pre></div>
<pre><code>## # A tibble: 52 x 5
## # Groups:   sex [2]
##    patient sex   Dose     Response     n
##    &lt;chr&gt;   &lt;fct&gt; &lt;chr&gt;       &lt;int&gt; &lt;int&gt;
##  1 001     f     dose10mg       12    26
##  2 002     f     dose10mg       11    26
##  3 003     m     dose10mg       54    26
##  4 004     m     dose10mg       71    26
##  5 005     f     dose10mg       19    26
##  6 006     f     dose10mg       22    26
##  7 007     f     dose10mg       23    26
##  8 008     m     dose10mg       68    26
##  9 009     f     dose10mg       30    26
## 10 010     m     dose10mg       83    26
## #  with 42 more rows</code></pre>
<div class="sourceCode" id="cb126"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb126-1" data-line-number="1"><span class="co">##same as below, but slightly more readable:</span></a>
<a class="sourceLine" id="cb126-2" data-line-number="2"><span class="co">#add_count(sex)</span></a></code></pre></div>
</div><div class="slide section level2">

<p><code>add_count()</code> is useful for groupwise filtering, for instance when you want to show details of the group that occurs the least.</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb127-1" data-line-number="1">mtcars <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb127-2" data-line-number="2"><span class="st">    </span><span class="kw">add_count</span>(cyl) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb127-3" data-line-number="3"><span class="st">    </span><span class="kw">filter</span>(n <span class="op">==</span><span class="st"> </span><span class="kw">min</span>(n)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb127-4" data-line-number="4"><span class="st">    </span><span class="kw">select</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, n)</a></code></pre></div>
<pre><code>## # A tibble: 7 x 6
##     mpg   cyl  disp    hp  drat     n
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;
## 1  21       6  160    110  3.9      7
## 2  21       6  160    110  3.9      7
## 3  21.4     6  258    110  3.08     7
## 4  18.1     6  225    105  2.76     7
## 5  19.2     6  168.   123  3.92     7
## 6  17.8     6  168.   123  3.92     7
## 7  19.7     6  145    175  3.62     7</code></pre>
</div><div id="merging-data" class="slide section level2">
<h1>Merging data</h1>
<p>There are a few functions used for merging</p>
<pre><code>- `left_join()`  
- `right_join()`   
- `inner_join()`  
- `full_join()`  </code></pre>
<p>Only <code>full_join()</code> is discussed here; the others are variations behaving differently with missing data in one or the other data frames to combine.</p>
</div><div class="slide section level2">

<p>Suppose you have two tibbles:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb130-1" data-line-number="1">trA &lt;-<span class="st"> </span><span class="kw">tribble</span>(</a>
<a class="sourceLine" id="cb130-2" data-line-number="2">  <span class="op">~</span>ID, <span class="op">~</span>var1,</a>
<a class="sourceLine" id="cb130-3" data-line-number="3">  <span class="st">&quot;a&quot;</span>,   <span class="dv">4</span>,</a>
<a class="sourceLine" id="cb130-4" data-line-number="4">  <span class="st">&quot;b&quot;</span>,   <span class="dv">6</span>,</a>
<a class="sourceLine" id="cb130-5" data-line-number="5">  <span class="st">&quot;c&quot;</span>,   <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb130-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb130-7" data-line-number="7"></a>
<a class="sourceLine" id="cb130-8" data-line-number="8">trB &lt;-<span class="st"> </span><span class="kw">tribble</span>(</a>
<a class="sourceLine" id="cb130-9" data-line-number="9">  <span class="op">~</span>ID, <span class="op">~</span>var2,</a>
<a class="sourceLine" id="cb130-10" data-line-number="10">  <span class="st">&quot;a&quot;</span>,   <span class="dv">7</span>,</a>
<a class="sourceLine" id="cb130-11" data-line-number="11">  <span class="st">&quot;b&quot;</span>,   <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb130-12" data-line-number="12">  <span class="st">&quot;d&quot;</span>,   <span class="dv">5</span></a>
<a class="sourceLine" id="cb130-13" data-line-number="13">)</a></code></pre></div>
</div><div class="slide section level2">

<p>Since there is a common variable ID we can simply combine these two into a single tibble:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb131-1" data-line-number="1"><span class="kw">full_join</span>(trA, trB, <span class="dt">by =</span> <span class="st">&quot;ID&quot;</span>)</a></code></pre></div>
<pre><code>## # A tibble: 4 x 3
##   ID     var1  var2
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         4     7
## 2 b         6     3
## 3 c         1    NA
## 4 d        NA     5</code></pre>
<p>When the column names differ you can specify it as <code>full_join(x, y, by = c(&quot;a&quot; = &quot;b&quot;))</code> which will match variable <code>a</code> on tibble <code>x</code> to variable <code>b</code> on tibble <code>y</code>.</p>
</div><div class="slide section level2">

<p>You can of course also do this in a workflow setting:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb133-1" data-line-number="1">trA <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">full_join</span>(trB, <span class="dt">by =</span> <span class="st">&quot;ID&quot;</span>)</a></code></pre></div>
<pre><code>## # A tibble: 4 x 3
##   ID     var1  var2
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         4     7
## 2 b         6     3
## 3 c         1    NA
## 4 d        NA     5</code></pre>
</div><div id="adding-rows-and-columns" class="slide section level2">
<h1>Adding rows and columns</h1>
<p>To add rows, use <code>bind_rows()</code> and to add columns, use <code>bind_cols()</code> have a look at the docs for the details. They are pretty much self-explanatory, and analogous to the base R <code>cbind()</code> and <code>rbind()</code> functions.</p>
</div>

  <!-- dynamically load mathjax for compatibility with self-contained -->
  <script>
    (function () {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
      document.getElementsByTagName("head")[0].appendChild(script);
    })();
  </script>

</body>
</html>
